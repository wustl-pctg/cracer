//#include <cilk-lib.cilkh>

#include "../data_structures/DSSkipList.cilkh"
#include "Configuration.h"


////////////////////////////////////////////////////////////////////////////////
//CONSTS
////////////////////////////////////////////////////////////////////////////////
#define  _ACTIONS_ARY_SIZE 2*1024*1024
#define  _SPAWN_MIN 2

////////////////////////////////////////////////////////////////////////////////
//GLOBALS
////////////////////////////////////////////////////////////////////////////////
static Random*        _gRand;
static Configuration* _gConfiguration;

static int  _g_thread_fill_table_size;
static int  _gActionAry[_ACTIONS_ARY_SIZE];
static int* _gRandNumAry;

static tick_t volatile *  _gThreadResultAry;

static int  _gTotalRandNum;
static int  _gNumProcessors;
static int  _gThroughputTime;
       int  _gNumThreads;

static int    _num_ds;
//static ITest* _gDS[1024];
static DSSkipList* _gDS[1024];

static AtomicInteger*   _gThreadStartCounter;
static AtomicInteger*   _gThreadEndCounter;
static Volatile_tick_t* _gStartTime;
static Volatile_tick_t* _gEndTime;
static Volatile_u32*    _gIsStopThreads;

static tick_t         _gResult = 0L;
static tick_t         _gResultAdd = 0L;
static tick_t         _gResultRemove = 0L;
static tick_t         _gResultPeek = 0L;

static volatile _u64  _seed;
//static char     _is_tm=0;
static char     _is_view=0;

////////////////////////////////////////////////////////////////////////////////
//FORWARD DECLARETIONS
////////////////////////////////////////////////////////////////////////////////
void PrepareActions();
void PrepareRandomNumbers(int);
cilk void RunBenchmark();
cilk void recursive_worker_spawn(int, int);
cilk void worker_run(int);
//ITest* CreateDataStructure(char* final alg_name);

cilk int main (int argc, char **argv) {
  int i, iDb;
  _seed = Random_getSeed();
  _gRand = new_Random();
  _gConfiguration = new_Configuration();
  _gStartTime     = new_Volatile_tick_t(0UL);
  _gEndTime       = new_Volatile_tick_t(0UL);
  _gIsStopThreads = new_Volatile_u32(0);
  _gThreadStartCounter = new_AtomicInteger(0);
  _gThreadEndCounter   = new_AtomicInteger(0);


  
  //contaminate memory manager ..............................................
  for(i=0; i < (1024*64); ++i) {
    void* rand_mem;
    rand_mem = (void*)malloc(Random_nextUInt(_gRand, 128)+1);
    free(rand_mem);
  }

  //read benchmark configuration ............................................
  if(!Configuration_read(_gConfiguration, argc, argv)) {
      System_out_println("USAGE: <algorithm> <testNum> <numThreads> <numActions> <maxKey> <insertOps> <deleteOps> <unrandom> <loadFactor> <badHash> <initialCount> <_throughput_time>");
      exit(-1);
  }

  _gNumProcessors   = 4;
  _gNumThreads      = _gConfiguration->_no_of_threads;
  _gTotalRandNum    = Max(_gConfiguration->_capacity, 4*1024*1024);
  _gThroughputTime  = _gConfiguration->_throughput_time;

  //prepare the random numbers ...............................................
  System_err_println(" ");
  System_err_println("    START create random numbers.");
  PrepareActions();
  PrepareRandomNumbers(_gTotalRandNum);
  System_err_println("    END   creating random numbers.");
  System_err_println(" ");

  //run the benchmark ........................................................
  spawn RunBenchmark();
  //print results ............................................................
  if(0 == _gConfiguration->_is_dedicated_mode) {
    System_out_format("%d", (unsigned int)_gResult);
  } else {
    System_out_format("%d %d %d", (unsigned int)_gResultAdd, 
        (unsigned int)_gResultRemove, (unsigned int)_gResultPeek);
  }
  framework_sleep(1*1000);
  for (iDb=0; iDb<_num_ds; ++iDb) {
    DSSkipList_print_custom(_gDS[iDb], _gNumThreads);
    free(_gDS[iDb]);
    _gDS[iDb] = null;
  } 

  return 0;
}

////////////////////////////////////////////////////////////////////////////////
//HELPER FUNCTIONS
////////////////////////////////////////////////////////////////////////////////

void PrepareActions() {
  int add_limit = _gConfiguration->_add_ops;
  int remove_limit = add_limit + _gConfiguration->_remove_ops;
  int iAction;

  for(iAction=0; iAction < _ACTIONS_ARY_SIZE; ++iAction) {
    int rand_num = Random_nextUInt(_gRand,1024*1024)%100;

    if(rand_num < 0 || rand_num >= 100) {
      System_err_println("PrepareActions: Error random number");
      exit(1);
    }

    if(rand_num < add_limit)
      _gActionAry[iAction] = 1;
    else if(rand_num < remove_limit)
      _gActionAry[iAction] = 2;
    else
      _gActionAry[iAction] = 3;
  }
}

void PrepareRandomNumbers(int size) {
  int iRandNum;
  _gRandNumAry = (int*)malloc(sizeof(int)*size);
  for (iRandNum = 0; iRandNum < size; ++iRandNum) {
    if(0 == _gConfiguration->_capacity) {
      _gRandNumAry[iRandNum] = iRandNum+2;
    } else {
      _gRandNumAry[iRandNum] = 
        Random_nextUInt(_gRand, _gConfiguration->_capacity) + 2;
      if(_gRandNumAry[iRandNum] <= 0 || 
          _gRandNumAry[iRandNum] >= (_gConfiguration->_capacity+2)) 
      {
        System_err_println("PrepareRandomNumbers: Error random number");
        exit(1);
      }
    }
  }
}

DSSkipList* CreateDataStructure(char* alg_name) {
  if(0 == strcmp(alg_name, "dsskiplist")) {
    return (new_DSSkipList());
  }

  //..........................................................................
  return null;
}

cilk void RunBenchmark() {
	char _sprintf_str[1024];
	int i, iDb; 
  int table_size;
  int num_add_threads, num_remove_threads, num_peek_threads;
  int iThread, curr_thread;
  //print test information ...................................................
	System_err_println("Benchmark Curr: ");
	System_err_println("--------------");
	fprintf(stderr, "    numOfThreads:      %d\n",
       _gConfiguration->_no_of_threads);
	fprintf(stderr, "    Algorithm1 Name:   %s\n", _gConfiguration->_alg1_name);
	fprintf(stderr, "    Algorithm1 Num:    %d\n", _gConfiguration->_alg1_num);
	fprintf(stderr, "    Algorithm2 Name:   %s\n", _gConfiguration->_alg2_name);
	fprintf(stderr, "    Algorithm2 Num:    %d\n", _gConfiguration->_alg2_num);
	fprintf(stderr, "    Algorithm3 Name:   %s\n", _gConfiguration->_alg3_name);
	fprintf(stderr, "    Algorithm3 Num:    %d\n", _gConfiguration->_alg3_num);
	fprintf(stderr, "    Algorithm4 Name:   %s\n", _gConfiguration->_alg4_name);
	fprintf(stderr, "    Algorithm4 Num:    %d\n", _gConfiguration->_alg4_num);
	fprintf(stderr, "    NumProcessors:     %d\n", _gNumProcessors);
	fprintf(stderr, "    testNo:            %d\n", _gConfiguration->_test_no);
	fprintf(stderr, "    addOps:            %d\n", _gConfiguration->_add_ops);
	fprintf(stderr, "    removeOps:         %d\n", _gConfiguration->_remove_ops);
	fprintf(stderr, "    throughput_time:   %d\n", 
      _gConfiguration->_throughput_time);
	fprintf(stderr, "    is_dedicated_mode: %d\n", 
      _gConfiguration->_is_dedicated_mode);
	fprintf(stderr, "    tm_status:         %d\n   (0=Norm; else View)", 
      _gConfiguration->_tm_status);
	fprintf(stderr, "    read_write_delay:  %d\n", 
      _gConfiguration->_is_dedicated_mode);

	_is_view = (0 != _gConfiguration->_tm_status);

	sprintf(_sprintf_str, "%f",  _gConfiguration->_load_factor);
	fprintf(stderr, "    loadFactor:        %s\n", _sprintf_str);
	fprintf(stderr, "    initialCapacity:   %d\n", _gConfiguration->_capacity);
	System_err_println(" ");
	_num_post_read_write = _gConfiguration->_read_write_delay;

	//create appropriate data-structure ........................................
	_num_ds=0;
	for (i=0; i<(_gConfiguration->_alg1_num); ++i) {
		DSSkipList* tmp = CreateDataStructure(_gConfiguration->_alg1_name);
		if(null != tmp) {
			_gDS[_num_ds++] = tmp;
		}
	}
	for (i=0; i<(_gConfiguration->_alg2_num); ++i) {
		DSSkipList* tmp = CreateDataStructure(_gConfiguration->_alg2_name);
		if(null != tmp) {
			_gDS[_num_ds++] = tmp;
		}
	}
	for (i=0; i<(_gConfiguration->_alg3_num); ++i) {
		DSSkipList* tmp = CreateDataStructure(_gConfiguration->_alg3_name);
		if(null != tmp) {
			_gDS[_num_ds++] = tmp;
		}
	}
	for (i=0; i<(_gConfiguration->_alg4_num); ++i) {
		DSSkipList* tmp = CreateDataStructure(_gConfiguration->_alg4_name);
		if(null != tmp) {
			_gDS[_num_ds++] = tmp;
		}
	}

	//calculate how much each thread should add the data-structure initially ...
  table_size 
      = (int)((_gConfiguration->_capacity) * (_gConfiguration->_load_factor));
	_g_thread_fill_table_size = table_size / _gNumThreads;

	//create benchmark threads .................................................
	/*System_err_println("    START creating threads.");
	_gThreads               =  new Thread*[_gNumThreads];*/
	//_gThreadResultAry       =  new tick_t[_gNumThreads];
	_gThreadResultAry   = (tick_t*)malloc(sizeof(tick_t)*_gNumThreads);
  memset((void*)_gThreadResultAry, 0, sizeof(int)*_gNumThreads);

	num_add_threads 
      = (int) ceil(_gNumThreads * (_gConfiguration->_add_ops)/100.0);
	num_remove_threads    
      = (int) floor(_gNumThreads * (_gConfiguration->_remove_ops)/100.0);
	num_peek_threads      
      = _gNumThreads - num_add_threads - num_remove_threads;

	/*if(0 == _gConfiguration->_is_dedicated_mode) {
		for(iThread = 0; iThread < _gNumThreads; ++iThread) {
			_gThreads[iThread] =  new MixThread(iThread);
		}
	} else {*/
	/*fprintf(stderr, "    num_add_threads:    %d\n" + num_add_threads);
	fprintf(stderr, "    num_remove_threads: %d\n" + num_remove_threads);
	fprintf(stderr, "    num_peek_threads:   %d\n" + num_peek_threads);*/

	/*int curr_thread=0;
		for(int iThread = 0; iThread < num_add_threads; ++iThread) {
			_gThreads[curr_thread] =  new MixThread(curr_thread);
			++curr_thread;
		}
		for(int iThread = 0; iThread < num_remove_threads; ++iThread) {
			_gThreads[curr_thread] =  new MixThread(curr_thread);
			++curr_thread;
		}
		for(int iThread = 0; iThread < num_peek_threads; ++iThread) {
			_gThreads[curr_thread] =  new MixThread(curr_thread);
			++curr_thread;
		}
	}
	System_err_println("    END   creating threads.");
	System_err_println("");*/
	yield();

	//start the benchmark threads ..............................................
	System_err_println("    START threads.");
	/*for(int iThread = 0; iThread < _gNumThreads; ++iThread) {
		_gThreads[iThread]->start();
	}*/
  spawn recursive_worker_spawn (0, _gNumThreads);
	
  System_err_println("    END START  threads.");
	System_err_println(" ");

	//wait the throughput time, and then signal the threads to terminate ...
	//yield();
	framework_sleep(_gThroughputTime*1000);
	Volatile_u32_set(_gIsStopThreads,1);

	//join the threads .........................................................
	/*for(int iThread = 0; iThread < _gNumThreads; ++iThread) {
		Thread::yield();
		Thread::yield();
		_gThreads[iThread]->join();
	}*/
  sync;
	System_err_println("    ALL threads terminated.");
	System_err_println(" ");

	//calculate threads results ................................................
	_gResult = 0;
	_gResultAdd = 0;
	_gResultRemove = 0;
	_gResultPeek = 0;
	if(0 == _gConfiguration->_is_dedicated_mode) {
		for(iThread = 0; iThread < _gNumThreads; ++iThread) {
			_gResult += _gThreadResultAry[iThread];
		}
	} else {
		curr_thread=0;
		for(iThread = 0; iThread < num_add_threads; ++iThread) {
			_gResultAdd += _gThreadResultAry[curr_thread];
			++curr_thread;
		}
		for(iThread = 0; iThread < num_remove_threads; ++iThread) {
			_gResultRemove += _gThreadResultAry[curr_thread];
			++curr_thread;
		}
		for(iThread = 0; iThread < num_peek_threads; ++iThread) {
			_gResultPeek += _gThreadResultAry[curr_thread];
			++curr_thread;
		}
	}

	//print benchmark results ..................................................
	for (iDb=0; iDb<_num_ds; ++iDb) {
		fprintf(stderr, "    %s Num elm: %d\n",
        DSSkipList_name(_gDS[iDb]),DSSkipList_size(_gDS[iDb]));
	}

	//free resources ...........................................................
	free(_gRandNumAry);
	//free(_gThreadResultAry);
	//free(_gThreads);

	_gRandNumAry = null;
	_gThreadResultAry = null;
	//_gThreads = null;

	//return benchmark results ................................................
	_gResult         /= (long)(_gEndTime - _gStartTime);
	_gResultAdd      /= (long)(_gEndTime - _gStartTime);
	_gResultRemove   /= (long)(_gEndTime - _gStartTime);
	_gResultPeek     /= (long)(_gEndTime - _gStartTime);
}

cilk void recursive_worker_spawn(int low, int high) {
  int i, mid;
  if (high - low < _SPAWN_MIN) {
    for (i=low; i < high; ++i)
      spawn worker_run(i);
    return;
  }
  
  mid = low + ceil((high - low)/2.0);
  spawn recursive_worker_spawn(low, mid);
  spawn recursive_worker_spawn(mid, high);
  return;
}

cilk void worker_run(int _threadNo) {
  int iNum, iDb, i;
  int start_counter;
  int iNumAdd, iNumRemove, iNumContain, iOp;
  int end_counter;
  tick_t action_counter;

  //printf("In worker_run\n");
  for (iNum=0; iNum < (_g_thread_fill_table_size/16); ++iNum) {
    for (iDb=0; iDb<_num_ds; ++iDb) {
      for (i=0; i<16; ++i) {
        char dummy;
        dummy = spawn DSSkipList_add(_gDS[iDb], _threadNo, 
          Random_getRandomInt(&_seed, _gConfiguration->_capacity) + 2);
      }
    }
  }

  //printf("Finished initial building\n");
  //TODO: what is this for?
  /*for(iDb=0; iDb<_num_ds; ++iDb) {
    DSSkipList_cas_reset(_gDS[iDb],_threadNo);
  }*/

  start_counter = AtomicInteger_getAndIncrement(_gThreadStartCounter);
  if(start_counter == (_gNumThreads-1))
    Volatile_tick_t_set(_gStartTime, currentTimeMillis());

  //while((_gNumThreads) != AtomicInteger_get(_gThreadStartCounter))
  //  {/*int j=AtomicInteger_get(_gThreadStartCounter);*/continue;}

  //printf("Finished waiting on start counter\n");

  action_counter = 0;
  iNumAdd = start_counter*1024;
  iNumRemove = start_counter*1024;
  iNumContain = start_counter*1024;
  iOp = start_counter*128;
  do {
    int op = _gActionAry[iOp];

    if(1==op) {
      for (iDb=0; iDb<_num_ds; ++iDb) {
        //int enq_value = 
        char dummy; 
        dummy = 
          spawn DSSkipList_add(_gDS[iDb], _threadNo, _gRandNumAry[iNumAdd]);
        ++iNumAdd;
        if(iNumAdd >= _gTotalRandNum)
          iNumAdd=0;
      }
      ++action_counter;
    } else if(2==op) {
      for (iDb=0; iDb<_num_ds; ++iDb) {
        //int deq_value =_gDS[iDb]->remove(_threadNo, _gRandNumAry[iNumRemove]);
        fprintf(stderr, "Test tried to call remove, not implemented\n");
        ++iNumRemove;
        if(iNumRemove >= _gTotalRandNum) { iNumRemove=0; }
      }
      ++action_counter;
    } else {
      for (iDb=0; iDb<_num_ds; ++iDb) {
        DSSkipList_contain(_gDS[iDb], _threadNo, _gRandNumAry[iNumContain]);
        ++iNumContain;
        if(iNumContain >= _gTotalRandNum) { iNumContain=0; }
      }
      ++action_counter;
    }
    ++iOp;
    if (iOp >= _ACTIONS_ARY_SIZE) {
      iOp=0;
    }

    //TODO: do we need this?
    if (_gConfiguration->_read_write_delay > 0) {
      DSSkipList_post_computation(_gDS[0], _threadNo);
    }

    if (0 != _gIsStopThreads) {
      break;
    }

  } while(true);

  //save end benchmark time ..............................................
  end_counter = AtomicInteger_getAndIncrement(_gThreadEndCounter);
  if(end_counter == (_gNumThreads-1)) {
    Volatile_tick_t_set(_gEndTime, currentTimeMillis());
  }

  //save thread benchmark result .........................................
  _gThreadResultAry[_threadNo] = action_counter;

  yield();
  
  return; 
}







