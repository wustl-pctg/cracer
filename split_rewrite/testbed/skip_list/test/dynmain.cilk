#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>

#include <sys/types.h>
#include <signal.h>

#include "../data_structures/DYNSkipList.cilkh"
#include "./timer.h"
//#include "DYNConfiguration.h"

#define CAPACITY 4*1024*1024*8 //TODO: bound this better
#define MAX_BENCHMARK_RUNTIME 1
#define NUM_OPS 5000000
#define NUM_THREADS 16 // not balanced for non-power of 2
//#define SIGALRM 14

static int            _gSeed;
static int            _gNumThreads;
static int            _gInitSize;
static int*           _gRandNumAry;
static int*           _gOpCounts;

static int            _gTotalRandNum;

volatile char         _gStopThreads;


void init_arrays(int size) {
  int iRandNum, iThread;
  _gOpCounts = (int*)malloc(sizeof(int)*_gNumThreads);
  for (iThread = 0; iThread < _gNumThreads; ++iThread) {_gOpCounts[iThread]=0;}
  _gRandNumAry = (int*)malloc(sizeof(int)*size);
  for (iRandNum = 0; iRandNum < size; ++iRandNum) {
    _gRandNumAry[iRandNum] = (rand()%size) + 3;
    if(_gRandNumAry[iRandNum] <= 0 ||
        _gRandNumAry[iRandNum] > (size+2))
    {
      fprintf(stderr, "PrepareRandomNumbers: Error random number\n");
      exit(1);
    }
  }
}

cilk void startDeadline() {
  sleep(MAX_BENCHMARK_RUNTIME);
  _gStopThreads = 1;
}

void print_results() {
  int i, num_ops = 0;
  for (i=0; i < _gNumThreads; ++i) {
    num_ops += _gOpCounts[i];
  }
  printf("num_ops: %d, runtime(ms): %lf\n", num_ops, getWallTime());
  return;
}

void contaminate_memory() {
  int i;
  //contaminate memory manager ..............................................
  for(i=0; i < (1024*64); ++i) {
    void* rand_mem;
    rand_mem = (void*)malloc((rand()%128)+1);
    free(rand_mem);
  }
}

void reset_counters() {
  int iThread;
  for (iThread = 0; iThread < _gNumThreads; ++iThread) {_gOpCounts[iThread]=0;}
}

cilk void recursiveOp(cilk void (*op)(T), int iLeaf, int level) {
  if (pow(2, level) < _gNumThreads) {
    spawn recursiveOp(op, 2*iLeaf, level+1);
    spawn recursiveOp(op, 2*iLeaf+1, level+1);
  } else {
    int max_ops = NUM_OPS/_gNumThreads;
    int rand_index = iLeaf*max_ops;
    int rand_index_max = rand_index + max_ops;
    if (rand_index_max > _gTotalRandNum) {
      fprintf(stderr, "Rand array too small\n");
      exit(1);
    }
    if (iLeaf >= _gNumThreads)
      return;
    //printf("level:%d, index:%d\n, max_ops:%d, rand_index:%d, index_max:%d\n", 
    //  level, iLeaf, max_ops, rand_index, rand_index_max);
    while (!_gStopThreads && rand_index < rand_index_max) {
      //printf("doing add\n");
      spawn op(_gRandNumAry[rand_index]);
      ++_gOpCounts[iLeaf];
      ++rand_index; 
    }
  }
  return;
}

void abort_benchmark(int num_signal) {
  _gStopThreads=1;
}

cilk void runDYNSkipListBenchmark() {
  int i;
  initList();
  reset_counters();
  if (NUM_OPS + _gInitSize > CAPACITY) {
    fprintf(stderr, "Capacity too small\n");
    exit(1);
  }

  for (i=0; i < _gInitSize; ++i)
    insertNode(rand()%CAPACITY+3);  

  contaminate_memory();
  _gStopThreads=0;

  signal(SIGALRM, abort_benchmark);
  alarm(MAX_BENCHMARK_RUNTIME);
  //abort_benchmark(0);
  //spawn startDeadline();
  startTimer();
  spawn recursiveOp(&batchInsertNode, 0, 0);
  sync;
  stopTimer();
  print_results();
}

void runSeqSkipListBenchmark() {
  int i, rand_index, rand_index_max;
  initList();
  reset_counters();
  if (NUM_OPS + _gInitSize > CAPACITY) {
    fprintf(stderr, "Capacity too small\n");
    exit(1);
  }

  for (i=0; i < _gInitSize; ++i)
    insertNode(rand()%CAPACITY+3);  

  contaminate_memory();

  _gStopThreads=0;
  signal(SIGALRM, abort_benchmark);
  alarm(MAX_BENCHMARK_RUNTIME);
  startTimer();
   
  rand_index = 0;
  rand_index_max = NUM_OPS;
  if (NUM_OPS > _gTotalRandNum)
    fprintf(stderr,"rand num array smaller than NUM_OPS\n");
    //printf("level:%d, index:%d\n, max_ops:%d, rand_index:%d, index_max:%d\n", 
    //  level, iLeaf, max_ops, rand_index, rand_index_max);
  while (!_gStopThreads && rand_index < rand_index_max) {
    //printf("doing add\n");
    insertNode(_gRandNumAry[rand_index]);
    ++_gOpCounts[0];
    ++rand_index; 
  }
 
  stopTimer();
  print_results();
}

void runFCSkipListBenchmark() {
  
}

cilk void runBenchmark(char* benchmark_name) {
  if (!strcmp(benchmark_name, "skiplist")) {
    printf("\n\nDynamic Skip List\n------------------------------\n");
    spawn runDYNSkipListBenchmark();
    sync;
    printf("\n\nSequential Skip list\n-----------------------------\n");
    runSeqSkipListBenchmark();
  } else {
    fprintf(stderr, "Unrecognized benchmark: %s\n", benchmark_name);
  }
}



void usage() {
  fprintf(stderr, "test_dyn <benchmark> <num_threads>\n");
}

cilk int main (int argc, char **argv) {
  _gSeed = time(NULL);
  srand(_gSeed);
  _gTotalRandNum = CAPACITY;
  _gStopThreads = 0;

  if (argc < 3) {
    usage();
    return EXIT_FAILURE;
  }
  _gNumThreads = atoi(argv[2]);
  printf("benchmark: %s, num threads: %d\n", argv[1], atoi(argv[2]));

  init_arrays(_gTotalRandNum); 

  if (argc > 3)
    _gInitSize = atoi(argv[3]);
  else 
    _gInitSize = 0;  

  spawn runBenchmark(argv[1]);
  sync;

  return EXIT_SUCCESS;
}


