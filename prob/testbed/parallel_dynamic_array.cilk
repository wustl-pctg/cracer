#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#define VOID_DATA (int)-INFINITY
#define DEFAULT_SIZE 10
#define PARALLEL_CUTOFF 5

/*! \file
	\brief Dynamically Resizing Array that supports copying and inserting in parallel*/

//Tyler Romero
/*-----------------------Structs------------------------------------------------*/
/*! \struct
	\brief A dynamically resizing array that supports parallel operations*/
struct dyn_array
{
	int* array;				//!<The array used by parallel_dynamic_array.cilk, 
	size_t size;			//!<The total memory allocated to the array, in terms of integer pointers
	size_t used;			//!<The current number of integers held in the array
};
typedef struct dyn_array dyn_array;




/*-----------------------Function Declarations----------------------------------*/
dyn_array* create_array();		//Initializes a new dynamic array
cilk void resize(dyn_array* current_array, int new_size);
cilk void batch_push_back(dyn_array* current_array, int* input, int input_size);	//Adds input array to the end of dynamic array
cilk void push_back(dyn_array* current_array, int input);		//Adds integer to the end of the dynamic array
int safe_access(dyn_array* current_array, int index);		//Gives an error and returns VOID_DATA if index is out of range
void print_array(dyn_array* current_array);
cilk void parallel_for(dyn_array* current_array, int* other_array, cilk void(*parallel_function)(dyn_array*,int*,int), int start, int end);
cilk void copy(dyn_array* current_array, int* temp, int i);
cilk void insert(dyn_array* current_array, int* input, int i);




/*----------------------create_array and delete_array-----------------------------------------*/
dyn_array* create_array()
{
	dyn_array* new_array = malloc(sizeof(dyn_array));
	if(new_array == NULL)
	{
		printf("\nError allocating memory for new array");
		return new_array;
	}
	
	//Initializations
	new_array->size = DEFAULT_SIZE;
	new_array->used = 0;
	new_array->array = (int*)malloc(DEFAULT_SIZE*sizeof(int));
	return new_array;
}

void delete_array(dyn_array* dead_array)
{
	free(dead_array->array);
	free(dead_array);
}




/*----------------------resize--------------------------------------------------*/
cilk void resize(dyn_array* current_array, int new_size)		//Sets the size of current_array to new_size
{
	//int i;
	int* temp;
	
	if(current_array->size > new_size)
	{
		printf("Error: Sizing Problem");
		return;
	}
	
	current_array->size = new_size;
	temp = (int*)malloc(current_array->size * sizeof(int));		//Reserve a new chunk of memory
	
	/*for(i=0; i<current_array->used; ++i){		//PARALLEL FOR
		temp[i] = current_array->array[i];
	}*/
	spawn parallel_for(current_array, temp, copy, 0, current_array->used);		//Copy to new array in parallel
	sync;
	
	free(current_array->array);
	current_array->array = temp;
}




/*----------------------push_back------------------------------------------------*/
cilk void batch_push_back(dyn_array* current_array, int* input, int input_size)
{
	//int i;
	
	if(input_size+current_array->used > current_array->size)	//If current_array needs more space
	{
		spawn resize(current_array, 2*(current_array->used+input_size));
		sync;
	}
	
	/*for(i=0; i<input_size; ++i){				//PARALLEL_FOR
		current_array->array[current_array->used + i] = input[i];
	}*/
	spawn parallel_for(current_array, input, insert, 0, input_size);	//Insert input into current_array in parallel
	sync;

	current_array->used = current_array->used + input_size;		//Update the current amout of used space
}

cilk void push_back(dyn_array* current_array, int input)
{
	spawn batch_push_back(current_array, &input, 1);		//Need to implement with batchify function
	sync;
}




/*---------------------safe_access-----------------------------------------------------*/
int safe_access(dyn_array* current_array, int index)
{
	if(index < current_array->used)
	{
		return current_array->array[index];
	}
	else
	{
		printf("Error: index is out of range\n");
		return VOID_DATA;
	}
}




/*-----------------------print_array----------------------------------------------*/
void print_array(dyn_array* current_array)
{
	int i;
	printf("\n[  ");
	for(i=0; i<current_array->used; ++i)
	{
		if(!(i%20) && !(i==0)) printf("\n   ");
		
		printf("%d  ", current_array->array[i]);
	}
	printf("]\n");
	printf("Size: %d\tUsed: %d\n", current_array->size, current_array->used);
}



/*----------------------parallel_for-----------------------------------------------*/
cilk void parallel_for(dyn_array* current_array, int* other_array, cilk void(*parallel_function)(dyn_array*,int*,int), int start, int end)
{
	int middle = start+(end-start)/2;
	if (end-start<=PARALLEL_CUTOFF) {
		for (start; start < end; ++start) {
            spawn parallel_function(current_array, other_array, start);
		}
    }
	else
	{		
		spawn parallel_for(current_array, other_array, parallel_function, start, middle); 	//start -> middle-1
		spawn parallel_for(current_array, other_array, parallel_function, middle+1, end); 	//middle+1 -> end-1
		spawn parallel_function(current_array, other_array, middle);						//middle
	}
}

cilk void copy(dyn_array* current_array, int* temp, int i)	//Used by parallel_for
{
	temp[i] = current_array->array[i];
}

cilk void insert(dyn_array* current_array, int* input, int i)	//Used by parallel_for
{
	current_array->array[current_array->used + i] = input[i];
}

