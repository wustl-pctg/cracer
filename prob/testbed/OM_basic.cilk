#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <cilk-lib.cilkh>

#define VOID_DATA (int)-INFINITY

//Tyler Romero
//Most basic implementation of OM data structure

//Order Maintenance Data Structure
	//A linked list that has labels that can be compared to determine which of the list items comes first

//Public Functions
	//void insert(x,y)
	//ptr order(x,y)
	
//Private Functions
	//void distribute()
	//etc

//----------------------Structs----------------------------------------------------------------------------
//A linked list item for an OM data struct that containts a spot for a label
struct itemOM
{
	void* data;
	size_t label;		//[0,OM->size^2)
	struct itemOM* next;
	struct itemOM* prev;
};
typedef struct itemOM itemOM;

//The actual OM data structure
struct datastructOM
{
	itemOM* list;
	int size; //The number of itemOMs in the list
};
typedef struct datastructOM datastructOM;

//----------------------Function Declarations--------------------------------------------------------------
datastructOM* create_OM();
void delete_OM(datastructOM* dead_OM);
itemOM* create_item(void* new_data);
void delete_list(itemOM* dead_item);

void insert(datastructOM* current_OM, itemOM* insert_item, itemOM* existing_item);
void delete(datastructOM* current_OM, itemOM* dead_item);
itemOM* order(itemOM* itemA, itemOM* itemB);

int label_space(datastructOM* current_OM);
int is_space_left(itemOM* current_item);
void basic_redistribute(datastructOM* current_OM);

//----------------------Create and Delete---------------------------------------

datastructOM* create_OM()
{
	datastructOM* new_OM = (datastructOM*)malloc(sizeof(datastructOM));
	if(new_OM == NULL) printf("Error Allocating Memory\n");
	new_OM->list = NULL;
	new_OM->size = 0;
	return new_OM;
}

void delete_OM(datastructOM* dead_OM)
{
	delete_list(dead_OM->list);
	free(dead_OM);
	return;
}

itemOM* create_item(void* new_data)		//To 'delete' this, just free it
{
	itemOM* new_item = (itemOM*)malloc(sizeof(itemOM));
	if(new_item == NULL) printf("Error Allocating Memory\n");
	new_item->data = new_data;
	new_item->label = VOID_DATA;
	new_item->next = NULL;
	new_item->prev = NULL;
	return new_item;
}

void delete_list(itemOM* dead_item)
{
	if(dead_item==NULL)
		return;
	else
	{
		delete_list(dead_item->next);
		free(dead_item);
		return;
	}
}



//----------------------Insert-----------------------------------------

void insert(datastructOM* current_OM, itemOM* insert_item, itemOM* existing_item)		//Sequential Implementation - insert_item is inserted after existing_item
{																						//Need to make it so
	if(insert_item == NULL)
	{
		printf("Error: insert_item was NULL\n");
		return;
	}
	
	if(existing_item == NULL)		//Insert insert_item first in the list
	{
		insert_item->prev = NULL;
		insert_item->next = current_OM->list;
		current_OM->list = insert_item;
		current_OM->size++;
		insert_item->label = 0;																		//NEED TO FIX THE LABELS IN THIS CASE
		return;
	}
	else if(existing_item->next == NULL)	//Existing item is the last in the list
	{
		existing_item->next = insert_item;
		insert_item->prev = existing_item;
		insert_item->next = NULL;
		current_OM->size++;
		insert_item->label = label_space(current_OM)-1;						//Label Item
		return;
	}
	else
	{
		insert_item->prev = existing_item;
		insert_item->next = existing_item->next;
		existing_item->next = insert_item;
		current_OM->size++;
		insert_item->label = existing_item->label + (insert_item->next->label-existing_item->label)/2;	//+1 ?
		if(!is_space_left(insert_item))		//If more label space will be needed, redistribute
		{
			//printf("insert_item->label = %d\texisting_item->label = %d\n", insert_item->label,existing_item->label);
			basic_redistribute(current_OM);
		}
		return;
	}
}

//----------------------Delete-----------------------------------------
void delete(datastructOM* current_OM, itemOM* dead_item)
{
	if(dead_item->next == NULL)					//If item is last in list
	{
		dead_item->prev->next == NULL;
		free(dead_item);
	}
	else if(dead_item->prev == NULL)			//If item is first in list
	{
		current_OM->list = dead_item->next;
		dead_item->next->prev = NULL;
		free(dead_item);
	}
	else
	{
		dead_item->prev->next = dead_item->next;
		dead_item->next->prev = dead_item->prev;
		free(dead_item);
	}
}

//----------------------Order------------------------------------------
itemOM* order(itemOM* itemA, itemOM* itemB)		//Sequential Implementation
{
	if(itemA->label > itemB->label)
		return itemB;	//Lower labels indicate that they are higher in the order (closert to the front of the list)
	else if(itemB->label > itemA->label)
		return itemA;
	else{
		printf("Error: items have the same label; should be impossible\n");
		return NULL;
	}	
}

//---------------------Other-------------------------------------------
int label_space(datastructOM* current_OM)
{
	//printf("label_space\n");
	return (current_OM->size) * (current_OM->size);
}

int is_space_left(itemOM* current_item)	//0 for no space left, 1 for space left
{
	//printf("is_space_left\n");
	if(current_item->next != NULL && current_item->prev != NULL){
		if(current_item->next->label <= current_item->label+1 || current_item->prev->label >= current_item->label-1){
			return 0;
		}
		else{
			return 1;
		}
	}
	else{
		return 0;
	}
}

void basic_redistribute(datastructOM* current_OM)
{
	int j = 0;
	itemOM* current_item = current_OM->list;
	
	//printf("basic_redistribute\n");
	while(j<current_OM->size && current_item != NULL)		//Check this
	{
		current_item->label = j*current_OM->size;
		if(current_item->label >= label_space(current_OM)){
			printf("Labeling Error\n");
		}
		//printf("j=%d\tlabel=%d\n",j,current_item->label);
		++j;
		current_item = current_item->next;
	}
}



//------------------------Print---------------------------------------
void print_OM(datastructOM* current_OM)
{
	itemOM* current_item = current_OM->list;
	printf("\nList:\n");
	while(current_item!=NULL)
	{
		printf("%d\t", current_item->label);
		current_item = current_item->next;
	}
	printf("\nSize: %d\n", current_OM->size);
}