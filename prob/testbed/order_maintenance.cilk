#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <cilk-lib.cilkh>

#define VOID_DATA (int)-INFINITY
#define M 32	//M = Tag Universe Size; Power of 2

//Tyler Romero
//Binary Tree OM Structure
//Has a leaf for every possible label
//Will eventually support multiple insertions in parallel

//----Structs-----------
enum bool{false,true};

struct nodeOM
{
	struct nodeOM *right, *left;
	int height;	//Height 0 = leaf
	int count; //Number of itemOMs below this node, max is 2^height
	struct nodeOM *parent;	//NULL if the node is the root
	struct itemOM* item;	//Only leafs will not be NULL
};
typedef struct nodeOM nodeOM;

struct itemOM
{
	struct itemOM *next, *prev;
	struct nodeOM *parent;
	int label;
	void* data;
};
typedef struct itemOM itemOM;

struct datastructOM
{
	struct nodeOM* root;
	int countOM;	//Number of leafs
	
};
typedef struct datastructOM OM;

//----Declarations------------
void individual_insert(OM* current_OM, itemOM* existing_item, itemOM* insert_item);
enum bool individual_order(itemOM* itemA, itemOM* itemB);

void recursive_relabel(nodeOM* current_node, itemOM** item_array, int size, int label);
nodeOM* recursive_find_low_density(nodeOM* current_node, double theshold, double T);
nodeOM* recursive_search_and_update_tree(nodeOM* current_node, int key, int sum);
double density(nodeOM* current_node);

	//Initializations
OM* create_OM(itemOM* first_item);
nodeOM* recursive_create_tree(nodeOM* root, int height);
nodeOM* create_nodeOM();
itemOM* create_itemOM(void* data);

	//Print
void print_OM(OM* current_OM);
void recursive_print_OM(nodeOM* current_node, int label);




//-------individual insert-----------------------
//NEED TO TEST AND DEBUG, should be fully implemented
void individual_insert(OM* current_OM, itemOM* existing_item, itemOM* insert_item)
{
	nodeOM* temp;
	itemOM* temp_item;
	itemOM** item_array;
	int i;
	
	//Insert into linked list
	printf("insert into list\n");
	insert_item->prev = existing_item;
	insert_item->next = existing_item->next;
	existing_item->next = insert_item;
	insert_item->next->prev = insert_item;
	
	//Give it a label	//IF IM RIGHT, THERE WILL ALWAYS BE SPACE
	printf("label\n");
	if(insert_item->next == existing_item)	//If there is only one existing item in the list
	{
		printf("A\n");
		insert_item->label = floor((M+existing_item->label)/2);	//Should always be just M/2
	}
	else if(existing_item->label == M-1)	//If existing item is the last item in the label space
	{
		printf("Tyler's math is probably wrong");
	}
	else									//A normal insertion
	{
		printf("B\n");
		insert_item->label = floor((insert_item->next->label+insert_item->prev->label)/2);
	}
	
	//Insert into tree (Is this efficient enough???)
	printf("Put in tree\n");
	printf("insert item label: %d\n", insert_item->label);
	temp = recursive_search_and_update_tree(current_OM->root, insert_item->label,0);	//O(log2(M))
	temp->item = insert_item;
	insert_item->parent = temp;


	//Relabel the smallest enclosing range that is not overflowing

	temp = recursive_find_low_density(insert_item->parent, 1.0, 1.1);

	if(temp == NULL)	//Base case, root is overflowing
	{
		printf("Root overflowed - Base Case\n");
		//Double size of tree by adding a node on top of root
		temp = create_nodeOM();
		temp->right = create_nodeOM();
		temp->left = current_OM->root;
		current_OM->root = temp;
		temp->right->height = temp->left->height;
		temp->height = temp->left->height + 1;
		temp->left->parent = temp;
		temp->right->parent = temp;
		temp->count = temp->left->count;
		//Build right side of tree
		recursive_create_tree(temp->right,temp->right->height);
		//Hypothetically, density should be low enough now
	}
	printf("Create item array\n");
	item_array = (itemOM**)malloc(temp->count*sizeof(itemOM*));
	temp_item = insert_item;
	for(i=0; i<temp->count; ++i)	//THIS COULD BE BAD!!!
	{
		item_array[i] = temp_item;
		temp_item->parent->item = NULL;	//Strip items from the tree
		temp_item->parent = NULL;
		temp_item = temp_item->next;
	}
	printf("Reinsert and relabel\n");
	printf("Size: %d\n", temp->count);
	recursive_relabel(temp, item_array, temp->count, item_array[0]->label);	//Reinsert and relabel items
	printf("Done inserting\n");
}

void recursive_relabel(nodeOM* current_node, itemOM** item_array, int size, int label)	//O(log(M))
{
	//SOME SORT OF PROBLEM WITH THIS!!!
	if(size>1 && current_node->height != 0)
	{
		printf("A\n");
		recursive_relabel(current_node->left, item_array, floor(size/2), label);
		recursive_relabel(current_node->right, &item_array[(int)(size-floor(size/2))], size-floor(size/2), label+pow(2,current_node->height-1));
	}
	else if(current_node->height != 0 && size == 1)
	{
		printf("B\n");
		recursive_relabel(current_node->left, item_array, size, label);
	}
	else if(current_node->height == 0 && size != 1)
	{
		printf("Something was wrong with Tyler's math");
		return;
	}
	else	//Height should = 0
	{
		printf("C\n");
		current_node->item = item_array[0];
		printf("Item from item array: %p\n",item_array[0]);
		printf("2\n");
		if(current_node->item != NULL)
		{
			current_node->item->label = label;
			printf("3\n");
			current_node->item->parent = current_node;
			printf("4\n");
		}
	}
}

nodeOM* recursive_find_low_density(nodeOM* current_node, double threshold, double T) //O(log2(M)) worst case
{
	if(current_node->height == 0)
		threshold = 1.0;
	else
		threshold = threshold/T;
	
	if(current_node->parent == NULL)
		return NULL;
	else if(density(current_node) >= threshold)	//If it is in overflow, move up the tree and try again
	{
		printf("Density: %f\tthreshold: %f (Overflow)\n",density(current_node),threshold);
		return recursive_find_low_density(current_node->parent, threshold, T);
	}
	else	//It is not in overflow, relabel below
	{
		printf("Density: %f\tthreshold: %f\n",density(current_node),threshold);
		return current_node;
	}
}

nodeOM* recursive_search_and_update_tree(nodeOM* current_node, int key, int sum)	//O(log2(M))
{
	current_node->count++;
	if(current_node->height==0)
		return current_node;
	
	if(pow(2,current_node->height-1)+sum > key)	//Search left
		return recursive_search_and_update_tree(current_node->left,key,sum);
	else						//Search right
		return recursive_search_and_update_tree(current_node->right,key,sum+pow(2,current_node->height-1));
}

//--------individual order----------------------
enum bool individual_order(itemOM* itemA, itemOM* itemB)	//True if itemA is earlier in the list than itemB
{
	if(itemA->label == itemB->label)
	{
		printf("Error: Input items must be distinct items from the same data structure\n");
		return false;
	}
	else if(itemA->label < itemB->label) return true;
	else return false;
}


//-----Other-----------
double density(nodeOM* current_node)
{
	return (double)((double)current_node->count)/((double)pow(2,current_node->height));	//Might have over-cast this
}

//----Initializations--------
OM* create_OM(itemOM* first_item)	//Data is for the first inserted item
{
	nodeOM* temp_node;
	OM* new_OM = (OM*)malloc(sizeof(OM));
	if(new_OM == NULL)
	{
		printf("Error Allocating Memory\n");
		return NULL;
	}
	//Initialize OM
	new_OM->root = create_nodeOM();
	new_OM->root->height = log2(M);
	new_OM->countOM = M;
	//Initialize first item
	temp_node = recursive_create_tree(new_OM->root,new_OM->root->height);
	temp_node->item = first_item;
	temp_node->item->parent = temp_node;
	temp_node->item->next = temp_node->item;	//Begin circularly linked list
	temp_node->item->prev = temp_node->item;
	temp_node->item->label = 0;
	do{
		temp_node->count++;
		temp_node = temp_node->parent;
	}while(temp_node != NULL);
	return new_OM;
}

nodeOM* recursive_create_tree(nodeOM* root, int height)	//Height of the node being inputted	//PARALLELIZE
{
	if(height <= 0)
	{
		return root;
	}
	root->left = create_nodeOM();
	root->left->height = height - 1;
	root->left->parent = root;
	root->right = create_nodeOM();
	root->right->height = height - 1;
	root->right->parent = root;
	recursive_create_tree(root->right,root->right->height);
	return recursive_create_tree(root->left,root->left->height);
}

nodeOM* create_nodeOM()
{
	nodeOM* new_node = (nodeOM*)malloc(sizeof(nodeOM));
	if(new_node == NULL)
	{
		printf("Error Allocating Memory\n");
		return NULL;
	}
	new_node->right = NULL;
	new_node->left = NULL;
	new_node->parent = NULL;
	new_node->height = VOID_DATA;
	new_node->count = 0;
	new_node->item = NULL;
	return new_node;
}

itemOM* create_itemOM(void* data)
{
	itemOM* new_item = (itemOM*)malloc(sizeof(itemOM));
	if(new_item == NULL)
	{
		printf("Error Allocating Memory\n");
		return NULL;
	}
	new_item->next = NULL;
	new_item->prev = NULL;
	new_item->parent = NULL;
	new_item->label = VOID_DATA;
	new_item->data = data;
	return new_item;
}

//-------Print-----------------
void print_OM(OM* current_OM)
{
	recursive_print_OM(current_OM->root, 0);
	printf("CountOM: %d\n", current_OM->countOM);
	return;
}

void recursive_print_OM(nodeOM* current_node, int label)
{
	int i;
	//Dont do anything if its null
	if(current_node == NULL)
	{
		printf("NULL SUBTREE");
		return;
	}
	
	//Move down the left side of the tree
	if(current_node->height != 0 && current_node->left != NULL)
		recursive_print_OM(current_node->left, label);
	
	//If its a leaf and it has an item, print the item
	if(current_node->item != NULL && current_node->height == 0)
	{
		printf("I l[%d] d[%d] \t\t", current_node->item->label, *((int*)current_node->item->data));
	}
	else if (current_node->height == 0) printf("Slot:  %d\t\t", label);
	else printf("\t\t\t");
	
	//printf("height: %d\n",current_node->height);	SOMETHING IS WRONG WITH THE HEIGHTS
	for(i=0; i<current_node->height; ++i)
	{
		printf("\t\t");
	}
	
	//Print current node
	printf("N h[%d] c[%d] d[%f]\n", current_node->height, current_node->count,density(current_node));
	
	//Move down the right side of the tree
	if(current_node->height != 0 && current_node->right != NULL)
		recursive_print_OM(current_node->right, label + pow(2,current_node->right->height));
	
	return;
}




















