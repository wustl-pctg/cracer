#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <cilk-lib.cilkh>

#define VOID_DATA (int)-INFINITY
#define M 32	//M = Tag Universe Size; Power of 2

//Tyler Romero
//Binary Tree OM Structure
//Has a leaf for every possible label
//Will eventually support multiple insertions in parallel

//----Structs-----------
enum bool{false,true};

struct nodeOM
{
	struct nodeOM *right, *left;
	int height;	//Height 0 = leaf
	int count; //Number of itemOMs below this node, max is 2^height
	struct nodeOM *parent;	//NULL if the node is the root
	struct itemOM* item;	//Only leafs will not be NULL
};
typedef struct nodeOM nodeOM;

struct itemOM
{
	struct itemOM *next, *prev;
	struct nodeOM *parent;
	int label;
	void* data;
};
typedef struct itemOM itemOM;

struct datastructOM
{
	struct nodeOM* root;
	int countOM;	//Number of leafs
	
};
typedef struct datastructOM OM;

//----Declarations------------
void individual_insert(OM* current_OM, itemOM* existing_item, itemOM* insert_item);
enum bool individual_order(itemOM* itemA, itemOM* itemB);

void recursive_relabel(nodeOM* current_node, itemOM** item_array, int size, int label);
nodeOM* recursive_find_low_density(nodeOM* current_node, double theshold, double T);
nodeOM* recursive_search_tree(nodeOM* current_node, int key, int height, int sum);
double density(nodeOM* current_node);

	//Initializations
OM* create_OM(itemOM* first_item);
nodeOM* recursive_create_tree(nodeOM* root, int height);
nodeOM* create_nodeOM();
itemOM* create_itemOM(void* data);

	//Print
void print_OM(OM* current_OM);
void recursive_print_OM(nodeOM* current_node);




//-------individual insert-----------------------
//NEED TO TEST AND DEBUG, should be fully implemented
void individual_insert(OM* current_OM, itemOM* existing_item, itemOM* insert_item)
{
	nodeOM* temp;
	itemOM* temp_item;
	itemOM** item_array;
	int i;
	
	//Insert into linked list
	insert_item->next = existing_item->next;
	existing_item->next = insert_item;
	insert_item->next->prev = insert_item;
	
	//Give it a label	//IF IM RIGHT, THERE WILL ALWAYS BE SPACE
	if(insert_item->next == existing_item)	//If there is only one existing item in the list
	{
		insert_item->label = floor((M+existing_item->label)/2);	//Should always be just M/2
	}
	else if(existing_item->label == M-1)	//If existing item is the last item in the label space
	{
		printf("Tyler's math is probably wrong");
	}
	else									//A normal insertion
	{
		insert_item->label = floor((insert_item->next->label+insert_item->prev->label)/2);
	}
	
	//Insert into tree (Is this efficient enough???)
	temp = recursive_search_tree(current_OM->root, insert_item->label, current_OM->root->height,0);	//O(log2(M))
	temp->item = insert_item;
	insert_item->parent = temp;
	while(temp->parent != NULL)	//Update count //O(log2(M))
	{
		temp->count++;
		temp = temp->parent;		
	}
	
	//Relabel the smallest enclosing range that is not overflowing
	temp = recursive_find_low_density(insert_item->parent, 1.0, 2.0);
	
	if(temp == NULL)	//Base case, root is overflowing
	{
		//Double size of tree by adding a node on top of root
		temp = create_nodeOM();
		temp->right = create_nodeOM();
		temp->left = current_OM->root;
		current_OM->root = temp;
		temp->right->height = temp->left->height;
		temp->height = temp->left->height + 1;
		temp->left->parent = temp;
		temp->right->parent = temp;
		temp->count = temp->left->count;
		//Build right side of tree
		recursive_create_tree(temp->right,temp->right->height);
		//Hypothetically, density should be low enough now
	}
	
	item_array = (itemOM**)malloc(temp->count*sizeof(itemOM*));
	temp_item = insert_item;
	for(i=0; i<temp->count; ++i)	//THIS COULD BE BAD!!!
	{
		item_array[i] = temp_item;
		temp_item->parent->item = NULL;	//Strip items from the tree
		temp_item->parent = NULL;
		temp_item = temp_item->next;
	}
	recursive_relabel(temp, item_array, temp->count, 0);	//Reinsert and relabel items
}

void recursive_relabel(nodeOM* current_node, itemOM** item_array, int size, int label)	//O(log(M))
{
	if(size>1 && current_node->height != 0)
	{
		recursive_relabel(current_node->left, item_array, floor(size/2), label);
		recursive_relabel(current_node->right, &item_array[(int)(size-floor(size/2))], size-floor(size/2), label+pow(2,current_node->height-1));
	}
	else if(current_node->height != 0 && size == 1)
	{
		recursive_relabel(current_node->left, item_array, size, label);
	}
	else if(size == 1)
	{
		printf("Something was wrong with Tyler's math");
		return;
	}
	else	//Height should = 0
	{
		current_node->item = item_array[0];
		current_node->item->label = label;
		current_node->item->parent = current_node;
	}
}

nodeOM* recursive_find_low_density(nodeOM* current_node, double threshold, double T) //O(log2(M)) worst case
{
	if(current_node->height == 0)
		threshold = 1.0;
	else
		threshold = threshold/T;
	
	if(current_node->parent == NULL)
		return NULL;
	else if(density(current_node) > threshold)	//If it is in overflow, move up the tree and try again
		return recursive_find_low_density(current_node->parent, threshold, T);
	else	//It is not in overflow, relabel below
		return current_node;
}

nodeOM* recursive_search_tree(nodeOM* current_node, int key, int height, int sum)	//O(log2(M))
{
	if(height==0)
		return current_node;
	
	height--;
	if(pow(2,height)-sum > key)	//Search left
		return recursive_search_tree(current_node->left,key,height,0);
	else						//Search right
		return recursive_search_tree(current_node->right,key,height,sum+pow(2,height));
}

//--------individual order----------------------
enum bool individual_order(itemOM* itemA, itemOM* itemB)	//True if itemA is earlier in the list than itemB
{
	if(itemA->label == itemB->label)
	{
		printf("Error: Input items must be distinct items from the same data structure\n");
		return false;
	}
	else if(itemA->label < itemB->label) return true;
	else return false;
}


//-----Other-----------
double density(nodeOM* current_node)
{
	return (double)((double)current_node->count)/((double)pow(2,current_node->height));	//Might have over-cast this
}

//----Initializations--------
OM* create_OM(itemOM* first_item)	//Data is for the first inserted item
{
	nodeOM* temp_node;
	OM* new_OM = (OM*)malloc(sizeof(OM));
	if(new_OM == NULL)
	{
		printf("Error Allocating Memory\n");
		return NULL;
	}
	//Initialize OM
	new_OM->root = create_nodeOM();
	new_OM->root->height = log2(M);
	new_OM->countOM = M;
	//Initialize first item
	temp_node = recursive_create_tree(new_OM->root,new_OM->root->height);
	temp_node->item = first_item;
	temp_node->item->parent = temp_node;
	temp_node->item->next = temp_node->item;	//Begin circularly linked list
	temp_node->item->prev = temp_node->item;
	temp_node->item->label = 0;
}

nodeOM* recursive_create_tree(nodeOM* root, int height)	//Height of the node being inputted	//PARALLELIZE
{
	if(height <= 0)
	{
		return root;
	}
	root->left = create_nodeOM();
	root->left->height = height - 1;
	root->left->parent = root;
	root->right = create_nodeOM();
	root->right->height = height - 1;
	root->right->parent = root;
	recursive_create_tree(root->right,root->right->height);
	return recursive_create_tree(root->left,root->left->height);
}

nodeOM* create_nodeOM()
{
	nodeOM* new_node = (nodeOM*)malloc(sizeof(nodeOM));
	if(new_node == NULL)
	{
		printf("Error Allocating Memory\n");
		return NULL;
	}
	new_node->right = NULL;
	new_node->left = NULL;
	new_node->parent = NULL;
	new_node->height = VOID_DATA;
	new_node->count = 0;
	new_node->item = NULL;
	return new_node;
}

itemOM* create_itemOM(void* data)
{
	itemOM* new_item = (itemOM*)malloc(sizeof(itemOM));
	if(new_item == NULL)
	{
		printf("Error Allocating Memory\n");
		return NULL;
	}
	new_item->next = NULL;
	new_item->prev = NULL;
	new_item->parent = NULL;
	new_item->label = VOID_DATA;
	new_item->data = data;
	return new_item;
}

//-------Print-----------------
void print_OM(OM* current_OM)
{
	recursive_print_OM(current_OM->root);
	printf("CountOM: %d\n", current_OM->countOM);
	return;
}

void recursive_print_OM(nodeOM* current_node)
{
	int i;
	
	if(current_node == NULL)
	{
		printf("NULL SUBTREE");
		return;
	}
		
	if(current_node->left != NULL)
		recursive_print(current_node->left);
	
	if(current_node->item != NULL)
	{
		printf("Item l[%d]\t\t", current_node->item->label);
	}
	else printf("\t\t");
	
	for(i=0; i<current_node->height; ++i)
	{
		printf("\t\t");
	}
	printf("Node h[%d] c[%d]\n", current_node->height, current_node->count);
	
	if(current_node->right != NULL)
		recursive_print(current_node->right);
	
	return;
}




















