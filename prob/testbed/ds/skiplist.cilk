/* skip list */

#include <stdio.h>
#include <stdlib.h>

#include <cilk-lib.cilkh>
#include <cilk.h>
//#include "../util/parfor.cilkh"

/* define data-type and compare operators here */
typedef int T;                  /* type of item to be stored */
#define compLT(a,b) (a < b)
#define compEQ(a,b) (a == b)

typedef struct {
	int add;
	T data;
} Operation;

/* levels range from (0 .. MAXLEVEL) */
#define MAXLEVEL 20
#define INSERT_CHUNK 512

typedef struct Node_ {
  T data;                     /* user's data */
  struct Node_ *forward[1];   /* skip list forward pointer */
} Node;

typedef struct {
  Node *hdr;                  /* list Header */
  int listLevel;              /* current level of list */
} SkipList;

SkipList list;                  /* skip list information */

#define NIL list.hdr

Node* insertNode(T data);
void deleteNode(T data);

void insertionSortSeq (void* data, size_t numElements) {
  //T* elements = (T*)data;
  Operation* elements = (Operation*)data;
  int c, i;
  T temp;
  for (c=1; c < numElements; ++c) {
    i=c;
    while (i > 0 && compLT(elements[i].data, elements[i-1].data)) {
      temp = elements[i].data;
      elements[i].data = elements[i-1].data;
      elements[i-1].data = temp;

      i--;
    }
  }
  return;
}

//NOTE: potentially unsafe if two closures try to modify adjacent edges at the
//      same time
/* cilk void recursiveInsertBatch(void* data, int iLeaf, */
/*                                size_t numElements, size_t numElementsTot) */
/* { */
/*   if (numElements > INSERT_CHUNK) { */
/*     spawn recursiveInsertBatch(data, 2*iLeaf, */
/*                                numElements - (numElements/2), numElementsTot); */
/*     spawn recursiveInsertBatch(data, 2*iLeaf+1, */
/*                                numElements/2, numElementsTot); */
/*   } else { */
/*     int istart = (numElementsTot/INSERT_CHUNK)*iLeaf; */
/*     int i; */
/*     for (i=istart; i < istart + INSERT_CHUNK; ++i) { */
/*       T d = ((Operation*)data)[i].data; */
/*       insertNode(d); */
/*     } */
/*   } */
/*   return; */
/* } */

cilk void recursiveInsertBatch(void* data, int start, int end)
{
  int i;
  if (end - start > INSERT_CHUNK) {
    i = start + (end - start) / 2;
    spawn recursiveInsertBatch(data, start, i);
    spawn recursiveInsertBatch(data, i, end);
  } else {
    for (i = start; i < end; i++) {
      T d = ((Operation*)data)[i].data;
      insertNode(d);
    }
  }
}

void mixed_batchify_seq(Batch* pending, void* ds, void* data,
                        size_t num_ops, void* results)
{
  int i;
  //  SkipList* list = ds;
  Operation* ops = (Operation*) data;

  for (i = 0; i < num_ops; i++) {
    if (ops[i].add)
      insertNode(ops[i].data);
    else
      deleteNode(ops[i].data);
  }
}

cilk void mixed_batchify(void *ds, void* data,
                         size_t num_ops, void* results)
{

}

cilk void batch_insert_par(void* dataStruct, void* data,
                           size_t numElements, void* results)
{
  insertionSortSeq(data, numElements);
  //spawn recursiveInsertBatch(data, 0, numElements, numElements);
  spawn recursiveInsertBatch(data, 0, numElements);
}

cilk void batch_createNodes(int index, void* info) {
  void** data  = info;
  //data is {&maxInsertLevel, level, data, new_nodes}
  // {int*,int*,int*,Node**}
  int i;
  Node* y;
  for (i=0; rand() < RAND_MAX/2 && i < MAXLEVEL; i++);
  ((int*)(data[1]))[index]=i; //Sets the level in the level array.
  if (*((int*)(data[0]))<i) {
    *((int*)(data[0]))=i;  //Changes max level currently.
  }
  if ((y=malloc(sizeof(Node) + i*sizeof(Node*)))==0){
    printf ("memory allocation error createNodes\n");
    exit(1);
  }
  ((Node**)(data[3]))[index]=y;
  y->data=((int*)(data[2]))[2*index];
}


cilk void batch_relateNodes(int index, void* infos){
  //Here info is {new_nodes,level,size,prev_nodes, maxInsertLevel
  void** info = infos;
  Node* y = ((Node**)(info[0]))[index];
  int check = index;
  int i,j,k;
  int maxlevel = *((int*)(info[4]));

  for (i = 0;i < ((int*)(info[1]))[index]; i++){
    y->forward[i]=NIL;
    for (j = check;j < *((int*)(info[2])); j++){
      if (((int*)(info[1]))[j] >= i){
        y->forward[i] = ((Node**)(info[0]))[j]; //sets the forward of the (index)th node at the ith level to node j.
        ((int*)(info[3]))[maxlevel*j+i] = index; //sets the previous pointer
        check = j;
        break;
      }
    }
  }
}

cilk void batch_insert_par2(void* dataStruct, void* data,
                            size_t numElements, void* results)
{
  int* level = calloc(numElements,sizeof(int));
  int i,j,k,check;
  int maxInsertLevel=0;
  int currMaxLevel;
  Node* x, *y;
  Node** new_nodes = calloc(numElements,sizeof(Node*));
  int* prev_nodes;
  //Par_for to create nodes
  void* createNodeArgs[5] = {&maxInsertLevel, level, data, new_nodes};
  void* relatedNodeArgs[5] = {new_nodes,level,&numElements,level,level};
  insertionSortSeq(data, numElements);
  currMaxLevel=((SkipList*)dataStruct)->listLevel;
  spawn parforpar(0,numElements,1,&batch_createNodes, createNodeArgs);
  sync;

  prev_nodes=calloc(maxInsertLevel*numElements,sizeof(int)); //Makes a prev array.
  //Fill in rest of info.
  relatedNodeArgs[3]=prev_nodes;
  relatedNodeArgs[4]=&maxInsertLevel;

  //Switch max level!
  if (maxInsertLevel>currMaxLevel) {
    ((SkipList*)dataStruct)->listLevel=maxInsertLevel;
  }

  //Par_for to relations
  spawn parforpar(0,numElements,1,&batch_relateNodes, relatedNodeArgs);
  sync;

  //Par_for to merge list
  for (i=0;i<numElements;i++){
    for (j=level[i]-1;j>=0;j--){
      x = list.hdr;
      while (x->forward[j] != NIL && compLT(x->forward[j]->data, ((int*)data)[2*i])) {
        x = x->forward[j];
      }

      //Do a quick loop forward to check for the last element in this level.
      if (new_nodes[i]->forward[j]!=NIL && compLT(x->forward[j]->data,new_nodes[i]->forward[j]->data)) {
        new_nodes[i]->forward[j]=x->forward[j];
      }

      for (k=i;k>=-1;k--){
        if (k==-1){
          x->forward[j]=new_nodes[i];
		      break;
        }
        if (level[k]>=level[i] && compLT(x->data,new_nodes[k]->data)){
          x->forward[j]=new_nodes[i];
          break;
        }
      }
    }
  }
  free(new_nodes);
  free(level);
  free(prev_nodes);
}

void batch_insert_seq(Batch* pending, void* ds, void* data,
                      size_t num_ops, void* results)
{
  int i;
  Operation* ops = (Operation*) data;
  for (i = 0; i < num_ops; i++) {
    // Assume ops are add operations.
    insertNode(ops[i].data);
  }
}

void popBatch(Batch* pending, void* dataStruct, void* data,
              size_t numElements, void* results)
{
  int i;
  for (i=0; i < numElements; ++i) {
    if (list.hdr->forward[0] != NIL)
      deleteNode(list.hdr->forward[0]->data);
  }
}

void insert_seq(CilkWorkerState *const ws, Operation* add_op)
{
  Cilk_batchify_sequential(ws, &batch_insert_seq, (void*)&list,
                           (void*)add_op, sizeof(int), NULL);
}

void insert_par(CilkWorkerState *const ws, Operation* add_op)
{
  Cilk_batchify(ws, &batch_insert_par, (void*)&list,
                (void*)add_op, sizeof(int), NULL);
}


void batchPopNode (CilkWorkerState *const ws, int inValue)
{
  Cilk_batchify_sequential(ws, &popBatch, (void*)&list,
                           (void*)&inValue, sizeof(int), NULL);
}

Node *insertNode(T data) {
  int i, newLevel;
  Node *update[MAXLEVEL+1];
  Node *x;

  /***********************************************
   *  allocate node for data and insert in list  *
   ***********************************************/

  /* find where data belongs */
  x = list.hdr;
  for (i = list.listLevel; i >= 0; i--) {
    while (x->forward[i] != NIL
           && compLT(x->forward[i]->data, data))
      x = x->forward[i];
    update[i] = x;
  }
  x = x->forward[0];
  if (x != NIL && compEQ(x->data, data)) {
    //    printf("%d already in skiplist\n", x->data);
    return(x);
  }

  /* determine level */
  for (newLevel = 0; rand() < RAND_MAX/2 && newLevel < MAXLEVEL; newLevel++);

  if (newLevel > list.listLevel) {
    for (i = list.listLevel + 1; i <= newLevel; i++)
      update[i] = NIL;
    list.listLevel = newLevel;
  }

  /* make new node */
  if ((x = malloc(sizeof(Node) +
                  newLevel*sizeof(Node *))) == 0) {
    printf ("insufficient memory (insertNode)\n");
    exit(1);
  }
  x->data = data;

  /* update forward links */
  for (i = 0; i <= newLevel; i++) {
    x->forward[i] = update[i]->forward[i];
    update[i]->forward[i] = x;
  }
  return(x);
}

void deleteNode(T data) {
  int i;
  Node *update[MAXLEVEL+1], *x;

  /*******************************************
   *  delete node containing data from list  *
   *******************************************/

  /* find where data belongs */
  x = list.hdr;
  for (i = list.listLevel; i >= 0; i--) {
    while (x->forward[i] != NIL
           && compLT(x->forward[i]->data, data))
      x = x->forward[i];
    update[i] = x;
  }
  x = x->forward[0];
  if (x == NIL || !compEQ(x->data, data)) return;

  /* adjust forward pointers */
  for (i = 0; i <= list.listLevel; i++) {
    if (update[i]->forward[i] != x) break;
    update[i]->forward[i] = x->forward[i];
  }

  free (x);

  /* adjust header level */
  while ((list.listLevel > 0)
         && (list.hdr->forward[list.listLevel] == NIL))
    list.listLevel--;
}

Node *findNode(T data) {
  int i;
  Node *x = list.hdr;

  /*******************************
   *  find node containing data  *
   *******************************/

  for (i = list.listLevel; i >= 0; i--) {
    while (x->forward[i] != NIL
           && compLT(x->forward[i]->data, data))
      x = x->forward[i];
  }
  x = x->forward[0];
  if (x != NIL && compEQ(x->data, data)) return (x);
  return(0);
}

void initList() {
  int i;

  /**************************
   *  initialize skip list  *
   **************************/

  if ((list.hdr = malloc(sizeof(Node) + MAXLEVEL*sizeof(Node *))) == 0) {
    printf ("insufficient memory (initList)\n");
    exit(1);
  }
  for (i = 0; i <= MAXLEVEL; i++)
    list.hdr->forward[i] = NIL;
  list.listLevel = 0;
}

int get_size() {
  int size = 0;
  Node* pCur = list.hdr;

  while (pCur->forward[0] != NIL) {
    ++size;
    pCur = pCur->forward[0];
  }

  return size;
}

/*int main(int argc, char **argv) {
  int i, *a, maxnum, random;

  //command-line:
  //
  //  skl maxnum [random]
  //
  //  skl 2000
  //      process 2000 sequential records
  //  skl 4000 r
  //      process 4000 random records



  maxnum = atoi(argv[1]);
  random = argc > 2;

  initList();

  if ((a = malloc(maxnum * sizeof(*a))) == 0) {
  fprintf (stderr, "insufficient memory (a)\n");
  exit(1);
  }

  if (random) {
  // fill "a" with unique random numbers
  for (i = 0; i < maxnum; i++) a[i] = rand();
  printf ("ran, %d items\n", maxnum);
  } else {
  for (i = 0; i < maxnum; i++) a[i] = i;
  printf ("seq, %d items\n", maxnum);
  }

  for (i = 0; i < maxnum; i++) {
  insertNode(a[i]);
  }

  for (i = maxnum-1; i >= 0; i--) {
  findNode(a[i]);
  }

  for (i = maxnum-1; i >= 0; i--) {
  deleteNode(a[i]);
  }
  return 0;
  }*/
