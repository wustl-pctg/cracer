#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>

#include "../util/parfor.cilkh"
#include "stack.cilkh"

#define MAX_SIZE 100000000

Stack* create_stack(){
       Stack* result = malloc(sizeof(Stack));
       Cilk_lock_init(result->lock);
       result->size=0;
       result->start=NULL;
       result->end=NULL;
       result->nodes=calloc(MAX_SIZE,sizeof(node));
       return result;
}

/* Sequential push method */
void push(Stack* ds, int data){
  //Get lock on stack
  node* ins = malloc(sizeof(node));
  ins->data=data;
  ins->next=NULL;
  Cilk_lock(ds->lock);
  if (ds->size==0){
    ds->start=ins;
    ds->end=ins;
    ins->prev=NULL;
  } else {
    ins->prev=ds->end;
    ds->end->next=ins;
    ds->end=ins;
  }
  ds->size++;
  //Releases the lock
  Cilk_unlock(ds->lock);
}

/* Sequential push method with no lock */
void pushInternal(Stack* ds, int data){
 node* ins;
 if (ds->size>=MAX_SIZE){
    ins = malloc(sizeof(node));
 }
 else {
     ins = &(ds->nodes[ds->size]);
  }
  ins->data=data;
  ins->next=NULL;
  if (ds->size==0){
    ds->start=ins;
    ds->end=ins;
    ins->prev=NULL;
  } else {
    ins->prev=ds->end;
    ds->end->next=ins;
    ds->end=ins;
  }
  ds->size++;
}


/* Batchify-caller method*/
cilk void pushBatchify(Stack* ds, int data){
  Cilk_batchify(_cilk_ws,&push_batch,ds,&data,sizeof(int),NULL);
}

/* Batchify for mixed*/
cilk void mixedBatchify(Stack* ds, Operation op){
  //return;
    Cilk_batchify(_cilk_ws,&doMixedOps,ds,&op,sizeof(Operation),NULL);
}

cilk void mixedBatchify_raw(Stack* ds, Operation op){
  Cilk_batchify_raw(_cilk_ws,&doRawMixedOps,ds,&op,sizeof(Operation),NULL);
}

/* Batch mixed function*/
cilk void doMixedOps(void* ds, void* oprec, size_t size, void*result){
//  return;
   Stack* stack = ds;
  BatchRecord** ops = oprec;
  BatchRecord* op;
  int i;
  for (i=0;i<size;i++){
    if (ops[i]!=NULL){
      pushInternal(stack,ops[i].data);
      popInternal(stack);
    }
}

/* Uses the raw oprec array*/
cilk void doRawMixedOps(void* ds, void* oprec, size_t size, void* result){
  Stack* stack = ds;
  Operation* ops = oprec;
  int i;
  for (i=0;i<size;i++){
    if (ops[i].add){
      pushInternal(stack,ops[i].data);
    } else {
      popInternal(stack);
    }
    }
}

/* Batch "clever" mixed function*/
cilk void doCleverMixedOps(void* ds, void* oprec, size_t size, void*result){
  Stack* stack = ds;
  Operation* ops = oprec;
  int i;
  int num_ops=0;
  for (i=0;i<size;i++){
    if (ops[i].add){
      num_ops++;
    } else {
      num_ops--;
    }
  }
  while (num_ops>0){
    i=0;
    if (ops[i].add){
       pushInternal(stack,ops[i].data);
       num_ops--;
    }
    i++;
  }
  while (num_ops<0){
    i=0;
    if (!(ops[i].add)){
       popInternal(stack);
       num_ops++;
    }
    i++;
  }
}

/* Batch push method.*/
cilk void push_batch(void* ds, void* oprec, size_t size, void* result){
  Stack* stack = ds;
  int* data=oprec;
  //^ all the needed variables cast as proper types.
  
  //Temporary varibles.
  node* new_nodes;
  /*  for (i=0;i<size;i++){
    push(ds,data[i]);
    }*/
  void* pair[2];
  new_nodes = calloc(size,sizeof(node));
  pair[0]=new_nodes;
  pair[1]=data;
  //Parallel_for
  /*for (i=0;i<size;i++){
    new_nodes[i].data=data[i];
    new_nodes[i].next=&new_nodes[i+1];
    new_nodes[i].prev=&new_nodes[i-1];
    }*/
  spawn parforpar(0,size-1,1,parallel_set,pair);
  sync;
  new_nodes[0].prev=stack->end;
  new_nodes[size-1].next=NULL;
  //Special case for initial creation.
  if (stack->size==0){
    stack->start=new_nodes;
  }
  //Normal case, which requires setting the end of the stack to point to the new item.
  else {
    stack->end->next=&new_nodes[0];
  }
  stack->end=&new_nodes[size-1];
  stack->size+=size;
}

/*Pop using a lock*/
node* pop(Stack* ds){
  node* result;
  Cilk_lock(ds->lock);
  result=popInternal(ds);
  Cilk_unlock(ds->lock);
  return result;
}

/*Batchify-caller for pop */
cilk void popBatchify(Stack* ds){
  Cilk_batchify(_cilk_ws,&pop_batch,ds,NULL,0,NULL);
}

/*Batch method to pop items*/
cilk void pop_batch(void* ds, void* oprec, size_t size, void* result){
  Stack* stack = ds;
  int i;
  node* res;
  for (i=0;i<size;i++){
    res=popInternal(stack);
  } 
}

/* Pop method without locks*/
node* popInternal(Stack* ds){
  node* result = ds->end;
  if (ds->size>0){
     if (result==NULL){
     	return NULL;
     }
    ds->end = result->prev;
    ds->size--;
    if (ds->end!=NULL){
       ds->end->next=NULL;
    }
    if (ds->size==0){
       ds->start=NULL;
    }
    return result;
  } else {
    return NULL;
  }
}

/* For use by parforpar*/
cilk void parallel_set(int i, void* in){
  //The second argument is actually a void** that has two elements.
    void** data=in;
    node* new_nodes=data[0];
    int* inputs=data[1];
    new_nodes[i].data=inputs[i];
    new_nodes[i].next=&new_nodes[i+1];
    new_nodes[i].prev=&new_nodes[i-1];
}

/* Prints out the stack sequentially*/
void printStack(Stack* ds) {
  node* it = ds->start;
  int i=0;
  while (it!=NULL) {
    //printf("(%p %d,%p)\n",it,it->data,it->next);
    it=it->next;
    i++;
  }
  printf("size: %d/%d\n",i,ds->size);
  return;
}
