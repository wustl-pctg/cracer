#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#include "../util/parfor.cilkh"
#include "stack_fc.cilkh"

//#define MAX_SIZE 1000000000
#define MAX_SIZE 10000000
#define PROCS 16

Stack* create_stack(){
	int i;
	Stack* result = malloc(sizeof(Stack));
	Cilk_lock_init(result->lock);
	result->size=0;
	result->start=NULL;
	result->end=NULL;
	result->nodes=calloc(MAX_SIZE,sizeof(node));
	assert(result->nodes != NULL);
	result->fc_locked=0;
	for (i=0; i <PROCS; i++){
		result->fc_arry[i]=-1;
	}
	return result;
}

/*Helper methods!*/

/* Sequential push method with no lock */
void pushInternal(Stack* ds, int data){
	node* ins;
	if (ds->size>=MAX_SIZE){
    ins = malloc(sizeof(node));
	}
	else {
		ins = &(ds->nodes[ds->size]);
  }
  ins->data=data;
  ins->next=NULL;
  /*
		if (ds->size==0){
    ds->start=ins;
    ds->end=ins;
    ins->prev=NULL;
		} else {
    ins->prev=ds->end;
    ds->end->next=ins;
    ds->end=ins;
		}
  */
  ds->size++;
}

/*do the flat combining*/
void do_FC(Stack* ds){
  int i,j;
  for (j=0;j<1;++j){
    //Repeat 3 times for some reason.
    for (i=0; i<PROCS;i++){
      if (ds->fc_arry[i]!=0 && ds->fc_arry[i]!=-1){
				ds->end=&(ds->nodes[ds->size]);
				ds->end->data=ds->fc_arry[i];
				(ds->size)++;
      }
      else if (ds->fc_arry[i]==0){
        if (ds->size>0){
					(ds->size)--;
					ds->end=&(ds->nodes[ds->size]);
				}
      }
      else {

      }
      ds->fc_arry[i]=-1;
    }
  }
}

/*copies flat combining*/
void mixedFC(Stack* ds, Operation op, CilkWorkerState* const ws){
  int* my_val = &(ds->fc_arry[ws->self]);
  if (op.add){
    *my_val=op.data;
  }
  else {
    *my_val=0;
  } //Sets the status to either 0 for remove, or an int for add.
  while (1) {
    if(!(ds->fc_locked) && !(ds->fc_locked) && !(ds->fc_locked) && __sync_bool_compare_and_swap(&(ds->fc_locked),0,1)){
      do_FC(ds);
      ds->fc_locked=0;
      return;
    }
    else {
      while(-1 != *my_val){
      }
      return;
    }
  }

}

/*Pop using a lock*/
node* pop(Stack* ds){
  node* result;
  Cilk_lock(ds->lock);
  result=popInternal(ds);
  Cilk_unlock(ds->lock);
  return result;
}

/* Pop method without locks*/
node* popInternal(Stack* ds){
  node* result = ds->end;
  if (ds->size>0){
		if (result==NULL){
     	return NULL;
		}
		//ds->end = result->prev;
    ds->size--;
    ds->end=&(ds->nodes[ds->size]);
  }
  return result;
	/*
    if (ds->end!=NULL){
		ds->end->next=NULL;
    }
    if (ds->size==0){
		ds->start=NULL;
    }
    return result;
		} else {
    return NULL;
		}
	*/
}


/* Prints out the stack sequentially*/
void printStack(Stack* ds) {
  node* it = ds->start;
  int i=0;
  while (it!=NULL) {
    //printf("(%p %d,%p)\n",it,it->data,it->next);
    it=it->next;
    i++;
  }
  printf("size: %d/%d\n",i,ds->size);
  return;
}
