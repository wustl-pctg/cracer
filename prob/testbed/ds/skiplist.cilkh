/* skip list */

#include <stdio.h>
#include <stdlib.h>

#include <cilk-lib.cilkh>
#include <cilk.h>

typedef struct {
	int add;
	int data;
} Operation;

/* define data-type and compare operators here */
typedef int T;                  /* type of item to be stored */
#define compLT(a,b) (a < b)
#define compEQ(a,b) (a == b)

/* levels range from (0 .. MAXLEVEL) */
#define MAXLEVEL 20
#define INSERT_CHUNK 16

typedef struct Node_ {
    T data;                     /* user's data */
    struct Node_ *forward[1];   /* skip list forward pointer */
} Node;

typedef struct {
    Node *hdr;                  /* list Header */
    int listLevel;              /* current level of list */
} SkipList;

SkipList list;                  /* skip list information */

#define NIL list.hdr

Node* insertNode(T data);
void deleteNode(T data);

void insertionSortSeq (void* data, size_t numElements) {
  //T* elements = (T*)data;
  Operation* elements = (Operation*)data;
  int c, i;
  T temp;
  for (c=1; c < numElements; ++c) {
    i=c;
    while (i > 0 && compLT(elements[i].data, elements[i-1].data)) {
      temp = elements[i].data;
      elements[i].data = elements[i-1].data;
      elements[i-1].data = temp;

      i--;
    }
  }
  return;
}

//NOTE: potentially unsafe if two closures try to modify adjacent edges at the
//      same time
cilk void recursiveInsertBatch(void* data, int iLeaf,
                          size_t numElements, size_t numElementsTot)
{
  if (numElements > INSERT_CHUNK) {
    spawn recursiveInsertBatch(data, 2*iLeaf, numElements/2, numElementsTot);
    spawn recursiveInsertBatch(data, 2*iLeaf+1, numElements/2, numElementsTot);
  } else {
    int istart = (numElementsTot/INSERT_CHUNK)*iLeaf;
    int i;
    for (i=istart; i < istart + INSERT_CHUNK; ++i) {
      T d = ((Operation*)data)[i].data;
      insertNode(d);
    }
  }
  return;
}

void mixed_batchify_seq(Batch* pending, void* ds, void* data,
                        size_t num_ops, void* results)
{
  int i;
  //  SkipList* list = ds;
  Operation* ops = (Operation*) data;

  for (i = 0; i < num_ops; i++) {
    if (ops[i].add)
      insertNode(ops[i].data);
    else
      deleteNode(ops[i].data);
  }
}

cilk void mixed_batchify(void *ds, void* data,
                    size_t num_ops, void* results)
{

}

cilk void batch_insert_par(void* dataStruct, void* data,
                           size_t numElements, void* results)
{
  insertionSortSeq(data, numElements);
  spawn recursiveInsertBatch(data, 0, numElements, numElements);
}

void batch_insert_seq(Batch* pending, void* ds, void* data,
                      size_t num_ops, void* results)
{
  int i;
  Operation* ops = (Operation*) data;
  for (i = 0; i < num_ops; i++) {
    // Assume ops are add operations.
    insertNode(ops[i].data);
  }
}

void popBatch(Batch* pending, void* dataStruct, void* data,
              size_t numElements, void* results)
{
  int i;
  for (i=0; i < numElements; ++i) {
    if (list.hdr->forward[0] != NIL)
      deleteNode(list.hdr->forward[0]->data);
  }
}

void insert_seq(CilkWorkerState *const ws, Operation add_op)
{
  Cilk_batchify_sequential(ws, &batch_insert_seq, (void*)&list,
                           (void*)&add_op, sizeof(int), NULL);
}

void insert_par(CilkWorkerState *const ws, Operation add_op)
{
  Cilk_batchify(ws, &batch_insert_par, (void*)&list,
                (void*)&add_op, sizeof(int), NULL);
}


void batchPopNode (CilkWorkerState *const ws, int inValue)
{
  Cilk_batchify_sequential(ws, &popBatch, (void*)&list,
                           (void*)&inValue, sizeof(int), NULL);
}

Node *insertNode(T data) {
    int i, newLevel;
    Node *update[MAXLEVEL+1];
    Node *x;

   /***********************************************
    *  allocate node for data and insert in list  *
    ***********************************************/

    /* find where data belongs */
    x = list.hdr;
    for (i = list.listLevel; i >= 0; i--) {
        while (x->forward[i] != NIL 
          && compLT(x->forward[i]->data, data))
            x = x->forward[i];
        update[i] = x;
    }
    x = x->forward[0];
    if (x != NIL && compEQ(x->data, data)) return(x);

    /* determine level */
    for (newLevel = 0; rand() < RAND_MAX/2 && newLevel < MAXLEVEL; newLevel++);

    if (newLevel > list.listLevel) {
        for (i = list.listLevel + 1; i <= newLevel; i++)
            update[i] = NIL;
        list.listLevel = newLevel;
    }

    /* make new node */
    if ((x = malloc(sizeof(Node) + 
      newLevel*sizeof(Node *))) == 0) {
        printf ("insufficient memory (insertNode)\n");
        exit(1);
    }
    x->data = data;

    /* update forward links */
    for (i = 0; i <= newLevel; i++) {
        x->forward[i] = update[i]->forward[i];
        update[i]->forward[i] = x;
    }
    return(x);
}

void deleteNode(T data) {
    int i;
    Node *update[MAXLEVEL+1], *x;

   /*******************************************
    *  delete node containing data from list  *
    *******************************************/

    /* find where data belongs */
    x = list.hdr;
    for (i = list.listLevel; i >= 0; i--) {
        while (x->forward[i] != NIL 
          && compLT(x->forward[i]->data, data))
            x = x->forward[i];
        update[i] = x;
    }
    x = x->forward[0];
    if (x == NIL || !compEQ(x->data, data)) return;

    /* adjust forward pointers */
    for (i = 0; i <= list.listLevel; i++) {
        if (update[i]->forward[i] != x) break;
        update[i]->forward[i] = x->forward[i];
    }

    free (x);

    /* adjust header level */
    while ((list.listLevel > 0)
    && (list.hdr->forward[list.listLevel] == NIL))
        list.listLevel--;
}

Node *findNode(T data) {
    int i;
    Node *x = list.hdr;

   /*******************************
    *  find node containing data  *
    *******************************/

    for (i = list.listLevel; i >= 0; i--) {
        while (x->forward[i] != NIL 
          && compLT(x->forward[i]->data, data))
            x = x->forward[i];
    }
    x = x->forward[0];
    if (x != NIL && compEQ(x->data, data)) return (x);
    return(0);
}

void initList() {
    int i;

   /**************************
    *  initialize skip list  *
    **************************/

    if ((list.hdr = malloc(sizeof(Node) + MAXLEVEL*sizeof(Node *))) == 0) {
        printf ("insufficient memory (initList)\n");
        exit(1);
    }
    for (i = 0; i <= MAXLEVEL; i++)
        list.hdr->forward[i] = NIL;
    list.listLevel = 0;
}

int get_size() {
  int size = 0;
  Node* pCur = list.hdr;

  while (pCur->forward[0] != NIL) {
    ++size;
    pCur = pCur->forward[0];
  }

  return size;
}

/*int main(int argc, char **argv) {
    int i, *a, maxnum, random;

    //command-line:
    //
    //  skl maxnum [random]
    //
    //  skl 2000
    //      process 2000 sequential records
    //  skl 4000 r
    //      process 4000 random records
    
    

    maxnum = atoi(argv[1]);
    random = argc > 2;

    initList();

    if ((a = malloc(maxnum * sizeof(*a))) == 0) {
        fprintf (stderr, "insufficient memory (a)\n");
        exit(1);
    }

    if (random) {
        // fill "a" with unique random numbers 
        for (i = 0; i < maxnum; i++) a[i] = rand();
        printf ("ran, %d items\n", maxnum);
    } else {
        for (i = 0; i < maxnum; i++) a[i] = i;
        printf ("seq, %d items\n", maxnum);
    }

    for (i = 0; i < maxnum; i++) {
        insertNode(a[i]);
    }

    for (i = maxnum-1; i >= 0; i--) {
        findNode(a[i]);
    }

    for (i = maxnum-1; i >= 0; i--) {
        deleteNode(a[i]);
    }
    return 0;
}*/
