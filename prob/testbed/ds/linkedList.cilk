#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>

#include <linkedList.cilkh>
#include <../util/defaults.h>

/* We need to talk about a few things:
- Do we need data in a node? How does the node's name clarify
   a p or an s in a significant way?
- Do we need to define a _cilk_ws for linkedListBatchInsert?
*/
InsertRecord global_ir;

//initialize linked list
LinkedList * createLinkedList(){

	LinkedList * tmp;
	 
	tmp = (LinkedList*) malloc(sizeof(LinkedList));	

	tmp->head = NULL;
	tmp->tail = NULL;
	tmp->size = 0;
	
	return tmp;
}


// free all Linked List nodes'and Linked List  memory
void cleanUp(LinkedList * ll){
	Node * tmp = ll->head;
	Node * next;

	while (tmp != ll->tail)
	{
		next = tmp->next;	
		//free(tmp->name);
		free(tmp);
		
		tmp = next;	
		
	}
	
	free(tmp);
	free(ll);
}

//private function to be called to append node to end
cilk void appendNode(LinkedList * list, Node * newNode){

	//TODO: size checks? 
	if (newNode != NULL)
	{
		
		//if this is an empty list, assign head and tail
		if (list->size == 0)
		{
			list->head = list->tail = newNode;
			newNode->next = NULL;
			newNode->prev = NULL;
			list->size++;
		} else {
			//update last two node's references to each other
			list->tail->next = newNode;
			newNode->prev = list->tail;

			newNode->next = NULL;
		
			//update tail of the list
			list->tail = newNode;	
			list->size++;
		}
	} else {
	       printf("%s\n","Error: trying to append a NULL node");
	}
	
}


cilk void batchInsertSeq(LinkedList * list, Node *x, Node *y){
	
	InsertRecord * ir = (InsertRecord * ) malloc(sizeof(InsertRecord));
	ir->x = x;
	ir->y = y;	

	Cilk_batchify(_cilk_ws, &insertSeq, list, ir, sizeof(Node), NULL);
}


cilk void non_batchInsertSeq(LinkedList * list, Node *x, Node *y){
	
	InsertRecord * ir = (InsertRecord * ) malloc(sizeof(InsertRecord));
	InsertRecord ** irArray = (InsertRecord **) malloc(1 * sizeof(InsertRecord *));
	ir->x = x;
	ir->y = y;	

	irArray[0] = ir;

	spawn insertSeq((void*)list, (void *)irArray, 1, NULL); 

}

cilk void non_batchInsertPar(LinkedList * list, InsertRecord ** irArray, int size){
	
	spawn insertPar((void*)list, (void *)irArray, (size_t)size, NULL); 

}

cilk void insertSeq(void *dataStruct, void *data, size_t size, void *result){

	//array of inserts to complete
	InsertRecord ** records =(InsertRecord **) data;
	LinkedList * list = (LinkedList *)dataStruct;
	Node  *x, *y, *z;

	int i = 0;
	for (; i < size; i++){
		InsertRecord *ir = records[i];

		// get x and y from record
		x = ir->x;
		y = ir->y;

		//if x is null
		if (!x)
		{
			printf("First node is null, skipping batch entry.");
			free(ir);
			continue;
		}
	
		//if x isnt tail
		if (x->next)	
			z = x->next;
		 //make z null and change y to tail
		else
		{
			z = NULL;
			list->tail = y;
		}
		//change prev pointers
		if (z)
			z->prev = y;
		y->prev = x;
	
		//change next pointers
		y->next = x->next;
		//do atomic change of x pointer
		if(__sync_bool_compare_and_swap(&(x->next), (x->next), y))
		{
			printf("Successful swap\n");
		}
		
		

		list->size++;
		
		free(ir);	
	}
}

//parallel version of insert
cilk void insertPar(void *dataStruct, void *data, size_t size, void *result)
{
	InsertRecord ** irArray = (InsertRecord **)data;
	LinkedList * list = (LinkedList *) dataStruct;
	int i = 0;
	for (; i<size;i++)
	{
		spawn atomicInsert(list, irArray[i]);
	}
}

//do single insert, called by insertPar
cilk void atomicInsert(LinkedList * list, InsertRecord *ir){
	Node * x, *y, *z;
	x = ir->x;
	y = ir->y;

	//if x is null
	if (!ir->x){
		printf("Node is null, skipping entry");
		free(ir);
		return;
	}	

	//if x isnt tail
	if (x->next)	
		z = x->next;
	 //make z null and change y to tail
	else
	{
		z = NULL;
		list->tail = y;
	}
	//change prev pointers
	if (z)
		z->prev = y;
	y->prev = x;

	//change next pointers
	y->next = x->next;

	if (__sync_bool_compare_and_swap(&(x->next), x->next, y)){
		printf("Successful swap\n");
	}	
	list->size++;
	free(ir);	
}

//we are going to assume that the data in x and y is unique to the list
//otherwise all bets are off
// 
// will return false if x and y are the same
// if x comes before y: return true
// else returns false

cilk int order(LinkedList * list, Node * x, Node *y ){

	//make sure list is valid
	
	/* ========= Why are these commented out? ======= */
	//assert(list != NULL);
	//assert((list->size) > 2);

	Node * current;
	current = list->head;


	do {
	   if (current == y)
	      return 0;
	   if (current == x)
	      return 1;

	   current = current->next;

	} while( current != list->tail);

	printf("%s\n", "Neither node found in linked list. Returning false");

	return 0;
}
