#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <string>


#include <linkedList.cilkh>
#include <../util/defaults.h>

/* We need to talk about a few things:
- Do we need data in a node? How does the node's name clarify
   a p or an s in a significant way?
- Do we need to define a _cilk_ws for linkedListBatchInsert?
*/

//initialize linked list
LinkedList * createLinkedList(){

	LinkedList * tmp;
	 
	tmp = (LinkedList*) malloc(sizeof(LinkedList));	

	tmp->head = NULL;
	tmp->tail = NULL;
	tmp->size = 0;
	
	return tmp;
}

// free all Linked List nodes'and Linked List  memory
void cleanUp(LinkedList * ll){
	Node * tmp = ll->head;
	Node * next;

	while (tmp != ll->tail)
	{
		next = tmp->next;	
		free(tmp);
		tmp = next;	
	}

	free(tmp);
	free(ll);
}

//private function to be called to append node to end
cilk void appendNode(LinkedList * list, Node * newNode){

	//TODO: size checks? 
	if (newNode != NULL)
	{
		
		//if this is an empty list, assign head and tail
		if (list->size == 0)
		{
			list->head = list->tail = newNode;
			list->size++;
		} else {
			//update last two node's references to each other
			list->tail->next = newNode;
			newNode->prev = list->tail;

			newNode->next = NULL;
		
			//update tail of the list
			list->tail = newNode;	
			list->size++;
		}
	} else {
	       printf("%s\n","Error: trying to append a NULL node");
	}
	
}


cilk void linkedListBatchInsert(LinkedList * list, Node *x, Node *y){
	InsertRecord ir;
	ir.x = x;
	ir.y = y;
	Cilk_batchify(_cilk_ws, &batchInsert, list, &ir, sizeof(InsertRecord), NULL);
}


cilk void batchInsert(void *dataStruct, void *data, size_t size, void *result){

	//array of inserts to complete
	InsertRecord *insertRecordArray = (InsertRecord *)data;

	LinkedList * list = (LinkedList *)dataStruct;

	int i = 0;
	for (; i < size; i++){
		InsertRecord ir = insertRecordArray[i];
		
		Node * x = ir.x;
		Node * z = x->next;
		Node * y = ir.y;
		
		//update next ptrs
		x->next = y;
		y->next = z;

		//update previous pointer for y	
		y->prev = x;

	
		//update previ pointer for y->next
		if (z != NULL) //if y isnt the tail		
		{
			z->prev = y;
		} else //if y is the tail 
			list->tail = y;
		
		list->size++;	
	}
}


/*
// if x or y is left as NULL, the other value will be appended to the 
// list
void insert(LinkedList * list, void * x, void * y){

	if (( x == NULL && y != NULL ) || (x != NULL && y == NULL)){
		void * d;
		//assign d to value x or y that is not NULL		
		(x == NULL)?d = y:d = x;

		//create new node
		Node * tmp = (Node*)malloc(sizeof(Node));

		//make sure space was allocated
		assert(tmp == NULL);
	
		//add data value to new node	
		tmp->data = d;
		
		//append node to end of list
		appendNode(list, tmp);

		
	}
	if ( x != NULL && y != NULL){
		Node * newNode = (Node*)malloc(sizeof(Node));

		//update node value
		newNode->data = y;

		
		
		//TODO: make thread safe	
		
		(list->size)++;
	}
		
	
}
*/

//we are going to assume that the data in x and y is unique to the list
//otherwise all bets are off
// 
// will return false if x and y are the same
// if x comes before y: return true
// else returns false

cilk int order(LinkedList * list, Node * x, Node *y ){

	//make sure list is valid
	
	/* ========= Why are these commented out? ======= */
	//assert(list != NULL);
	//assert((list->size) > 2);

	Node * current;
	current = list->head;


	do {
	   if (current == y)
	      return 0;
	   if (current == x)
	      return 1;

	   current = current->next;

	} while( current != list->tail);

	printf("%s\n", "Neither node found in linked list. Returning false");

	return 0;
}