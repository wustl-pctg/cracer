#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#define VOID_DATA (int)-INFINITY
#define PARALLEL_CUTOFF 2


/* 2-3 Tree that supports parallel operations */
/* The insertion function will allow any amount of data to be inserted */
/* Tyler Romero and Kefu Lu */

//To do: add the batchify function
//To do: the 'remove' function



/*-----------------------------Structs-----------------------------------------------------------------------------------------*/
struct node23
{
	struct node23 *left, *middle, *right;
	int left_data, right_data;
	int max;
    int height;
	enum mark_status{unmarked, marked} is_marked;
};

struct tree23
{
	struct node23 *root;
};



/*-----------------------------Function Declarations----------------------------------------------------------------------------*/
	//Initialization Functions
struct node23* create_node(int node_data);	/*COMPLETE*/
struct tree23* create_tree(int node_data);	/*COMPLETE*/

	//Delete Tree
void delete_tree_helper(struct node23 *dead_node);	/*COMPLETE*/
void delete_tree(struct tree23 *dead_tree);			/*COMPLETE*/

	//Special Search Functions
int binary_search_function(int (*function_ptr)(int, int, struct node23**, struct node23*), struct node23** node_array, int size, struct node23* target);	/*COMPLETE*/			/*Returns the array index of the thing that is searched for*/
int find_first(int index, int bound, struct node23** node_array, struct node23* target); 		/*COMPLETE*/
int find_last(int index, int bound, struct node23** node_array, struct node23* target); 		/*COMPLETE*/
int find_insert_index(int *input_array, int size, struct node23* target);						/*COMPLETE*/

	//Search and Mark
struct node23* searchAndMark(struct node23* current_node, int key, int mark);					/*COMPLETE*/
cilk struct node23* callSearchAndMark(struct node23* root, int key, int mark);					/*COMPLETE*/
int search_mark_and_height(struct node23* current_node, int key, int height);
	
	//Batch Insert Function and helper functions
cilk void complex_batch_insert(struct tree23* current_tree, int *input_integers, int size);		/*COMPLETE*/
cilk struct node23** recursive_split(struct node23* current_node, struct node23** search_array, int *input_integers, int size, int *return_size);	/*COMPLETE*/
cilk struct node23** create_and_link_parent_nodes(int size_a, int size_b, int size_c, struct node23 **node_array_a, struct node23 **node_array_b, struct node23 **node_array_c);	/*COMPELTE*/
	
	//Batch Remove Function and helper functions
cilk void complex_batch_remove(struct tree23* current_tree, int *input_integers, int size);
cilk struct node23* recursive_combine(struct node23* current_node, int sub_tree_height);
void fix_children(struct node23* current_node, struct node23** result_array);
cilk void restructure_children(struct node23** current_node);
int count_children(struct node23* current_node);
struct node23** recursive_merge_tree(struct node23* current_node, struct node23* target_node, int *return_size);
struct node23* merge_trees(struct node23* tree1, struct node23* tree2);
void fix_node_values(struct node23* node);

	//Print Tree
void print_tree(struct node23 *current_node, int i);	/*COMPLETE*/

	//Other
int compare_integers(const void *A, const void *B);		/*COMPLETE*/

	//Parallel Functions
cilk void basic_parallel_for(int start, int end, int first, int insert, int last, struct node23** result, int *input_integers, cilk void (*function_ptr)(struct node23**,int*,int,int,int,int));
cilk void parallel_for_mark(struct node23* root, int* input_integers, struct node23** result_array, int start, int end);
cilk void create_node_array(struct node23** result, int* input_integers, int first, int insert, int last, int index);
cilk void create_node_array_2(struct node23** result, int* input_integers, int first, int insert, int last, int index);
cilk void parallel_for_parent_creator(int start, int end, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b,
										struct node23** node_array_c, cilk void (*function_ptr)(int, int, int, int, struct node23**, struct node23**, struct node23**, struct node23**));
cilk void triplet_parent_creator(int i, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b, struct node23** node_array_c);
cilk void pair_parent_creator(int pair_counter, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b, struct node23** node_array_c);




/*-----------------------------Create Node----------------------------------------------------------------------------------*/
struct node23* create_node(int node_data)	//Initializes a node with 'node_data' being 'left_data'
{
	struct node23* new_node = malloc(sizeof(struct node23));
	if(new_node == NULL)
	{
		printf("\nError allocating memory for new node");
		return new_node;
	}
	
	new_node->left_data = node_data;
	new_node->right_data = VOID_DATA;
	new_node->max = node_data;
	new_node->left = NULL;
	new_node->middle = NULL;
	new_node->right = NULL;
	new_node->is_marked = unmarked;
    new_node->height=0;
	return new_node;
}

struct tree23* create_tree(int node_data)
{
	struct tree23* new_tree = malloc(sizeof(struct tree23));
	if(new_tree == NULL)
	{
		printf("\nError allocating memory for new tree");
		return new_tree;
	}
	
	new_tree->root = create_node(node_data);
	return new_tree;
}


/*----------------------------delete_tree-----------------------------------------------------------------*/
void delete_tree_helper(struct node23 *dead_node)
{
	if(dead_node->left != NULL)
		delete_tree_helper(dead_node->left);
	if(dead_node->middle != NULL)
		delete_tree_helper(dead_node->middle);
	if(dead_node->right != NULL)
		delete_tree_helper(dead_node->right);

	free(dead_node);
	return;	
}

void delete_tree(struct tree23 *dead_tree)
{
	delete_tree_helper(dead_tree->root);
	free(dead_tree);
}



/*---------------------------Binary Search Function-----------------------------------------------------------------*/
int binary_search_function(int (*function_ptr)(int, int, struct node23**, struct node23*), struct node23** node_array, int size, struct node23* target)
{
	int left, right, middle;
	int search_result;
	left = 0;
	right = size;
	do{
		middle = (right-left)/2+left;
		search_result = function_ptr(middle, size, node_array, target);
		
		if (search_result == 1)
			return middle;
		else if(search_result == 0)
		{
			right = middle;
		}
		else left = middle+1;
		

	}while(right-left>0);
	return -1;
}

int find_first(int index, int bound, struct node23** node_array, struct node23* target) 		//Returns 1 if correct index, returns 0 if index is to left, returns 2 if index is to right
{
	if(node_array[index] == target)
	{
		if(index == 0 || node_array[index-1] != target) return 1;
		else return 0;
	}
	if(node_array[index]->left_data < target->left_data)
	{
		return 2;
	}
	else return 0;
}

int find_last(int index, int bound, struct node23** node_array, struct node23* target) 		//Returns 1 if correct index, returns 0 if index is to left, returns 2 if index is to right
{
	if(node_array[index] == target)
	{
		if(index == bound-1 || node_array[index+1] != target) return 1;		//The only difference between find_first and find_last is the change in this line
		else return 2;
	}
	if(node_array[index]->left_data < target->left_data)
	{
		return 2;
	}
	else return 0;
}

int find_insert_index(int *input_array, int size, struct node23* target)
{
	int left, right, middle;
	left = 0;
	right = size;
	while(right-left!=0)
    {
		middle = (right-left)/2+left;
        if (target->left_data >= input_array[middle]){
            if (middle+1==right || input_array[middle+1]>target->left_data){
                return middle+1;
            }
            else {
                left=middle;
            }
        }
        else {
            if (middle==left) {
                return middle;
            }
            else {
                right=middle;
            }
        }
    }
    return -5;
}


/*----------------------------Search and Mark---------------------------------------------------------------*/
struct node23* searchAndMark(struct node23* current_node, int key, int mark)
{
    current_node->is_marked=mark;
	if(current_node->left == NULL)
	{
		return current_node;
	}
	else{
		if(key <= current_node->left_data)
			return searchAndMark(current_node->left, key, mark);
		else if(current_node->right_data == VOID_DATA)
			return searchAndMark(current_node->middle, key, mark);
		else if(key <= current_node->right_data)
			return searchAndMark(current_node->middle, key, mark);
		else if(key > current_node->right_data)
			return searchAndMark(current_node->right, key, mark);
		else return NULL; 								/*Hypothetically should never happen*/
	}
}

cilk struct node23* callSearchAndMark(struct node23* root, int key, int mark)
{
	return searchAndMark(root,key,mark);
}

int search_mark_and_height(struct node23* current_node, int key, int height)
{
    current_node->is_marked = marked;
	if(current_node->left == NULL)
	{
		if(current_node->left_data != key)
			current_node->is_marked = unmarked;
		return height;
	}
	else{
		if(key <= current_node->left_data)
			return search_mark_and_height(current_node->left, key, height+1);
		else if(current_node->right_data == VOID_DATA)
			return search_mark_and_height(current_node->middle, key, height+1);
		else if(key <= current_node->right_data)
			return search_mark_and_height(current_node->middle, key, height+1);
		else if(key > current_node->right_data)
			return search_mark_and_height(current_node->right, key, height+1);
		else return height;							/*Hypothetically, this should never happen*/
	}
}


/*----------------------------complex_batch_insert-------------------------------------------------------*/
cilk void complex_batch_insert(struct tree23* current_tree, int *input_integers, int size) /*Takes in a pointer to a tree, an array of keys to insert, and the size of that array*/
{
	struct node23 **result_array = calloc(size, sizeof(struct node23*));
	struct node23 **result;
	int number_of_children=0;
	int i;

	qsort((void*)input_integers, size, sizeof(int), compare_integers); //Find a faster sort?
	
	/*for(i=0; i<size; ++i)	
	{
		result_array[i] = searchAndMark(current_tree->root, input_integers[i], 1);
	}*/
	
	spawn parallel_for_mark(current_tree->root, input_integers, result_array, 0, size); //Should sync on its own at the end of the function
	sync;
	
    result = spawn recursive_split(current_tree->root, result_array, input_integers, size, &number_of_children);
	sync;
	
	//fix root - to group the array of nodes returned
	if(number_of_children == 0)
		printf("There is a problem with the number_of_children variable");
		
	while(number_of_children>1)
	{
		result = spawn create_and_link_parent_nodes(number_of_children, 0, 0, result, NULL, NULL);
		sync;
		if(number_of_children%3==0)	//Return the size of the result array
			number_of_children = number_of_children/3;
		else
			number_of_children = (number_of_children/3)+1;
	}
	
	current_tree->root = *result;
	
	free(result_array);
	free(result);
}

cilk struct node23** recursive_split(struct node23* current_node, struct node23** search_array, int *input_integers, int size, int *return_size) //Edits return_size to be the size of the return array
{
	int first, insert, last;
	int size_a, size_b, size_c;
	struct node23 **node_array_a, **node_array_b, **node_array_c; //a, b, and c refer to the left, middle, or right parts of the parent node
	struct node23 **result; /*The array of parent nodes that we will return*/
	
	if(current_node==NULL)	/*If current_node doesnt exist return NULL*/
	{
		*return_size = 0;
		return NULL;
	}
	else if(current_node->is_marked == unmarked) //If current_node is not marked, return size 1 and the current node
	{
		*return_size = 1;
		result = malloc(sizeof(struct node23*));
		*result = current_node;
		return result;
	}
	else if(current_node->left == NULL)									/*If current_node IS a leaf ----> generate a sub-array of nodes that correspond to that leaf; return that node array*/
	{
        first = binary_search_function(find_first, search_array, size, current_node);
		last = binary_search_function(find_last, search_array, size, current_node);
		printf("current_node->left_data: %d\n", current_node->left_data);
		insert = find_insert_index(input_integers, size, current_node);
		
		printf("first: %d, last: %d, insert: %d\n", first, last, insert);
		
		result = calloc(2+last-first, sizeof(struct node23*)); /*Allocate a sub-array for each of the leafs*/
		
		if(insert > last) /*Fill the sub-arrays using the integer inputs - Normal case*/
		{
			/*for(i = 0; i < 1+last-first; ++i)
			{
				result[i] = create_node(input_integers[i+first]);
			}*/
			
			spawn basic_parallel_for(0, 1+last-first, first, insert, last, result, input_integers, create_node_array);
			sync;
			result[1+last-first] = current_node;
		}
		else			 /*Exception - the node does not go on the end of the sub-array*/
		{
			/*for(i=0; i<insert-first; ++i) //Fills up the sub-array before the node
				result[i] = create_node(input_integers[i+first]);*/
			spawn basic_parallel_for(0, insert-first, first, insert, last, result, input_integers, create_node_array);
			result[insert-first] = current_node; //Inserts the node
			/*for(i=insert-first+1; i<2+last-first; ++i) //Fills up the sub-array after the node		//PARALLEL FOR
				result[i] = create_node(input_integers[i+first-1]);*/
			spawn basic_parallel_for(insert-first+1, 2+last-first, first, insert, last, result, input_integers, create_node_array_2);
			sync;
		}
		*return_size = 2+last-first;
        current_node->is_marked=unmarked;
		return result;
	}
	else															/*If current_node is NOT a leaf ----> call recursive split and generate new nodes?*/
	{
		node_array_a = spawn recursive_split(current_node->left, search_array, input_integers, size, &size_a);
		node_array_b = spawn recursive_split(current_node->middle, search_array, input_integers, size, &size_b);
		node_array_c = spawn recursive_split(current_node->right, search_array, input_integers, size, &size_c);
		sync;
		printf("Test post-recursive split\n");
	}

	if((size_a+size_b+size_c)%3==0)	//Return the size of the result array
		*return_size = (size_a+size_b+size_c)/3;
	else
		*return_size = (size_a+size_b+size_c)/3+1;


	result = spawn create_and_link_parent_nodes(size_a, size_b, size_c, node_array_a, node_array_b, node_array_c);
	sync;
	
	free(node_array_a);
	free(node_array_b);
	free(node_array_c);
	free(current_node);
    
	return result;
}

cilk struct node23** create_and_link_parent_nodes(int size_a, int size_b, int size_c, struct node23 **node_array_a, struct node23 **node_array_b, struct node23 **node_array_c) /*Regroup the node_arrays, and create new parent nodes as needed*/
{
	int size_total = size_a+size_b+size_c;
	int i;
	int triplet_counter, pair_counter;
	struct node23** result;
	struct node23** temp;
	
	printf("size_total: %d\n", size_total);
    printf("from sizes: {%d,%d,%d}\n",size_a,size_b,size_c);
	if (size_total==0) {
        return NULL;
    }
	if(size_total%3 == 0) //<-------------------------If size is a multiple of 3
	{
		printf("multiple of 3\n");
		result = calloc(size_total/3, sizeof(struct node23*)); /*Allocate a sub-array for each of the leafs*/
		for(i=0; i<size_total/3; ++i)
		{
			result[i] = create_node(VOID_DATA);		//Parent nodes
		}
		/*for(i=0; i<size_total; ++i)		//Creating the parent nodes for the groups of three children
		{
			if (i%3==0) {
				temp=&(result[i/3]->left);
			} else if (i%3==1){
				temp=&(result[i/3]->middle);
			}
			else {
				temp=&(result[i/3]->right);
			}
			
			if(i<size_a)							//Assign temp with pointer magic
			{
				*temp = node_array_a[i];
			}
			else if(i<size_a+size_b)
			{
				*temp = node_array_b[i-size_a];
			}
			else
			{
				*temp = node_array_c[i-size_a-size_b];
			}
		}*/
		
		//Creating the parent nodes for the groups of three children
		spawn parallel_for_parent_creator(0, size_total, size_a, size_b, 0, result, node_array_a, node_array_b, node_array_c, triplet_parent_creator); //This did not give seg faults when isolated
		sync;
       
	   for (i=0;i<size_total/3;++i)
		{
            result[i]->max = result[i]->right->max;
            result[i]->left_data=result[i]->left->max;
            result[i]->right_data=result[i]->middle->max;
            result[i]->height=result[i]->left->height+1;
        }
	}
	else		//If size_total is not a multiple of three
	{     
		printf("NOT a multiple of 3\n");
		result = calloc((size_total/3)+1, sizeof(struct node23*)); /*Allocate a sub-array that will be the parent nodes*/
		if(result == NULL)
		{
			printf("Failure Allocating Memory");
		}
		
		for(i=0; i<(size_total/3)+1; ++i)
		{
			result[i] = create_node(VOID_DATA);		//Create the parent nodes
		}
		
		if(size_total%3 == 1)
			triplet_counter = size_total-4;		//<---two pairs of two leafs will be added to the end (After this next for loop)
		else
			triplet_counter = size_total-2;		//<---one pair of two leafs will be added to the end (After this next for loop)
		if (triplet_counter<0) {
            triplet_counter=0;
        }
		printf("triplet_counter: %d\n", triplet_counter);
		
		/*for(i=0; i<triplet_counter; ++i)		//Linking the parent nodes for the groups of three children
		{
			if (i%3==0) 
			{
				temp = &(result[i/3]->left);
			}
			else if (i%3==1)
			{
				temp = &(result[i/3]->middle);
			}
			else
			{
				temp = &(result[i/3]->right);
			}
			
			if(i<size_a)						//Assign temp with pointer magic
			{
				*temp = node_array_a[i];

			}
			else if(i<size_a+size_b)
			{
				*temp = node_array_b[i-size_a];
			}
			else
			{
				*temp = node_array_c[i-size_a-size_b];
			}
		}*/
		
		//Creating the parent nodes for the groups of three children
		spawn parallel_for_parent_creator(0, triplet_counter, size_a, size_b, 0, result, node_array_a, node_array_b, node_array_c, triplet_parent_creator);		//The cause of one of the seg faults
		sync;
		
		/*for(pair_counter = 0; (pair_counter + i) < size_total; ++pair_counter)	//Linking the parent nodes for the groups of two children
		{
			if (pair_counter%2 == 0) 
			{
				temp=&(result[i/3 + pair_counter/2]->left);
			}
			else
			{
				temp=&(result[i/3 + pair_counter/2]->middle);
			}

			if((i+pair_counter)<size_a)		//Assign temp with pointer magic
			{
				*temp = node_array_a[i+pair_counter];
			}
			else if((i+pair_counter)<size_a+size_b)
			{
				*temp = node_array_b[(i+pair_counter)-size_a];
			}
			else
			{
				*temp = node_array_c[(i+pair_counter)-size_a-size_b];
			}
		}*/
		
		//Creating the parent nodes for the groups of three children
		spawn parallel_for_parent_creator(0, size_total-triplet_counter, size_a, size_b, triplet_counter, result, node_array_a, node_array_b, node_array_c, pair_parent_creator); //No seg fault when isolated
        sync;
		for (i=0;i<(size_total/3)+1;i++){	//sets the max data field for every new node
            //printf("TEST10\n");
            if (result[i]->middle==NULL){
                printf("This should never happen!\n");
                result[i]->max=result[i]->left->max;
            }
            else if (result[i]->right==NULL){
                //printf("Just before middle is dereferenced: i is %d: {%d,%d}\n",i, result[i]->left,result[i]->middle);
                result[i]->max = result[i]->middle->max;								//Seg fault where middle is NULL, and it is dereferenced here, starts occuring when line 434 is added
                result[i]->left_data=result[i]->left->max;
            }
            else {
                //printf("i is %d: {%d,%d, %d}\n",i, result[i]->left,result[i]->middle, result[i]->right)
                result[i]->max = result[i]->right->max;
                result[i]->left_data=result[i]->left->max;
                result[i]->right_data=result[i]->middle->max;
            }
            result[i]->height=result[i]->left->height+1;
            //printf("TEST11\n");
        }
	}
	return result;
}



/*---------------------------complex_batch_remove---------------------------------------------------------*/
cilk void complex_batch_remove(struct tree23* current_tree, int *input_integers, int size)
{
	int i;
	int height;
	struct node23* result;
	
	height = search_mark_and_height(current_tree->root, input_integers[0],0);
	
	for(i=1; i<size; ++i)			//PARALLEL FOR
	{
		search_mark_and_height(current_tree->root, input_integers[i],0);
	}
	
	result = spawn recursive_combine(current_tree->root, height);
	sync;
	//Fix Root
	
    /*There is a lot of stuff to do in the root. Must think of a way to do it without increasing time complexity.*/
	
    /*
    if (current_tree->root->right==NULL){
        printf("get over here!\n");
        fix_node_values(current_tree->root);
    }
    else {
        current_tree->root->max  = current_tree->root->right->max;
        current_tree->root->left_data=current_tree->root->left->max;
        current_tree->root->right_data=current_tree->root->middle->max;
    }*/
    current_tree->root=result;
	//If root has more than two children, do nothing
}


cilk struct node23* recursive_combine(struct node23* current_node, int sub_tree_height)
{
	struct node23* result_array[3];

	
	if(current_node == NULL)						//If current_node is NULL
	{	
		return NULL;
	}
	
	if(current_node->is_marked == marked)		//If the current_node is Marked
	{
		if(sub_tree_height == 0)						//If current node is a Marked Leaf
		{
			//delete
            printf("delete a node: %d\n",current_node->left_data);
			free(current_node);
			return NULL;
		}
		else											//If current node is Marked but NOT a Leaf
		{
			result_array[0] = spawn recursive_combine(current_node->left, sub_tree_height-1);
			sync;
			result_array[1] = spawn recursive_combine(current_node->middle, sub_tree_height-1);
			sync;
			result_array[2] = spawn recursive_combine(current_node->right, sub_tree_height-1);
			sync;
			
			fix_children(current_node, result_array);							//Shifts children left and unmarkes current_node if it has more than one child
			if(current_node->left == NULL)						//If current_node has no remaining children
			{
				free(current_node);
				return NULL;
			}
			//RESTRUCTURE A and B using IF statements
			spawn restructure_children(&current_node);
			sync;
			return current_node;
		}
	}
	else										//If the current_node is NOT marked
	{
		return current_node;
	}
}

void fix_children(struct node23* current_node, struct node23** result_array)		//For a 2-3 tree, result_array will always be of size 3
{
	int i;
	int counter = 0;
	
	current_node->left = NULL;
	current_node->right = NULL;
	current_node->middle = NULL;
	
	
	for(i=0; i<3; ++i)
	{
		if(result_array[i] != NULL)	//Shifts all children as far left as possible
		{
			(*((struct node23**)current_node+counter))=result_array[i];
			++counter;
		}
	}
	
	//SET MAX
}

cilk void restructure_children(struct node23** current_node)
{
	struct node23* node;
    if ((*current_node)->middle==NULL) {
        node = *current_node;
        *current_node=(*current_node)->left;
        free(node);
        return;
    }
    else {
        node = merge_trees((*current_node)->left,(*current_node)->middle);
        if ((*current_node)->right!=NULL){
            node = merge_trees((*current_node)->right,node);
        }
        (*current_node)=node;
    }
}

int count_children(struct node23* current_node)
{
	int counter = 0;
    if (current_node==NULL) {
        return 0;
    }
	if(current_node->left!=NULL)
	{
		++counter;
	}
	if(current_node->middle)
	{
		++counter;
	}
	if(current_node->right)
	{
		++counter;
	}
	return counter;
}

/*
struct node23* combine_tree(struct node23* left, struct node23* right) {
    struct node23* big, small, branch_place;
    struct node23** top_array;
    if (left==NULL || right==NULL) {
        printf("left or right is null\n");
        return NULL;
    }
    if (left->height > right->height){
        big=left;
        small=right;
    }
    else if (left->height==right->height) {
        big = create_node(left->max);
        big->left=left;
        big->middle = right;
        big->max= right->max;
        big->height=left->height +1;
    }
    else {
        small=left;
        big=right;
    }
    
    top_array = recursive_merge_tree(big, small, int size, int *return_size);
    branch_place = search_for_tree(big, small); //Search for small in big.
    if (small==left){ //Small goes to the left of every child of branch_place.
        merge_array={small, branch_place->left, branch_place->middle, branch_place->right};
    }
    else {
        merge_array{branch_place->left, branch_place->middle, branch_place->right, small};
    }
    merge_children(merge_array);
}*/

struct node23** recursive_merge_tree(struct node23* current_node, struct node23* target_node, int *return_size) {
    struct node23** result = calloc(2,sizeof(struct node23*));
    struct node23* targetL=NULL;
    struct node23* targetM=NULL;
    struct node23* targetR=NULL;
    struct node23** result_a, **result_b, **result_c;
    int size_a,size_b,size_c;
    int i;
    
    if (target_node==NULL ){
        if (current_node!=NULL){
            *return_size = 1;
            result[0]=current_node;
            return result;
        }
        else {
            *return_size=0;
            return result;
        }
    }
    if (current_node->height == target_node->height){
        *return_size=2;
        if (current_node->left_data < target_node->left_data){
            result[0]=current_node;
            result[1]=target_node;
        }
        else {
            result[0]=target_node;
            result[1]=current_node;
        }
        return result;
    }
    else {
        if(target_node->left_data < current_node->left_data) {
            targetL=target_node;
        }
        else if(current_node->right_data == VOID_DATA)
            targetM=target_node;
        else if(target_node->left_data < current_node->right_data)
            targetM=target_node;
        else if(target_node->left_data > current_node->right_data)
            targetR=target_node;
        else {
            printf("somehow target is equal to this node\n");
            return NULL;
        }
        result_a = recursive_merge_tree(current_node->left, targetL, &size_a);
        result_b = recursive_merge_tree(current_node->middle, targetM, &size_b);
        result_c = recursive_merge_tree(current_node->right, targetR, &size_c);
        
        if (size_a+size_b+size_c <=3) {
            for (i=0;i<3;++i){
                if (i<size_a){
                    *((struct node23**)(current_node) + i) = result_a[i];
                }
                else if (i<size_a+size_b){
                    *((struct node23**)(current_node) + i) = result_b[i-size_a];
                }
                else {
                    *((struct node23**)(current_node) + i) = result_c[i-size_a-size_b];
                }
            }
            *return_size = 1;
            result[0]=current_node;
            return result;
        }
        if (size_a+size_b+size_c ==4) {
            result[0]=current_node;
            result[1]=create_node(VOID_DATA);
            if (size_a>1) {
                result[0]->left=result_a[0];
                result[0]->middle=result_a[1];
                result[0]->right=NULL;
                result[1]->left=result_b[0];
                result[1]->middle=result_c[0];
            }
            else if (size_c>1) {
                result[0]->left=result_a[0];
                result[0]->middle=result_b[0];
                result[0]->right=NULL;
                result[1]->left=result_c[0];
                result[1]->middle=result_c[1];
            }
            else {
                printf("%d,%d,%d\n",size_a,size_b,size_c);
                printf("something bad here\n");
            }
            fix_node_values(result[1]);
            *return_size=2;
            return result;
        }
        else {
            printf("something bad happened\n");
        }
    }
    printf("-1 returned\n");
    return -1;
}
struct node23* merge_trees(struct node23* tree1, struct node23* tree2) {
    int i=0;
    struct node23** results;
    struct node23* big;
    struct node23* small;
    if (tree1->height>=tree2->height){
        big=tree1;
        small=tree2;
    }
    else {
        big=tree2;
        small=tree1;
    }
   results=recursive_merge_tree(big, small, &i);
   if (i<2){
        return results[0];
    }
    else {
        printf("a problem has occured in the root. . .\n");
        printf("useful info %d,%d\n", results[0]->max, results[1]->max);
        big=create_node(VOID_DATA);
        big->left=results[0];
        big->middle=results[1];
        fix_node_values(big);
        printf("asdfasdfasf\n");
        print_tree(big,0);
        printf("asdfasdfasf\n");
        return big;
    }
}
/*
struct node23* search_for_tree(struct node23* current_node, struct node23* target)
{
    if (current_node->height-1==target->height) {
        return current_node;
    }
    else if(current_node->left == NULL)
	{
		printf("this should not happen\n");
        return NULL;
	}
	else{
		if(target->left_data < current_node->left_data)
			return search_for_tree(current_node->left, target);
		else if(current_node->right_data == VOID_DATA)
			return search_for_tree(current_node->middle, target);
		else if(key < current_node->right_data)
			return search_for_tree(current_node->middle, target);
		else if(key > current_node->right_data)
			return search_for_tree(current_node->right, target);
		else {
            printf("somehow target is equal to a node\n");
            return NULL;
        } 								
	}
}
*/
/*------------------------- print_tree ---------------------------------------------------------------------------------*/
void print_tree(struct node23 *current_node, int i)
{   
    int j;
    if (current_node==NULL) {
        printf("NULL SUBTREE\n");
        return;
    }
	if(current_node->left != NULL) {
		print_tree(current_node->left, i+1);
    }
	
    for (j=0;j<i;j++){
        printf("\t\t");
    }
    printf("[%d, %d] {%d} (%d) *%p", current_node->left_data,current_node->right_data, current_node->max, current_node->height,current_node);
	printf("\n");
    
	if(current_node->middle != NULL){
		print_tree(current_node->middle, i+1);
    }
	if(current_node->right != NULL){
		print_tree(current_node->right, i+1);
    }
		
	return;	
}

/*-----------------------------Other----------------------------------------------------------*/
int compare_integers(const void *A, const void *B)
{
	return *(int*)A - *(int*)B;
}



/*---------------------------Parallel Functions-------------------------------------------------*/

	//Singled out and tested basic_parallel_for; no seg faults due to this alone
cilk void basic_parallel_for(int start, int end, int first, int insert, int last, struct node23** result, int *input_integers, cilk void (*function_ptr)(struct node23**,int*,int,int,int,int))
{
	int middle = start+(end-start)/2;
	if (end-start<=PARALLEL_CUTOFF) {
		for (start; start < end; ++start) {
            spawn function_ptr(result, input_integers, first,insert,last,start);
		}
    }
	else
	{		
		spawn basic_parallel_for(start,middle,first,insert,last,result, input_integers, function_ptr); 	//start -> middle-1
		spawn basic_parallel_for(middle+1,end,first,insert,last,result, input_integers, function_ptr); 	//middle+1 -> end-1
		spawn function_ptr(result, input_integers, first, insert, last, middle);						//middle
	}
	//return;				//Removing this didnt cause seg faults or anything
}

	//When included along with the basic_parallel_for, seg faults occured occasionally
cilk void parallel_for_mark(struct node23* root, int* input_integers, struct node23** result_array, int start, int end)
{
    int middle = start+(end-start)/2;
	
    if (end-start<=PARALLEL_CUTOFF) {
        for (start; start <end; ++start)
		{
            result_array[start] = spawn callSearchAndMark(root, input_integers[start], 1);
        }
    }
    else
	{
        spawn parallel_for_mark(root, input_integers, result_array, start, middle);
        spawn parallel_for_mark(root, input_integers, result_array, middle + 1, end);
        result_array[middle] = spawn callSearchAndMark(root, input_integers[middle], 1);
    }
	//sync;			//I think this is unneccissary
}

cilk void create_node_array(struct node23** result, int* input_integers, int first,int insert,int last, int index)
{
	result[index] = create_node(input_integers[index+first]);
}

cilk void create_node_array_2(struct node23** result, int* input_integers, int first,int insert,int last, int index)
{
	result[index] = create_node(input_integers[index+first-1]);
}


cilk void parallel_for_parent_creator(int start, int end, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a,struct node23** node_array_b,
										struct node23** node_array_c,cilk void (*function_ptr)(int, int, int, int, struct node23**, struct node23**, struct node23**, struct node23**))
{	//function_ptr(index,size_a,size_b,constant,result,node_array_a,...)
	int middle = start+(end-start)/2;
	if(end-start<=PARALLEL_CUTOFF)
		for(start;start<end;++start)
		{
			spawn function_ptr(start,size_a,size_b,constant,result,node_array_a,node_array_b,node_array_c);
		}
	else
	{
		spawn parallel_for_parent_creator(start, middle,size_a,size_b,constant,result,node_array_a,node_array_b,node_array_c, function_ptr);
		spawn parallel_for_parent_creator(middle+1,end, size_a,size_b,constant,result,node_array_a,node_array_b,node_array_c, function_ptr);
		spawn function_ptr(middle,size_a,size_b,constant,result,node_array_a,node_array_b,node_array_c);
	}
	//return;					//removing this did not cause any seg faults
}

cilk void triplet_parent_creator(int i, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b, struct node23** node_array_c)
{
	struct node23** temp;
	
	if (i%3==0) {
		temp=&(result[i/3]->left);
	} else if (i%3==1){
		temp=&(result[i/3]->middle);
	}
	else {
		temp=&(result[i/3]->right);
	}
	
	if(i<size_a)							//Assign temp with pointer magic
	{
		*temp = node_array_a[i];
	}
	else if(i<size_a+size_b)
	{
		*temp = node_array_b[i-size_a];
	}
	else
	{
		*temp = node_array_c[i-size_a-size_b];
	}
	//return;					//Removing this did not cause any seg faults
}

cilk void pair_parent_creator(int pair_counter, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b, struct node23** node_array_c)
{
	struct node23** temp;
	
	if (pair_counter%2 == 0) {
		temp=&(result[constant/3 + pair_counter/2]->left);
	}
	else{
		temp=&(result[constant/3 + pair_counter/2]->middle);
	}

	if((constant+pair_counter)<size_a)		//Assign temp with pointer magic
	{
		*temp = node_array_a[constant+pair_counter];
	}
	else if((constant+pair_counter)<size_a+size_b)
	{
		*temp = node_array_b[(constant+pair_counter)-size_a];
	}
	else
	{
		*temp = node_array_c[(constant+pair_counter)-size_a-size_b];
	}
	//return;
}
	

void fix_node_values(struct node23* node) {
    node->left_data = node->left->max;
    node->height=node->left->height+1;
    if (node->right==NULL){
        node->max=node->middle->max;
        node->right_data=VOID_DATA;
        return;
    }
    else {
        node->max=node->right->max;
        node->right_data=node->middle->max;
    }
}
	
	
	
	
	
