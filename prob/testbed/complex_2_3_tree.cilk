#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#define VOID_DATA (int)-INFINITY
#define PARALLEL_CUTOFF 2


/* 2-3 Tree that supports parallel operations */
/* Tyler Romero and Kefu Lu */
/*
    TODO: Use a Parallel sort from the cilk library instead of just calling qsort from the C library
    TODO: Use batchify - need to finalize syntax for that first though.
*/

/*-----------------------------Structs-----------------------------------------------------------------------------------------*/
struct node23
{
	struct node23 *left, *middle, *right;
	int left_data, right_data;
	int max;
    int height;
	enum mark_status{unmarked, marked} is_marked;
};

struct tree23
{
	struct node23 *root;
};



/*-----------------------------Function Declarations----------------------------------------------------------------------------*/
	//Initialization Functions
struct node23* create_node(int node_data);
struct tree23* create_tree(int node_data);	

	//Delete Tree
void delete_tree_helper(struct node23 *dead_node);
void delete_tree(struct tree23 *dead_tree);			

	//Special Search Functions
int binary_search_function(int (*function_ptr)(int, int, struct node23**, struct node23*), struct node23** node_array, int size, struct node23* target);
int find_first(int index, int bound, struct node23** node_array, struct node23* target); 		
int find_last(int index, int bound, struct node23** node_array, struct node23* target); 		
int find_insert_index(int *input_array, int size, struct node23* target);				

	//Search and Mark
struct node23* searchAndMark(struct node23* current_node, int key, int mark);					
cilk struct node23* callSearchAndMark(struct node23* root, int key, int mark);					
int search_mark_and_height(struct node23* current_node, int key, int height);
cilk void search_for_delete(struct node23* root, int key);
	
	//Batch Insert Function and helper functions
cilk void complex_batch_insert(struct tree23* current_tree, int *input_integers, int size);
cilk struct node23** recursive_split(struct node23* current_node, struct node23** search_array, int *input_integers, int size, int *return_size);
cilk struct node23** create_and_link_parent_nodes(int size_a, int size_b, int size_c, struct node23 **node_array_a, struct node23 **node_array_b, struct node23 **node_array_c);
	
	//Batch Remove Function and helper functions
cilk void complex_batch_remove(struct tree23* current_tree, int *input_integers, int size);
cilk struct node23* recursive_combine(struct node23* current_node, int sub_tree_height);
void fix_children(struct node23* current_node, struct node23** result_array);
cilk void restructure_children(struct node23** current_node);
struct node23** recursive_merge_tree(struct node23* current_node, struct node23* target_node, int *return_size);
struct node23* merge_trees(struct node23* tree1, struct node23* tree2);
void fix_node_values(struct node23* node);

	//Print Tree using an in-order tree-walk.
void print_tree(struct node23 *current_node, int i);	

	//Other
int compare_integers(const void *A, const void *B);		//Needed for the sort in the insertion.

	//Parallel Functions
cilk void basic_parallel_for(int start, int end, int first, int insert, int last, struct node23** result, int *input_integers, cilk void (*function_ptr)(struct node23**,int*,int,int,int,int));
cilk void parallel_for_mark(struct node23* root, int* input_integers, struct node23** result_array, int start, int end);
cilk void create_node_array(struct node23** result, int* input_integers, int first, int insert, int last, int index);
cilk void create_node_array_2(struct node23** result, int* input_integers, int first, int insert, int last, int index);
cilk void parallel_for_parent_creator(int start, int end, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b,
										struct node23** node_array_c, cilk void (*function_ptr)(int, int, int, int, struct node23**, struct node23**, struct node23**, struct node23**));
cilk void triplet_parent_creator(int i, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b, struct node23** node_array_c);
cilk void pair_parent_creator(int pair_counter, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b, struct node23** node_array_c);
cilk void mark_for_delete(struct node23* root, int* input, int first, int last);



/*-----------------------------Constructor Methods----------------------------------------------------------------------------------*/
struct node23* create_node(int node_data)	//Initializes a node with 'node_data' being 'left_data'
{
	struct node23* new_node = malloc(sizeof(struct node23));
	if(new_node == NULL)
	{
		printf("\nError allocating memory for new node");
		return new_node;
	}
	
	new_node->left_data = node_data;
	new_node->right_data = VOID_DATA;
	new_node->max = node_data;
	new_node->left = NULL;
	new_node->middle = NULL;
	new_node->right = NULL;
	new_node->is_marked = unmarked;
	new_node->height=0;
	return new_node;
}

struct tree23* create_tree(int node_data)
{
	struct tree23* new_tree = malloc(sizeof(struct tree23));
	if(new_tree == NULL)
	{
		printf("\nError allocating memory for new tree");
		return new_tree;
	}
	
	new_tree->root = create_node(node_data);
	return new_tree;
}


/*----------------------------delete_tree (free all the memory)-----------------------------------------------------------------*/
void delete_tree_helper(struct node23 *dead_node)
{
	if(dead_node->left != NULL)
		delete_tree_helper(dead_node->left);
	if(dead_node->middle != NULL)
		delete_tree_helper(dead_node->middle);
	if(dead_node->right != NULL)
		delete_tree_helper(dead_node->right);

	free(dead_node);
	return;	
}

void delete_tree(struct tree23 *dead_tree)
{
	delete_tree_helper(dead_tree->root);
	free(dead_tree);
}



/*---------------------------Search functions-----------------------------------------------------------------*/
int binary_search_function(int (*function_ptr)(int, int, struct node23**, struct node23*), struct node23** node_array, int size, struct node23* target)
{
	int left, right, middle;
	int search_result;
	left = 0;
	right = size;
	do{
		middle = (right-left)/2+left;
		search_result = function_ptr(middle, size, node_array, target);
		
		if (search_result == 1)
			return middle;
		else if(search_result == 0)
		{
			right = middle;
		}
		else left = middle+1;
		

	}while(right-left>0);
	return -1;
}

int find_first(int index, int bound, struct node23** node_array, struct node23* target) 		//Returns 1 if correct index, returns 0 if index is to left, returns 2 if index is to right
{
	if(node_array[index] == target)
	{
		if(index == 0 || node_array[index-1] != target) return 1;
		else return 0;
	}
	if(node_array[index]->left_data < target->left_data)
	{
		return 2;
	}
	else return 0;
}

int find_last(int index, int bound, struct node23** node_array, struct node23* target) 		//Returns 1 if correct index, returns 0 if index is to left, returns 2 if index is to right
{
	if(node_array[index] == target)
	{
		if(index == bound-1 || node_array[index+1] != target) return 1;		//The only difference between find_first and find_last is the change in this line
		else return 2;
	}
	if(node_array[index]->left_data < target->left_data)
	{
		return 2;
	}
	else return 0;
}

int find_insert_index(int *input_array, int size, struct node23* target)
{
	int left, right, middle;
	left = 0;
	right = size;
	while(right-left!=0)
    {
		middle = (right-left)/2+left;
        if (target->left_data >= input_array[middle]){
            if (middle+1==right || input_array[middle+1]>target->left_data){
                return middle+1;
            }
            else {
                left=middle;
            }
        }
        else {
            if (middle==left) {
                return middle;
            }
            else {
                right=middle;
            }
        }
    }
    return -5;
}


/*----------------------------Search and Mark---------------------------------------------------------------*/
struct node23* searchAndMark(struct node23* current_node, int key, int mark)
{
    current_node->is_marked=mark;
	if(current_node->left == NULL)
	{
		return current_node;
	}
	else{
		if(key <= current_node->left_data)
			return searchAndMark(current_node->left, key, mark);
		else if(current_node->right_data == VOID_DATA)
			return searchAndMark(current_node->middle, key, mark);
		else if(key <= current_node->right_data)
			return searchAndMark(current_node->middle, key, mark);
		else if(key > current_node->right_data)
			return searchAndMark(current_node->right, key, mark);
		else return NULL; 								/*This should never happen*/
	}
}

cilk struct node23* callSearchAndMark(struct node23* root, int key, int mark)
{
	return searchAndMark(root,key,mark);
}

int search_mark_and_height(struct node23* current_node, int key, int height)
{
	if(current_node->left == NULL)
	{
		if(current_node->left_data == key)
			current_node->is_marked = marked;
		return height;
	}
	else{
		current_node->is_marked=marked;
		if(key <= current_node->left_data)
			return search_mark_and_height(current_node->left, key, height+1);
		else if(current_node->right_data == VOID_DATA)
			return search_mark_and_height(current_node->middle, key, height+1);
		else if(key <= current_node->right_data)
			return search_mark_and_height(current_node->middle, key, height+1);
		else if(key > current_node->right_data)
			return search_mark_and_height(current_node->right, key, height+1);
		else return height;							/*This should never happen*/
	}
}

cilk void search_for_delete(struct node23* root, int key){
     search_mark_and_height(root,key,0);
}


/*Insert/remove functions -> this is what will call batchify*/
cilk void insert_item(struct tree23* tree, int input){
    Cilk_batchify(_cilk_ws, &complex_batch_insert, tree, &input, sizeof(int), NULL);
}



/*----------------------------complex_batch_insert-------------------------------------------------------*/
cilk void complex_batch_insert(struct tree23* current_tree, int *input_integers, int size) /*Takes in a pointer to a tree, an array of keys to insert, and the size of that array*/
{
	struct node23 **result_array = calloc(size, sizeof(struct node23*));
	struct node23 **result;
	int number_of_children=0;
	
	qsort((void*)input_integers, size, sizeof(int), compare_integers); //Find a faster sort?
	
	spawn parallel_for_mark(current_tree->root, input_integers, result_array, 0, size); //Should sync on its own at the end of the function
	sync;
	
    	result = spawn recursive_split(current_tree->root, result_array, input_integers, size, &number_of_children);
	sync;
	
	//fix root - to group the array of nodes returned
	if(number_of_children == 0)
		printf("There is a problem with the number_of_children variable");
		
	while(number_of_children>1)
	{
		result = spawn create_and_link_parent_nodes(number_of_children, 0, 0, result, NULL, NULL);
		sync;
		if(number_of_children%3==0)	//Return the size of the result array
			number_of_children = number_of_children/3;
		else
			number_of_children = (number_of_children/3)+1;
	}
	
	current_tree->root = *result;
	
	free(result_array);
	free(result);
    Cilk_terminate_batch(_cilk_ws);
}

cilk struct node23** recursive_split(struct node23* current_node, struct node23** search_array, int *input_integers, int size, int *return_size) //Edits return_size to be the size of the return array
{
	int first, insert, last;
	int size_a, size_b, size_c;
	struct node23 **node_array_a, **node_array_b, **node_array_c; //a, b, and c refer to the left, middle, or right parts of the parent node
	struct node23 **result; /*The array of parent nodes that we will return*/
	
	if(current_node==NULL)	/*If current_node doesnt exist return NULL*/
	{
		*return_size = 0;
		return NULL;
	}
	else if(current_node->is_marked == unmarked) //If current_node is not marked, return size 1 and the current node
	{
		*return_size = 1;
		result = malloc(sizeof(struct node23*));
		*result = current_node;
		return result;
	}
	else if(current_node->left == NULL)									/*If current_node IS a leaf ----> generate a sub-array of nodes that correspond to that leaf; return that node array*/
	{
        first = binary_search_function(find_first, search_array, size, current_node);
		last = binary_search_function(find_last, search_array, size, current_node);
		insert = find_insert_index(input_integers, size, current_node);
		
		
		result = calloc(2+last-first, sizeof(struct node23*)); /*Allocate a sub-array for each of the leafs*/
		
		if(insert > last) /*Fill the sub-arrays using the integer inputs - Normal case*/
		{
			spawn basic_parallel_for(0, 1+last-first, first, insert, last, result, input_integers, create_node_array);
			sync;
			result[1+last-first] = current_node;
		}
		else			 
		{
			spawn basic_parallel_for(0, insert-first, first, insert, last, result, input_integers, create_node_array);
			result[insert-first] = current_node; //Inserts the node
			spawn basic_parallel_for(insert-first+1, 2+last-first, first, insert, last, result, input_integers, create_node_array_2);
			sync;
		}
		*return_size = 2+last-first;
        current_node->is_marked=unmarked;
		return result;
	}
	else															/*If current_node is NOT a leaf ----> call recursive split and generate new nodes?*/
	{
		node_array_a = spawn recursive_split(current_node->left, search_array, input_integers, size, &size_a);
		node_array_b = spawn recursive_split(current_node->middle, search_array, input_integers, size, &size_b);
		node_array_c = spawn recursive_split(current_node->right, search_array, input_integers, size, &size_c);
		sync;
	}

	if((size_a+size_b+size_c)%3==0)	//Return the size of the result array
		*return_size = (size_a+size_b+size_c)/3;
	else
		*return_size = (size_a+size_b+size_c)/3+1;


	result = spawn create_and_link_parent_nodes(size_a, size_b, size_c, node_array_a, node_array_b, node_array_c);
	sync;
	
	free(node_array_a);
	free(node_array_b);
	free(node_array_c);
	free(current_node);
    
	return result;
}

cilk struct node23** create_and_link_parent_nodes(int size_a, int size_b, int size_c, struct node23 **node_array_a, struct node23 **node_array_b, struct node23 **node_array_c) /*Regroup the node_arrays, and create new parent nodes as needed*/
{
	int size_total = size_a+size_b+size_c;
	int i;
	int triplet_counter;
	struct node23** result;
	
	if (size_total==0) {
        return NULL;
    }
	if(size_total%3 == 0) //<-------------------------If size is a multiple of 3
	{
		result = calloc(size_total/3, sizeof(struct node23*)); /*Allocate a sub-array for each of the leafs*/
		for(i=0; i<size_total/3; ++i)
		{
			result[i] = create_node(VOID_DATA);		//Parent nodes
		}
		//Creating the parent nodes for the groups of three children
		spawn parallel_for_parent_creator(0, size_total, size_a, size_b, 0, result, node_array_a, node_array_b, node_array_c, triplet_parent_creator); //This did not give seg faults when isolated
		sync;
       
	   for (i=0;i<size_total/3;++i)
		{
            result[i]->max = result[i]->right->max;
            result[i]->left_data=result[i]->left->max;
            result[i]->right_data=result[i]->middle->max;
            result[i]->height=result[i]->left->height+1;
        }
	}
	else		//If size_total is not a multiple of three
	{     
		result = calloc((size_total/3)+1, sizeof(struct node23*)); /*Allocate a sub-array that will be the parent nodes*/
		if(result == NULL)
		{
			printf("Failure Allocating Memory");
		}
		
		for(i=0; i<(size_total/3)+1; ++i)
		{
			result[i] = create_node(VOID_DATA);		//Create the parent nodes
		}
		
		if(size_total%3 == 1)
			triplet_counter = size_total-4;		//<---two pairs of two leafs will be added to the end (After this next for loop)
		else
			triplet_counter = size_total-2;		//<---one pair of two leafs will be added to the end (After this next for loop)
		if (triplet_counter<0) {
            triplet_counter=0;
        }
		//Creating the parent nodes for the groups of three children
		spawn parallel_for_parent_creator(0, triplet_counter, size_a, size_b, 0, result, node_array_a, node_array_b, node_array_c, triplet_parent_creator);		//The cause of one of the seg faults
		sync;
		
		//Creating the parent nodes for the groups of three children
		spawn parallel_for_parent_creator(0, size_total-triplet_counter, size_a, size_b, triplet_counter, result, node_array_a, node_array_b, node_array_c, pair_parent_creator); //No seg fault when isolated
        sync;
        
		for (i=0;i<(size_total/3)+1;i++){	//sets the data fields for every new node, TODO need to be parallel for?
            fix_node_values(result[i]);
        }
	}
	return result;
}



/*---------------------------complex_batch_remove---------------------------------------------------------*/
cilk void complex_batch_remove(struct tree23* current_tree, int *input_integers, int size)
{
	int height;
	struct node23* result;
	
	height = search_mark_and_height(current_tree->root, input_integers[0],0);
	spawn mark_for_delete(current_tree->root, input_integers, 1, size); //This is a parallel-for loop.
	sync;					  
	result = spawn recursive_combine(current_tree->root, height);
	sync;

    if (current_tree->root==result){
	   return;
	}
	else {
	     free(current_tree->root);
	     current_tree->root=result;
	}
}


cilk struct node23* recursive_combine(struct node23* current_node, int sub_tree_height)
{
	struct node23* result_array[3];

	
	if(current_node == NULL)						//If current_node is NULL
	{	
		return NULL;
	}
	
	if(current_node->is_marked == marked)		//If the current_node is Marked
	{
		if(sub_tree_height == 0)						//If current node is a Marked Leaf
		{
			//delete
			free(current_node);
			return NULL;
		}
		else											//If current node is Marked but NOT a Leaf
		{
			result_array[0] = spawn recursive_combine(current_node->left, sub_tree_height-1);
			result_array[1] = spawn recursive_combine(current_node->middle, sub_tree_height-1);
			result_array[2] = spawn recursive_combine(current_node->right, sub_tree_height-1);
			sync;
			
			fix_children(current_node, result_array);							//Shifts children left and unmarkes current_node if it has more than one child
			if(current_node->left == NULL)						//If current_node has no remaining children
			{
				free(current_node);
				return NULL;
			}
            //Rebalance if necessary.
			spawn restructure_children(&current_node);
			sync;
			return current_node;
		}
	}
	else										//If the current_node is NOT marked, then do nothing.
	{
		return current_node;
	}
}

void fix_children(struct node23* current_node, struct node23** result_array)		//For a 2-3 tree, result_array will always be of size 3
{
	int i;
	int counter = 0;
	
	current_node->left = NULL;
	current_node->right = NULL;
	current_node->middle = NULL;
	
	for(i=0; i<3; ++i)
	{
		if(result_array[i] != NULL)	//Shifts all children as far left as possible
		{
			(*((struct node23**)current_node+counter))=result_array[i];
			++counter;
		}
	}
}

cilk void restructure_children(struct node23** current_node)
{
    struct node23* node;
    if ((*current_node)->middle==NULL) {
        node = *current_node;
        *current_node=(*current_node)->left;
        free(node);
        return;
    }
    else {
        node = merge_trees((*current_node)->left,(*current_node)->middle);
            if ((*current_node)->right!=NULL){
                node = merge_trees((*current_node)->right,node);
            }
        (*current_node)=node;
    }
}

struct node23** recursive_merge_tree(struct node23* current_node, struct node23* target_node, int *return_size) {
    struct node23** result = calloc(2,sizeof(struct node23*));
    struct node23** result_a,**result_b,**result_c;
    int size_a,size_b,size_c;
    int i;
    if (target_node==NULL ){
        result[0]=current_node;
        (*return_size)=(current_node==NULL)?0:1;
        return result;
    }
    if (current_node->height == target_node->height){
        *return_size=2;
        if (current_node->left_data < target_node->left_data){
            result[0]=current_node;
            result[1]=target_node;
        }
        else {
            result[0]=target_node;
            result[1]=current_node;
        }
        return result;
    }
    else {
        //Make recursive call to either left, right, or middle.
        if(target_node->left_data < current_node->left_data) {
           result_b = calloc(1,sizeof(struct node23*));
           *result_b = current_node->middle;
           size_b=(current_node->middle==NULL)?0:1;
           result_c = calloc(1,sizeof(struct node23*));
           *result_c = current_node->right;
           size_c=(current_node->right==NULL)?0:1;
           
          result_a = recursive_merge_tree(current_node->left, target_node, &size_a);
     	}
        else if(current_node->right_data == VOID_DATA || target_node->left_data < current_node->right_data) {
           result_a = calloc(1,sizeof(struct node23*));
           *result_a = current_node->left;
           size_a=(current_node->left==NULL)?0:1;
           result_c = calloc(1,sizeof(struct node23*));
           *result_c = current_node->right;
           size_c=(current_node->right==NULL)?0:1;
           
            result_b = recursive_merge_tree(current_node->middle, target_node, &size_b);
        }
        else if(target_node->left_data > current_node->right_data) {
           result_a = calloc(1,sizeof(struct node23*));
           *result_a = current_node->left;
           size_a=(current_node->left==NULL)?0:1;
           result_b = calloc(1,sizeof(struct node23*));
           *result_b = current_node->middle;
           size_b=(current_node->middle==NULL)?0:1;
           
           result_c = recursive_merge_tree(current_node->right, target_node, &size_c);
       }
        else {
            return NULL;
        }
        
        //Creates extra node if necessary.
        if (size_a+size_b+size_c <=3) {
            for (i=0;i<3;++i){
                if (i<size_a){
                    *((struct node23**)(current_node) + i) = *(result_a+i);
                }
                else if (i<size_a+size_b){
                    *((struct node23**)(current_node) + i) = *(result_b+(i-size_a));
                }
                else {
                    *((struct node23**)(current_node) + i) = *(result_c+(i-size_a-size_b));
                }
            }
            *return_size = 1;
            result[0]=current_node;
            fix_node_values(result[0]);
        }
        else if (size_a+size_b+size_c ==4) {
            result[0]=current_node;
            result[1]=create_node(VOID_DATA);
	    if (size_a>1) {
                result[0]->left=*result_a;
                result[0]->middle=*(result_a+1);
                result[0]->right=NULL;
                result[1]->left=*result_b;
                result[1]->middle=*result_c;
            }
            else if (size_c>1) {
                result[0]->left=*result_a;
                result[0]->middle=*result_b;
                result[0]->right=NULL;
                result[1]->left=*result_c;
                result[1]->middle=*(result_c+1);
            }
            else {
	    	 //Should never happen.
            }
        fix_node_values(result[0]);
        fix_node_values(result[1]);
        *return_size=2;
    }
	free(result_a);
	free(result_b);
	free(result_c);
	return result;
    }
}
struct node23* merge_trees(struct node23* tree1, struct node23* tree2) {
    int result_size=0;
    struct node23** results;
    struct node23* big;
    struct node23* small;
    if (tree1->height>=tree2->height){
        big=tree1;
        small=tree2;
    }
    else {
        big=tree2;
        small=tree1;
    }
   results=recursive_merge_tree(big, small, &result_size);
   if (result_size<2){
        big = results[0];
        free(results);
        return big;
    }
    else {
       //Create a node ontop if necessary.
        big=create_node(VOID_DATA);
        big->left=results[0];
        big->middle=results[1];
        fix_node_values(big);
        free(results);
        return big;
    }
}

/*------------------------- print_tree ---------------------------------------------------------------------------------*/
void print_tree(struct node23 *current_node, int i)
{   
    int j;
    if (current_node==NULL) {
        printf("NULL SUBTREE\n");
        return;
    }
	if(current_node->left != NULL) {
		print_tree(current_node->left, i+1);
    }
	
    for (j=0;j<i;j++){
        printf("\t\t");
    }
    
    printf("[%d, %d] {%d} (%d) (?%d) %p", current_node->left_data,current_node->right_data, current_node->max, current_node->height,current_node->is_marked,current_node);
    printf("\n");
    
	if(current_node->middle != NULL){
		print_tree(current_node->middle, i+1);
    }
	if(current_node->right != NULL){
		print_tree(current_node->right, i+1);
    }
		
	return;	
}

/*-----------------------------Other----------------------------------------------------------*/
int compare_integers(const void *A, const void *B)
{
	return *(int*)A - *(int*)B;
}



/*---------------------------Parallel Functions-------------------------------------------------*/

	//Singled out and tested basic_parallel_for; no seg faults due to this alone
cilk void basic_parallel_for(int start, int end, int first, int insert, int last, struct node23** result, int *input_integers, cilk void (*function_ptr)(struct node23**,int*,int,int,int,int))
{
	int middle = start+(end-start)/2;
	if (end-start<=PARALLEL_CUTOFF) {
		for (start; start < end; ++start) {
            spawn function_ptr(result, input_integers, first,insert,last,start);
		}
    }
	else
	{		
		spawn basic_parallel_for(start,middle,first,insert,last,result, input_integers, function_ptr); 	//start -> middle-1
		spawn basic_parallel_for(middle+1,end,first,insert,last,result, input_integers, function_ptr); 	//middle+1 -> end-1
		spawn function_ptr(result, input_integers, first, insert, last, middle);						//middle
	}
	//return;				//Removing this didnt cause seg faults or anything
}

//Marks for deletion things that are in key array.
cilk void mark_for_delete(struct node23* root, int* keys, int start, int end){
     int middle = start+(end-start)/2;
     if (end-start<=PARALLEL_CUTOFF){
     	for (start; start<end; ++start){
	    spawn search_for_delete(root, keys[start]);
	}
     } 
     else {
     	  spawn mark_for_delete(root,keys,start,middle);
	  spawn mark_for_delete(root,keys,middle+1,end);
	  spawn search_for_delete(root, keys[middle]);
     }
}

	//When included along with the basic_parallel_for, seg faults occured occasionally
cilk void parallel_for_mark(struct node23* root, int* input_integers, struct node23** result_array, int start, int end)
{
    int middle = start+(end-start)/2;
	
    if (end-start<=PARALLEL_CUTOFF) {
        for (start; start <end; ++start)
		{
            result_array[start] = spawn callSearchAndMark(root, input_integers[start], 1);
        }
    }
    else
	{
        spawn parallel_for_mark(root, input_integers, result_array, start, middle);
        spawn parallel_for_mark(root, input_integers, result_array, middle + 1, end);
        result_array[middle] = spawn callSearchAndMark(root, input_integers[middle], 1);
    }
}

cilk void create_node_array(struct node23** result, int* input_integers, int first,int insert,int last, int index)
{
	result[index] = create_node(input_integers[index+first]);
}

cilk void create_node_array_2(struct node23** result, int* input_integers, int first,int insert,int last, int index)
{
	result[index] = create_node(input_integers[index+first-1]);
}


cilk void parallel_for_parent_creator(int start, int end, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a,struct node23** node_array_b,
										struct node23** node_array_c,cilk void (*function_ptr)(int, int, int, int, struct node23**, struct node23**, struct node23**, struct node23**))
{	//function_ptr(index,size_a,size_b,constant,result,node_array_a,...)
	int middle = start+(end-start)/2;
	if(end-start<=PARALLEL_CUTOFF)
		for(start;start<end;++start)
		{
			spawn function_ptr(start,size_a,size_b,constant,result,node_array_a,node_array_b,node_array_c);
		}
	else
	{
		spawn parallel_for_parent_creator(start, middle,size_a,size_b,constant,result,node_array_a,node_array_b,node_array_c, function_ptr);
		spawn parallel_for_parent_creator(middle+1,end, size_a,size_b,constant,result,node_array_a,node_array_b,node_array_c, function_ptr);
		spawn function_ptr(middle,size_a,size_b,constant,result,node_array_a,node_array_b,node_array_c);
	}
}

cilk void triplet_parent_creator(int i, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b, struct node23** node_array_c)
{
	struct node23** temp;
	
	if (i%3==0) {
		temp=&(result[i/3]->left);
	} else if (i%3==1){
		temp=&(result[i/3]->middle);
	}
	else {
		temp=&(result[i/3]->right);
	}
	
	if(i<size_a)							//Assign temp with pointer magic
	{
		*temp = node_array_a[i];
	}
	else if(i<size_a+size_b)
	{
		*temp = node_array_b[i-size_a];
	}
	else
	{
		*temp = node_array_c[i-size_a-size_b];
	}
	//return;					//Removing this did not cause any seg faults
}

cilk void pair_parent_creator(int pair_counter, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b, struct node23** node_array_c)
{
	struct node23** temp;
	
	if (pair_counter%2 == 0) {
		temp=&(result[constant/3 + pair_counter/2]->left);
	}
	else{
		temp=&(result[constant/3 + pair_counter/2]->middle);
	}

	if((constant+pair_counter)<size_a)		//Assign temp with pointer magic
	{
		*temp = node_array_a[constant+pair_counter];
	}
	else if((constant+pair_counter)<size_a+size_b)
	{
		*temp = node_array_b[(constant+pair_counter)-size_a];
	}
	else
	{
		*temp = node_array_c[(constant+pair_counter)-size_a-size_b];
	}
}
	

void fix_node_values(struct node23* node) { //Fixes the left_data,right_data, max, and height of each node
    node->left_data = node->left->max;
    node->height=node->left->height+1;
    if (node->right==NULL){
        node->max=node->middle->max;
        node->right_data=VOID_DATA;
        return;
    }
    else {
        node->max=node->right->max;
        node->right_data=node->middle->max;
    }
}
	
	
	
	
	
