#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#define VOID_DATA (int)-INFINITY
#define PARALLEL_CUTOFF 5


/* 2-3 Tree that supports parallel operations */
/* The insertion function will allow any amount of data to be inserted */
/* Tyler Romero and Kefu Lu */

/*-----------------------------Structs-----------------------------------------------------------------------------------------*/
struct node23
{
	int left_data, right_data;
	int max;
	struct node23 *left, *middle, *right;
	enum mark_status{unmarked, marked} is_marked;
};

struct tree23
{
	struct node23 *root;
};



/*-----------------------------Function Declarations----------------------------------------------------------------------------*/
	//Initialization Functions
struct node23* create_node(int node_data);									 					/*COMPLETE*/
struct tree23* create_tree(int node_data);

	//Special Search Functions
int binary_search_function(int (*function_ptr)(int, int, struct node23**, struct node23*), struct node23** node_array, int size, struct node23* target);	/*COMPLETE*/			/*Returns the array index of the thing that is searched for*/
int find_first(int index, int bound, struct node23** node_array, struct node23* target); 		/*COMPLETE*/
int find_last(int index, int bound, struct node23** node_array, struct node23* target); 		/*COMPLETE*/
int find_insert_index(int *input_array, int size, struct node23* target);

	//Batch Insert Function and helper functions
void complex_batch_insert(struct tree23* current_tree, int *input_integers, int size);
struct node23** recursive_split(struct node23* current_node, struct node23** search_array, int *input_integers, int size, int *return_size);
struct node23** create_and_link_parent_nodes(int size_a, int size_b, int size_c, struct node23 **node_array_a, struct node23 **node_array_b, struct node23 **node_array_c);

	//Print Tree
void print_tree(struct node23 *current_node, int i);




/*-----------------------------Create Node----------------------------------------------------------------------------------*/
struct node23* create_node(int node_data)	//Initializes a node with 'node_data' being 'left_data'
{
	struct node23* new_node = malloc(sizeof(struct node23));
	if(new_node == NULL)
	{
		printf("\nError allocating memory for new node");
		return new_node;
	}
	
	new_node->left_data = node_data;
	new_node->right_data = VOID_DATA;
	new_node->max = VOID_DATA;
	new_node->left = NULL;
	new_node->middle = NULL;
	new_node->right = NULL;
	new_node->is_marked = unmarked;
	return new_node;
}

struct tree23* create_tree(int node_data)
{
	struct tree23* new_tree = malloc(sizeof(struct tree23));
	if(new_tree == NULL)
	{
		printf("\nError allocating memory for new tree");
		return new_tree;
	}
	
	new_tree->root = create_node(node_data);
	return new_tree;
}


/*---------------------------Binary Search Function-----------------------------------------------------------------*/
int binary_search_function(int (*function_ptr)(int, int, struct node23**, struct node23*), struct node23** node_array, int size, struct node23* target)
{
	int left, right, middle;
	int search_result;
	left = 0;
	right = size;
	do{
		middle = (right-left)/2+left;
		search_result = function_ptr(middle, size, node_array, target);
		
		if (search_result == 1)
			return middle;
		else if(search_result == 0)
		{
			right = middle;
		}
		else left = middle+1;
		

	}while(right-left>0);
	return -1;
	/* ^^^^^^^Take care of case where nothing is found by search*/
}

int find_first(int index, int bound, struct node23** node_array, struct node23* target) 		//Returns 1 if correct index, returns 0 if index is to left, returns 2 if index is to right
{
	if(node_array[index] == target)
	{
		if(index == 0 || node_array[index-1] != target) return 1;
		else return 0;
	}
	if(node_array[index]->left_data < target->left_data)
	{
		return 2;
	}
	else return 0;
}

int find_last(int index, int bound, struct node23** node_array, struct node23* target) 		//Returns 1 if correct index, returns 0 if index is to left, returns 2 if index is to right
{
	if(node_array[index] == target)
	{
		if(index == bound-1 || node_array[index+1] != target) return 1;		//The only difference between find_first and find_last is the change in this line
		else return 2;
	}
	if(node_array[index]->left_data < target->left_data)
	{
		return 2;
	}
	else return 0;
}

int find_insert_index(int *input_array, int size, struct node23* target)
{
	int left, right, middle;
	left = 0;
	right = size;
	
	do{
		middle = (right-left)/2+left;

		printf("middle: %d\n", middle);
		
		if (target->left_data < input_array[middle])
			right = middle;
		else if(target->left_data >= input_array[middle])
		{
			left = middle;
		}else left = middle;
		
		if(right-left==1)
		{
			printf("right: %d\n", right);
			return right;
		}
	
	}while(right-left>0);
	return -1;
	/* ^^^^^^^Take care of case where nothing is found by search*/	
}


/*----------------------------Search and Mark---------------------------------------------------------------*/
struct node23* searchAndMark(struct node23* current_node, int key, int mark)
{
    current_node->is_marked=mark;
	if(current_node->left == NULL)
	{
		return current_node;
	}
	else{
		if(key <= current_node->left_data)
			return searchAndMark(current_node->left, key, mark);
		else if(current_node->right_data == VOID_DATA)
			return searchAndMark(current_node->middle, key, mark);
		else if(key <= current_node->right_data)
			return searchAndMark(current_node->middle, key, mark);
		else if(key > current_node->right_data)
			return searchAndMark(current_node->right, key, mark);
		else return NULL; 								/*Hypothetically should never happen*/
	}
}

/*----------------------------complex_batch_insert-------------------------------------------------------*/
void complex_batch_insert(struct tree23* current_tree, int *input_integers, int size) /*Takes in a pointer to a tree, an array of keys to insert, and the size of that array*/
{
	int i;
	struct node23 **result_array = calloc(size, sizeof(struct node23*));
	struct node23 **result;
	int number_of_children=0;

	for(i=0; i<size; ++i)
	{
		result_array[i] = searchAndMark(current_tree->root, input_integers[i], 1);
	}

    result = recursive_split(current_tree->root, result_array, input_integers, size, &number_of_children);
	
	//fix root - to group the array of nodes returned
	if(number_of_children == 0)
		printf("There is a problem with the number_of_children variable");
		
	while(number_of_children>1)
	{
		result = create_and_link_parent_nodes(number_of_children, 0, 0, result, NULL, NULL);
		
		if(number_of_children%3==0)	//Return the size of the result array
			number_of_children = number_of_children/3;
		else
			number_of_children = (number_of_children/3)+1;
	}
	
	current_tree->root = *result;
	
	free(result_array);
	free(result);
}

struct node23** recursive_split(struct node23* current_node, struct node23** search_array, int *input_integers, int size, int *return_size) //Edits result, but returns the size of result
{
	//struct node23 **result; /*The array of parent nodes that we will return*/
	int first, insert, last;
	int size_a, size_b, size_c;
	struct node23 **node_array_a, **node_array_b, **node_array_c; //a, b, and c refer to the left, middle, or right parts of the parent node
	int i;
	struct node23 **result;
	
	if(current_node==NULL)	/*If current_node doesnt exist return NULL*/
	{
		*return_size = 0;
		return NULL;
	}
	else if(current_node->is_marked == unmarked) //If current_node is not marked, return size 1 and the current node
	{
		*return_size = 1;
		result = malloc(sizeof(struct node23*));
		*result = current_node;
		return result;
	}
	else if(current_node->left == NULL)									/*If current_node IS a leaf ----> generate a sub-array of nodes that correspond to that leaf; return that node array*/
	{
		first = binary_search_function(find_first, search_array, size, current_node);
		last = binary_search_function(find_last, search_array, size, current_node);
		printf("current_node->left_data: %d\n", current_node->left_data);
		insert = find_insert_index(input_integers, size, current_node);
		
		printf("first: %d, last: %d, insert: %d\n", first, last, insert);
		
		result = calloc(2+last-first, sizeof(struct node23*)); /*Allocate a sub-array for each of the leafs*/
		
		if(insert > last) /*Fill the sub-arrays using the integer inputs - Normal case*/
		{
			for(i = 0; i < 1+last-first; ++i) 											//PARALLEL FOR
			{
				result[i] = create_node(input_integers[i+first]);
			}
			result[1+last-first] = current_node;
		}
		else			 /*Exception - the node does not go on the end of the sub-array*/
		{
			for(i=0; i<insert-first; ++i) //Fills up the sub-array before the node			//PARALLEL FOR
				result[i] = create_node(input_integers[i+first]);
			result[insert-first] = current_node; //Inserts the node
			for(i=insert-first+1; i<1+last-first; ++i) //Fills up the sub-array after the node*/		//PARALLEL FOR
				result[i] = create_node(input_integers[i+first-1]);
		}
		*return_size = 2+last-first;
		return result;
	}
	else															/*If current_node is NOT a leaf ----> call recursive split and generate new nodes?*/
	{
		node_array_a = recursive_split(current_node->left, search_array, input_integers, size, &size_a);
		node_array_b = recursive_split(current_node->middle, search_array, input_integers, size, &size_b);
		node_array_c = recursive_split(current_node->right, search_array, input_integers, size, &size_c);
	}

	if((size_a+size_b+size_c)%3==0)	//Return the size of the result array
		*return_size = (size_a+size_b+size_c)/3;
	else
		*return_size = (size_a+size_b+size_c)/3+1;
		
	
	result = create_and_link_parent_nodes(size_a, size_b, size_c, node_array_a, node_array_b, node_array_c);
	
	free(node_array_a);
	free(node_array_b);
	free(node_array_c);
	
	return result;
}

struct node23** create_and_link_parent_nodes(int size_a, int size_b, int size_c, struct node23 **node_array_a, struct node23 **node_array_b, struct node23 **node_array_c) /*Regroup the node_arrays, and create new parent nodes as needed*/
{
	int size_total = size_a+size_b+size_c;
	int i;
	int pair_counter;
	int triplet_counter;
	struct node23** result;
	struct node23** temp;
	
	printf("size_total: %d\n", size_total);
	
	if(size_total%3 == 0) //<-------------------------If size is a multiple of 3
	{
		*result = calloc(size_total/3, sizeof(struct node23*)); /*Allocate a sub-array for each of the leafs*/
		for(i=0; i<size_total/3; ++i)
		{
			result[i] = create_node(VOID_DATA);		//Parent nodes
		}
		for(i=0; i<size_total; ++i)		//Creating the parent nodes for the groups of three children
		{
			if (i%3==0) {
				temp=&(result[i/3]->left);
			} else if (i%3==1){
				temp=&(result[i/3]->middle);
			}
			else {
				temp=&(result[i/3]->right);
			}
			
			if(i<size_a)							//Assign temp with pointer magic
			{
				*temp = node_array_a[i];
			}
			else if(i<size_a+size_b)
			{
				*temp = node_array_b[i-size_a];
			}
			else
			{
				*temp = node_array_c[i-size_a-size_b];
			}
		}
	}
	else		//If size_total is not a multiple of three
	{
		result = calloc((size_total/3)+1, sizeof(struct node23*)); /*Allocate a sub-array that will be the parent nodes*/
		if(result == NULL)
		{
			printf("Failure Allocating Memory");
		}
		
		for(i=0; i<(size_total/3)+1; ++i)
		{
			result[i] = create_node(VOID_DATA);		//Create the parent nodes
		}
		
		if(size_total%3 == 1)
			triplet_counter = size_total-4;		//<---two pairs of two leafs will be added to the end (After this next for loop)
		else
			triplet_counter = size_total-2;		//<---one pair of two leafs will be added to the end (After this next for loop)
		
		for(i=0; i<triplet_counter; ++i)		//Linking the parent nodes for the groups of three children
		{
			if (i%3==0) 
			{
				temp = &(result[i/3]->left);
			}
			else if (i%3==1)
			{
				temp = &(result[i/3]->middle);
			}
			else
			{
				temp = &(result[i/3]->right);
			}
			
			if(i<size_a)							//Assign temp with pointer magic
			{
				*temp = node_array_a[i];

			}
			else if(i<size_a+size_b)
			{
				*temp = node_array_b[i-size_a];
			}
			else
			{
				*temp = node_array_c[i-size_a-size_b];
			}
		}
		
		for(pair_counter = 0; (pair_counter + i) < size_total; ++pair_counter)	//Linking the parent nodes for the groups of two children
		{
			if (pair_counter%2 == 0) 
			{
				temp=&(result[(i+1)/3 + pair_counter/2]->left);
			}
			else
			{
				temp=&(result[(i+1)/3 + pair_counter/2]->middle);
			}

			if(i<size_a)		//Assign temp with pointer magic
			{
				*temp = node_array_a[i+pair_counter];
			}
			else if(i<size_a+size_b)
			{
				*temp = node_array_b[(i+pair_counter)-size_a];
			}
			else
			{
				*temp = node_array_c[(i+pair_counter)-size_a-size_b];
			}
		}
	}
	return result;
}

/*------------------------- print_tree ---------------------------------------------------------------------------------*/
void print_tree(struct node23 *current_node, int i)
{   
    int j;
    if (current_node==NULL) {
        printf("NULL SUBTREE\n");
        return;
    }
	if(current_node->left != NULL) {
		print_tree(current_node->left, i+1);
    }
	
    for (j=0;j<i;j++){
        printf("\t\t");
    }
    printf("[%d, %d] {%d} ", current_node->left_data,current_node->right_data, current_node->max);
	printf("\n");
    
	if(current_node->middle != NULL){
		print_tree(current_node->middle, i+1);
    }
	if(current_node->right != NULL){
		print_tree(current_node->right, i+1);
    }
		
	return;	
}




