#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#define VOID_DATA (int)-INFINITY
#define PARALLEL_CUTOFF 2


/* 2-3 Tree that supports parallel operations */
/* The insertion function will allow any amount of data to be inserted */
/* Tyler Romero and Kefu Lu */

//To do: add the batchify function
//To do: the 'delete' function



/*-----------------------------Structs-----------------------------------------------------------------------------------------*/
struct node23
{
	int left_data, right_data;
	int max;
	struct node23 *left, *middle, *right;
	enum mark_status{unmarked, marked} is_marked;
};

struct tree23
{
	struct node23 *root;
};



/*-----------------------------Function Declarations----------------------------------------------------------------------------*/
	//Initialization Functions
struct node23* create_node(int node_data);	/*COMPLETE*/
struct tree23* create_tree(int node_data);	/*COMPLETE*/

	//Delete Tree
void delete_tree_helper(struct node23 *dead_node);	/*COMPLETE*/
void delete_tree(struct tree23 *dead_tree);			/*COMPLETE*/

	//Special Search Functions
int binary_search_function(int (*function_ptr)(int, int, struct node23**, struct node23*), struct node23** node_array, int size, struct node23* target);	/*COMPLETE*/			/*Returns the array index of the thing that is searched for*/
int find_first(int index, int bound, struct node23** node_array, struct node23* target); 		/*COMPLETE*/
int find_last(int index, int bound, struct node23** node_array, struct node23* target); 		/*COMPLETE*/
int find_insert_index(int *input_array, int size, struct node23* target);						/*COMPLETE*/

	//Search and Mark
struct node23* searchAndMark(struct node23* current_node, int key, int mark);	
cilk struct node23* callSearchAndMark(struct node23* root, int key, int mark);
	
	//Batch Insert Function and helper functions
cilk void complex_batch_insert(struct tree23* current_tree, int *input_integers, int size);
cilk struct node23** recursive_split(struct node23* current_node, struct node23** search_array, int *input_integers, int size, int *return_size);
cilk struct node23** create_and_link_parent_nodes(int size_a, int size_b, int size_c, struct node23 **node_array_a, struct node23 **node_array_b, struct node23 **node_array_c);

	//Print Tree
void print_tree(struct node23 *current_node, int i);	/*COMPLETE*/

	//Other
int compare_integers(const void *A, const void *B);		/*COMPLETE*/

	//Parallel Functions
cilk void basic_parallel_for(int start, int end, int first, int insert, int last, struct node23** result, int *input_integers, cilk void (*function_ptr)(struct node23**,int*,int,int,int,int));
cilk void parallel_for_mark(struct node23* root, int* input_integers, struct node23** result_array, int start, int end);
cilk void create_node_array(struct node23** result, int* input_integers, int first, int insert, int last, int index);
cilk void create_node_array_2(struct node23** result, int* input_integers, int first, int insert, int last, int index);
cilk void parallel_for_parent_creator(int start, int end, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b,
										struct node23** node_array_c, cilk void (*function_ptr)(int, int, int, int, struct node23**, struct node23**, struct node23**, struct node23**));
cilk void triplet_parent_creator(int i, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b, struct node23** node_array_c);
cilk void pair_parent_creator(int pair_counter, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b, struct node23** node_array_c);




/*-----------------------------Create Node----------------------------------------------------------------------------------*/
struct node23* create_node(int node_data)	//Initializes a node with 'node_data' being 'left_data'
{
	struct node23* new_node = malloc(sizeof(struct node23));
	if(new_node == NULL)
	{
		printf("\nError allocating memory for new node");
		return new_node;
	}
	
	new_node->left_data = node_data;
	new_node->right_data = VOID_DATA;
	new_node->max = node_data;
	new_node->left = NULL;
	new_node->middle = NULL;
	new_node->right = NULL;
	new_node->is_marked = unmarked;
	return new_node;
}

struct tree23* create_tree(int node_data)
{
	struct tree23* new_tree = malloc(sizeof(struct tree23));
	if(new_tree == NULL)
	{
		printf("\nError allocating memory for new tree");
		return new_tree;
	}
	
	new_tree->root = create_node(node_data);
	return new_tree;
}


/*----------------------------delete_tree-----------------------------------------------------------------*/
void delete_tree_helper(struct node23 *dead_node)
{
	if(dead_node->left != NULL)
		delete_tree_helper(dead_node->left);
	if(dead_node->middle != NULL)
		delete_tree_helper(dead_node->middle);
	if(dead_node->right != NULL)
		delete_tree_helper(dead_node->right);

	free(dead_node);
	return;	
}

void delete_tree(struct tree23 *dead_tree)
{
	delete_tree_helper(dead_tree->root);
	free(dead_tree);
}



/*---------------------------Binary Search Function-----------------------------------------------------------------*/
int binary_search_function(int (*function_ptr)(int, int, struct node23**, struct node23*), struct node23** node_array, int size, struct node23* target)
{
	int left, right, middle;
	int search_result;
	left = 0;
	right = size;
	do{
		middle = (right-left)/2+left;
		search_result = function_ptr(middle, size, node_array, target);
		
		if (search_result == 1)
			return middle;
		else if(search_result == 0)
		{
			right = middle;
		}
		else left = middle+1;
		

	}while(right-left>0);
	return -1;
	/* ^^^^^^^Take care of case where nothing is found by search*/
}

int find_first(int index, int bound, struct node23** node_array, struct node23* target) 		//Returns 1 if correct index, returns 0 if index is to left, returns 2 if index is to right
{
	if(node_array[index] == target)
	{
		if(index == 0 || node_array[index-1] != target) return 1;
		else return 0;
	}
	if(node_array[index]->left_data < target->left_data)
	{
		return 2;
	}
	else return 0;
}

int find_last(int index, int bound, struct node23** node_array, struct node23* target) 		//Returns 1 if correct index, returns 0 if index is to left, returns 2 if index is to right
{
	if(node_array[index] == target)
	{
		if(index == bound-1 || node_array[index+1] != target) return 1;		//The only difference between find_first and find_last is the change in this line
		else return 2;
	}
	if(node_array[index]->left_data < target->left_data)
	{
		return 2;
	}
	else return 0;
}

int find_insert_index(int *input_array, int size, struct node23* target)
{
	int left, right, middle;
	left = 0;
	right = size;
	while(right-left!=0)
    {
		middle = (right-left)/2+left;
        if (target->left_data >= input_array[middle]){
            if (middle+1==right || input_array[middle+1]>target->left_data){
                return middle+1;
            }
            else {
                left=middle;
            }
        }
        else {
            if (middle==left) {
                return middle;
            }
            else {
                right=middle;
            }
        }
    }
    return -5;
}


/*----------------------------Search and Mark---------------------------------------------------------------*/
struct node23* searchAndMark(struct node23* current_node, int key, int mark)
{
    current_node->is_marked=mark;
	if(current_node->left == NULL)
	{
		return current_node;
	}
	else{
		if(key <= current_node->left_data)
			return searchAndMark(current_node->left, key, mark);
		else if(current_node->right_data == VOID_DATA)
			return searchAndMark(current_node->middle, key, mark);
		else if(key <= current_node->right_data)
			return searchAndMark(current_node->middle, key, mark);
		else if(key > current_node->right_data)
			return searchAndMark(current_node->right, key, mark);
		else return NULL; 								/*Hypothetically should never happen*/
	}
}

cilk struct node23* callSearchAndMark(struct node23* root, int key, int mark)
{
	return searchAndMark(root,key,mark);
}


/*----------------------------complex_batch_insert-------------------------------------------------------*/
cilk void complex_batch_insert(struct tree23* current_tree, int *input_integers, int size) /*Takes in a pointer to a tree, an array of keys to insert, and the size of that array*/
{
	struct node23 **result_array = calloc(size, sizeof(struct node23*));
	struct node23 **result;
	int number_of_children=0;
	int i;

	qsort((void*)input_integers, size, sizeof(int), compare_integers);
	
	/*for(i=0; i<size; ++i)	
	{
		result_array[i] = searchAndMark(current_tree->root, input_integers[i], 1);
	}*/
	
	spawn parallel_for_mark(current_tree->root, input_integers, result_array, 0, size); //Should sync on its own at the end of the function
	sync;
	
    result = spawn recursive_split(current_tree->root, result_array, input_integers, size, &number_of_children);
	sync;
	
	//fix root - to group the array of nodes returned
	if(number_of_children == 0)
		printf("There is a problem with the number_of_children variable");
		
	while(number_of_children>1)
	{
		result = spawn create_and_link_parent_nodes(number_of_children, 0, 0, result, NULL, NULL);
		sync;
		if(number_of_children%3==0)	//Return the size of the result array
			number_of_children = number_of_children/3;
		else
			number_of_children = (number_of_children/3)+1;
	}
	
	current_tree->root = *result;
	
	free(result_array);
	free(result);
}

cilk struct node23** recursive_split(struct node23* current_node, struct node23** search_array, int *input_integers, int size, int *return_size) //Edits return_size to be the size of the return array
{
	int first, insert, last;
	int size_a, size_b, size_c;
	struct node23 **node_array_a, **node_array_b, **node_array_c; //a, b, and c refer to the left, middle, or right parts of the parent node
	struct node23 **result;
	
	if(current_node==NULL)	/*If current_node doesnt exist return NULL*/
	{
		*return_size = 0;
		return NULL;
	}
	else if(current_node->is_marked == unmarked) //If current_node is not marked, return size 1 and the current node
	{
		*return_size = 1;
		result = malloc(sizeof(struct node23*));
		*result = current_node;
		return result;
	}
	else if(current_node->left == NULL)									/*If current_node IS a leaf ----> generate a sub-array of nodes that correspond to that leaf; return that node array*/
	{
        first = binary_search_function(find_first, search_array, size, current_node);
		last = binary_search_function(find_last, search_array, size, current_node);
		printf("current_node->left_data: %d\n", current_node->left_data);
		insert = find_insert_index(input_integers, size, current_node);
		
		printf("first: %d, last: %d, insert: %d\n", first, last, insert);
		
		result = calloc(2+last-first, sizeof(struct node23*)); /*Allocate a sub-array for each of the leafs*/
		
		if(insert > last) /*Fill the sub-arrays using the integer inputs - Normal case*/
		{
			/*for(i = 0; i < 1+last-first; ++i)
			{
				result[i] = create_node(input_integers[i+first]);
			}*/
			
			spawn basic_parallel_for(0, 1+last-first, first, insert, last, result, input_integers, create_node_array);
			sync;
			result[1+last-first] = current_node;
		}
		else			 /*Exception - the node does not go on the end of the sub-array*/
		{
			/*for(i=0; i<insert-first; ++i) //Fills up the sub-array before the node
				result[i] = create_node(input_integers[i+first]);*/
			spawn basic_parallel_for(0, insert-first, first, insert, last, result, input_integers, create_node_array);
			result[insert-first] = current_node; //Inserts the node
			/*for(i=insert-first+1; i<2+last-first; ++i) //Fills up the sub-array after the node		//PARALLEL FOR
				result[i] = create_node(input_integers[i+first-1]);*/
			spawn basic_parallel_for(insert-first+1, 2+last-first, first, insert, last, result, input_integers, create_node_array_2);
			sync;
		}
		*return_size = 2+last-first;
        current_node->is_marked=unmarked;
		return result;
	}
	else															/*If current_node is NOT a leaf ----> call recursive split and generate new nodes?*/
	{
		node_array_a = spawn recursive_split(current_node->left, search_array, input_integers, size, &size_a);
		node_array_b = spawn recursive_split(current_node->middle, search_array, input_integers, size, &size_b);
		node_array_c = spawn recursive_split(current_node->right, search_array, input_integers, size, &size_c);
		sync;
		printf("Test post-recursive split\n");
	}

	if((size_a+size_b+size_c)%3==0)	//Return the size of the result array
		*return_size = (size_a+size_b+size_c)/3;
	else
		*return_size = (size_a+size_b+size_c)/3+1;


	result = spawn create_and_link_parent_nodes(size_a, size_b, size_c, node_array_a, node_array_b, node_array_c);
	sync;
	
	free(node_array_a);
	free(node_array_b);
	free(node_array_c);
	free(current_node);
    
	return result;
}

cilk struct node23** create_and_link_parent_nodes(int size_a, int size_b, int size_c, struct node23 **node_array_a, struct node23 **node_array_b, struct node23 **node_array_c) /*Regroup the node_arrays, and create new parent nodes as needed*/
{
	int size_total = size_a+size_b+size_c;
	int i;
	int triplet_counter, pair_counter;
	struct node23** result;
	struct node23** temp;
	
	printf("size_total: %d\n", size_total);
    printf("from sizes: {%d,%d,%d}\n",size_a,size_b,size_c);
	
	if(size_total%3 == 0) //<-------------------------If size is a multiple of 3
	{
		printf("multiple of 3\n");
		result = calloc(size_total/3, sizeof(struct node23*)); /*Allocate a sub-array for each of the leafs*/
		for(i=0; i<size_total/3; ++i)
		{
			result[i] = create_node(VOID_DATA);		//Parent nodes
		}
		/*for(i=0; i<size_total; ++i)		//Creating the parent nodes for the groups of three children
		{
			if (i%3==0) {
				temp=&(result[i/3]->left);
			} else if (i%3==1){
				temp=&(result[i/3]->middle);
			}
			else {
				temp=&(result[i/3]->right);
			}
			
			if(i<size_a)							//Assign temp with pointer magic
			{
				*temp = node_array_a[i];
			}
			else if(i<size_a+size_b)
			{
				*temp = node_array_b[i-size_a];
			}
			else
			{
				*temp = node_array_c[i-size_a-size_b];
			}
		}*/
		
		//Creating the parent nodes for the groups of three children
		spawn parallel_for_parent_creator(0, size_total, size_a, size_b, 0, result, node_array_a, node_array_b, node_array_c, triplet_parent_creator); //This did not give seg faults when isolated
		sync;
       
	   for (i=0;i<size_total/3;++i)
		{
            result[i]->max = result[i]->right->max;
            result[i]->left_data=result[i]->left->max;
            result[i]->right_data=result[i]->middle->max;
        }
	}
	else		//If size_total is not a multiple of three
	{     
		printf("NOT a multiple of 3\n");
		result = calloc((size_total/3)+1, sizeof(struct node23*)); /*Allocate a sub-array that will be the parent nodes*/
		if(result == NULL)
		{
			printf("Failure Allocating Memory");
		}
		
		for(i=0; i<(size_total/3)+1; ++i)
		{
			result[i] = create_node(VOID_DATA);		//Create the parent nodes
		}
		
		if(size_total%3 == 1)
			triplet_counter = size_total-4;		//<---two pairs of two leafs will be added to the end (After this next for loop)
		else
			triplet_counter = size_total-2;		//<---one pair of two leafs will be added to the end (After this next for loop)
		
		printf("triplet_counter: %d\n", triplet_counter);
		
		/*for(i=0; i<triplet_counter; ++i)		//Linking the parent nodes for the groups of three children
		{
			if (i%3==0) 
			{
				temp = &(result[i/3]->left);
			}
			else if (i%3==1)
			{
				temp = &(result[i/3]->middle);
			}
			else
			{
				temp = &(result[i/3]->right);
			}
			
			if(i<size_a)						//Assign temp with pointer magic
			{
				*temp = node_array_a[i];

			}
			else if(i<size_a+size_b)
			{
				*temp = node_array_b[i-size_a];
			}
			else
			{
				*temp = node_array_c[i-size_a-size_b];
			}
		}*/
		
		//Creating the parent nodes for the groups of three children
		spawn parallel_for_parent_creator(0, triplet_counter, size_a, size_b, 0, result, node_array_a, node_array_b, node_array_c, triplet_parent_creator);		//The cause of one of the seg faults
		sync;
		
		/*for(pair_counter = 0; (pair_counter + i) < size_total; ++pair_counter)	//Linking the parent nodes for the groups of two children
		{
			if (pair_counter%2 == 0) 
			{
				temp=&(result[i/3 + pair_counter/2]->left);
			}
			else
			{
				temp=&(result[i/3 + pair_counter/2]->middle);
			}

			if((i+pair_counter)<size_a)		//Assign temp with pointer magic
			{
				*temp = node_array_a[i+pair_counter];
			}
			else if((i+pair_counter)<size_a+size_b)
			{
				*temp = node_array_b[(i+pair_counter)-size_a];
			}
			else
			{
				*temp = node_array_c[(i+pair_counter)-size_a-size_b];
			}
		}*/
		
		//Creating the parent nodes for the groups of three children
		spawn parallel_for_parent_creator(0, size_total-triplet_counter, size_a, size_b, triplet_counter, result, node_array_a, node_array_b, node_array_c, pair_parent_creator); //No seg fault when isolated
        sync;
		
		for (i=0;i<(size_total/3)+1;i++){	//sets the max data field for every new node
            //printf("TEST10\n");
            if (result[i]->right==NULL){
                //printf("Just before middle is dereferenced: i is %d: {%d,%d}\n",i, result[i]->left,result[i]->middle);
                result[i]->max = result[i]->middle->max;								//Seg fault where middle is NULL, and it is dereferenced here, starts occuring when line 434 is added
                result[i]->left_data=result[i]->left->max;
            }
            else {
                //printf("i is %d: {%d,%d, %d}\n",i, result[i]->left,result[i]->middle, result[i]->right);
                result[i]->max = result[i]->right->max;
                result[i]->left_data=result[i]->left->max;
                result[i]->right_data=result[i]->middle->max;
            }
            //printf("TEST11\n");
        }
	}
	return result;
}

/*------------------------- print_tree ---------------------------------------------------------------------------------*/
void print_tree(struct node23 *current_node, int i)
{   
    int j;
    if (current_node==NULL) {
        printf("NULL SUBTREE\n");
        return;
    }
	if(current_node->left != NULL) {
		print_tree(current_node->left, i+1);
    }
	
    for (j=0;j<i;j++){
        printf("\t\t");
    }
    printf("[%d, %d] {%d} ", current_node->left_data,current_node->right_data, current_node->max);
	printf("\n");
    
	if(current_node->middle != NULL){
		print_tree(current_node->middle, i+1);
    }
	if(current_node->right != NULL){
		print_tree(current_node->right, i+1);
    }
		
	return;	
}

/*-----------------------------Other----------------------------------------------------------*/
int compare_integers(const void *A, const void *B)
{
	return *(int*)A - *(int*)B;
}



/*---------------------------Parallel Functions-------------------------------------------------*/

	//Singled out and tested basic_parallel_for; no seg faults due to this alone
cilk void basic_parallel_for(int start, int end, int first, int insert, int last, struct node23** result, int *input_integers, cilk void (*function_ptr)(struct node23**,int*,int,int,int,int))
{
	int middle = start+(end-start)/2;
	if (end-start<=PARALLEL_CUTOFF) {
		for (start; start < end; ++start) {
            spawn function_ptr(result, input_integers, first,insert,last,start);
		}
    }
	else
	{		
		spawn basic_parallel_for(start,middle,first,insert,last,result, input_integers, function_ptr); 	//start -> middle-1
		spawn basic_parallel_for(middle+1,end,first,insert,last,result, input_integers, function_ptr); 	//middle+1 -> end-1
		spawn function_ptr(result, input_integers, first, insert, last, middle);						//middle
	}
	//return;				//Removing this didnt cause seg faults or anything
}

	//When included along with the basic_parallel_for, seg faults occured occasionally
cilk void parallel_for_mark(struct node23* root, int* input_integers, struct node23** result_array, int start, int end)
{
    int middle = start+(end-start)/2;
	
    if (end-start<=PARALLEL_CUTOFF) {
        for (start; start <end; ++start)
		{
            result_array[start] = spawn callSearchAndMark(root, input_integers[start], 1);
        }
    }
    else
	{
        spawn parallel_for_mark(root, input_integers, result_array, start, middle);
        spawn parallel_for_mark(root, input_integers, result_array, middle + 1, end);
        result_array[middle] = spawn callSearchAndMark(root, input_integers[middle], 1);
    }
	//sync;			//I think this is unneccissary
}

cilk void create_node_array(struct node23** result, int* input_integers, int first,int insert,int last, int index)
{
	result[index] = create_node(input_integers[index+first]);
}

cilk void create_node_array_2(struct node23** result, int* input_integers, int first,int insert,int last, int index)
{
	result[index] = create_node(input_integers[index+first-1]);
}


cilk void parallel_for_parent_creator(int start, int end, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a,struct node23** node_array_b,
										struct node23** node_array_c,cilk void (*function_ptr)(int, int, int, int, struct node23**, struct node23**, struct node23**, struct node23**))
{	//function_ptr(index,size_a,size_b,constant,result,node_array_a,...)
	int middle = start+(end-start)/2;
	if(end-start<=PARALLEL_CUTOFF)
		for(start;start<end;++start)
		{
			spawn function_ptr(start,size_a,size_b,constant,result,node_array_a,node_array_b,node_array_c);
		}
	else
	{
		spawn parallel_for_parent_creator(start, middle,size_a,size_b,constant,result,node_array_a,node_array_b,node_array_c, function_ptr);
		spawn parallel_for_parent_creator(middle+1,end, size_a,size_b,constant,result,node_array_a,node_array_b,node_array_c, function_ptr);
		spawn function_ptr(middle,size_a,size_b,constant,result,node_array_a,node_array_b,node_array_c);
	}
	//return;					//removing this did not cause any seg faults
}

cilk void triplet_parent_creator(int i, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b, struct node23** node_array_c)
{
	struct node23** temp;
	
	if (i%3==0) {
		temp=&(result[i/3]->left);
	} else if (i%3==1){
		temp=&(result[i/3]->middle);
	}
	else {
		temp=&(result[i/3]->right);
	}
	
	if(i<size_a)							//Assign temp with pointer magic
	{
		*temp = node_array_a[i];
	}
	else if(i<size_a+size_b)
	{
		*temp = node_array_b[i-size_a];
	}
	else
	{
		*temp = node_array_c[i-size_a-size_b];
	}
	//return;					//Removing this did not cause any seg faults
}

cilk void pair_parent_creator(int pair_counter, int size_a, int size_b, int constant, struct node23** result, struct node23** node_array_a, struct node23** node_array_b, struct node23** node_array_c)
{
	struct node23** temp;
	
	if (pair_counter%2 == 0) {
		temp=&(result[constant/3 + pair_counter/2]->left);
	}
	else{
		temp=&(result[constant/3 + pair_counter/2]->middle);
	}

	if((constant+pair_counter)<size_a)		//Assign temp with pointer magic
	{
		*temp = node_array_a[constant+pair_counter];
	}
	else if((constant+pair_counter)<size_a+size_b)
	{
		*temp = node_array_b[(constant+pair_counter)-size_a];
	}
	else
	{
		*temp = node_array_c[(constant+pair_counter)-size_a-size_b];
	}
	//return;
}
	
	
	
	
	
	
	
