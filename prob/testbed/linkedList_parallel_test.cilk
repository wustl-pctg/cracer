#include "ds/linkedList.cilkh"

#include <cilk-lib.cilkh>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>


#define NUM_INSERTS 3

void printList(LinkedList * list) {
	Node * n;

	n = list->head;
	printf("Head->");
	while (n != NULL){
	printf("%s->", n->name);	
	n = n->next;
	}
	
	printf("Tail\n");
}


cilk int main(int argc, char **argv)

{
	InsertRecord ** irArray = (InsertRecord **)malloc(NUM_INSERTS * sizeof(InsertRecord));
	InsertRecord * tmpIR1 = malloc(sizeof(InsertRecord));
	InsertRecord * tmpIR2 = malloc(sizeof(InsertRecord));
	InsertRecord * tmpIR3 = malloc(sizeof(InsertRecord));
	LinkedList * list;
	Node * n, *n2, *n3, *n4;
	int x = 0;
	
	n = malloc(sizeof(Node));
	n2 = malloc(sizeof(Node));
	n3 = malloc(sizeof(Node));
	n4 = malloc(sizeof(Node));
	
	n->name  = "n1";
	n2->name = "n2";
	n3->name = "n3";
	n4->name = "n4";
	
	list =createLinkedList();

	//empty
	printList(list);	
	spawn appendNode(list, n);	
	sync;

	//

	irArray[0] = tmpIR1;
	irArray[1] = tmpIR2;
	irArray[2] = tmpIR3;
	
	(irArray[0])->x = n;
	(irArray[0])->y = n2;
	(irArray[1])->x = n;
	(irArray[1])->y = n3;
	(irArray[2])->x = n;
	(irArray[2])->y = n4;

	
		spawn batchInsertSeq(list, n, n2);
		spawn batchInsertSeq(list, n, n3);
		spawn batchInsertSeq(list, n, n4);
		//spawn insertPar(list, irArray, 3, NULL);
	
	//spawn atomicInsert(list, irArray[0]);
	//spawn atomicInsert(list, irArray[2]);
	//spawn atomicInsert(list, irArray[1]);
	
	x += spawn order(list, n3, n4);
	//
	
	sync;	
	printList(list);
	
(x)?printf("n3 before n4\n"):printf("n3 not before n4\n");

	cleanUp(list);
	free(irArray);
	//tmpIR freed
  	return 0;
}
