#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <cilk-lib.cilkh>
#include <time.h>

#include "util/parfor.cilkh"
#include "util/prefixSums.cilkh"
#include "util/timer.h"

#define MAX_NUM 100
Cilk_lockvar lock_counter;
int counter = 0;

/* extern void Cilk_batchify(CilkWorkerState *const ws, */
/* 			  CilkBatchOpInternal op, */
/* 			  void *dataStruct, void *data, size_t dataSize, void *indvResult); */
extern void Cilk_terminate_batch(CilkWorkerState *const ws);

cilk void fastSum(void *dataStruct, void *data, size_t size, void *result)	//batch_op
{
	int *nums = (int*)data;
  int temp = nums[size-1];
  int *count = (int*)dataStruct;

  spawn prefixSumsExc(nums, size, nums);
  sync;

  result = data;
  *count += temp + nums[size-1];
  Cilk_terminate_batch(_cilk_ws);
  return;
}

cilk void batchIncrement(int i, void* nums)	//calls batch_op
{
  Cilk_batchify(_cilk_ws, fastSum, &counter, &((int*)nums)[i], sizeof(int), NULL);
}

cilk void parallelIncrement(int *nums, size_t size)	//Parallel for to call the call to batch_op
{
  spawn parforpar_1(0, size-1, batchIncrement, (void*)nums);
  sync;
} 

void lockIncrement(int i, void* nums)
{
  Cilk_lock(lock_counter);
  counter += ((int*)nums)[i];
  Cilk_unlock(lock_counter);
}

cilk void concurrentIncrement(int *nums, size_t size)
{
  spawn parfor_1(0, size-1, lockIncrement, (void*)nums);
  sync;
}

void sequentialIncrement(int *nums, size_t size)
{
  int i;
  for (i = 0; i < size; i++) {
    counter += nums[i];
  }
}

cilk int main(int argc, char *argv[])
{
  int *data;
  int nNums = 5;
  int i, sum;
	
  if (argc > 2) {
    fprintf(stderr, "Too many arguments\n");
    Cilk_exit(1);
  } else if (argc == 2) {
    nNums = atoi(argv[1]);
  }

  data = malloc(nNums*sizeof(int));

  srand(time(NULL));
	//	printf("Original sequence: ");
  for (i = 0; i < nNums; i++) {
    // want -MAX_NUM to MAX_NUM range
    data[i] = rand() % (2*MAX_NUM) - MAX_NUM;
		//		printf("%i ", data[i]);
  }
	//	printf("\n");

  startTimer();
  sequentialIncrement(data, nNums);
  stopTimer();
  sum = counter;
  printf("Sum: %i\n", sum);
  printf("Sequential wall time: %lf ms\n", getWallTime());
  printf("Sequential process time: %lf ms\n", getProcTime());

  counter = 0;
  startTimer();
  spawn concurrentIncrement(data, nNums);
  sync;
  stopTimer();
  printf("Concurrent (Locks) wall time: %lf ms\n", getWallTime());
  printf("Concurrent (Locks) process time: %lf ms\n", getProcTime());
  assert(counter == sum);

  startTimer();
  counter = 0;
  Cilk_lock_init(lock_counter);
  spawn parallelIncrement(data, nNums);
  sync;
  stopTimer();
  printf("Parallel (Batch) wall time: %lf ms\n", getWallTime());
  printf("Parallel (Batch) process time: %lf ms\n", getProcTime());
  if (counter != sum) {
    printf("counter: %i, actual sum: %i\n", counter, sum);
    assert(counter == sum);
  }

  free(data);

  return 0;
}
