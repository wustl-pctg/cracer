#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <cilk-lib.cilkh>

#include "util/parfor.cilkh"
#include "util/prefixSums.cilkh"
#include "util/timer.h"

#define MAX_NUM 100
Cilk_lockvar lock_counter;
int counter = 0;

cilk void fastSum(void *dataStruct, void *data, size_t size, void *result)
{
  int i;
  int *nums = (int*)data;
	//	int temp = nums[size-1];

	for (i = 0; i < size; i++) {
		(*(int*)dataStruct) += nums[i];
		((int*)result)[i] = nums[i];
	}

  result = data;
	terminate_batch(_cilk_ws);
	return;
	/* spawn prefixSumsExc(nums, size, nums); */
	/* sync; */
	/* counter += temp + nums[size-1]; */

}

cilk void batchIncrement(int i, void* nums)
{
  void *temp;
	/* temp = spawn Cilk_batchify(fastSum, &counter, (void*)&((int*)nums)[i], sizeof(int)); */
	/* sync; */
	//Cilk_free(temp);
	temp = spawn Cilk_batchify(fastSum, &counter, (void*)&((int*)nums)[i], sizeof(int));
	sync;
}

cilk void parallelIncrement(int *nums, size_t size)
{
	spawn parforpar_1(0, size-1, batchIncrement, (void*)nums);
	sync;
} 

void lockIncrement(int i, void* nums)
{
  Cilk_lock(lock_counter);
  counter += ((int*)nums)[i];
	Cilk_unlock(lock_counter);
}

cilk void concurrentIncrement(int *nums, size_t size)
{
	spawn parfor_1(0, size-1, lockIncrement, (void*)nums);
	sync;
}

void sequentialIncrement(int *nums, size_t size)
{
	int i;
	for (i = 0; i < size; i++) {
		counter += nums[i];
	}
}

cilk int main(int argc, char *argv[])
{
  int *data;
	int nNums = 5;
	int i, sum;
	
	if (argc > 2) {
		fprintf(stderr, "Too many arguments\n");
		Cilk_exit(1);
	} else if (argc == 2) {
		nNums = atoi(argv[1]);
	}

	data = malloc(nNums*sizeof(int));

	srand(time(NULL));
	for (i = 0; i < nNums; i++) {
		// want -MAX_NUM to MAX_NUM range
		data[i] = rand() % (2*MAX_NUM) - MAX_NUM;
	}

	/* startTimer(); */
	/* sequentialIncrement(data, nNums); */
	/* stopTimer(); */
	/* sum = counter; */
	/* printf("Sum: %i\n", sum); */
	/* printf("Sequential wall time: %lf ms\n", getWallTime()); */
	/* printf("Sequential process time: %lf ms\n", getProcTime()); */

	/* counter = 0; */
	/* startTimer(); */
	/* spawn concurrentIncrement(data, nNums); */
	/* sync; */
	/* stopTimer(); */
	/* printf("Concurrent (Locks) wall time: %lf ms\n", getWallTime()); */
	/* printf("Concurrent (Locks) process time: %lf ms\n", getProcTime()); */
	/* assert(counter == sum); */
	sum = 0;
	for (i = 0; i < nNums; i++) {
		sum += data[i];
	}

	startTimer();
	counter = 0;
	Cilk_lock_init(lock_counter);
	spawn parallelIncrement(data, nNums);
	sync;
	stopTimer();
	printf("Parallel (Batch) wall time: %lf ms\n", getWallTime());
	printf("Parallel (Batch) process time: %lf ms\n", getProcTime());
	assert(counter == sum);

	free(data);

	return 0;
}
