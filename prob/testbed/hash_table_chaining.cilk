#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <cilk-lib.cilkh>

#define PARALLEL_CUTOFF 2
#define ab(j) (j<0)?-j:j

typedef struct itemsss{
    int key;
    void* data;
    struct itemsss* prev, *next;
} hashTableItem;

typedef struct {
    void** slots;
    int size;
    int load;
    Cilk_lockvar lock;
} hashTable;

struct hashTableInsertion{
    int key;
    void* item;
};

/*-----------------------------------Declarations---------------------------------------------------*/
hashTable* hashTable_create(int size);
struct hashTableInsertion* hashTable_createInsertion(int key, void* data);
hashTableItem* hashTable_createItem(int key, void* data);
cilk void hashTable_insert(hashTable* table, int key, void* data);
cilk void hashTable_batchInsert(hashTable* table, void* insertions, void* results, int size);
int hashTable_hash(int size, int key);
void hashTable_print(hashTable* table, int (*printfunct)(void*));
cilk void resize(hashTable* current_table, int new_size);
cilk void parallel_for1(hashTable* current_table, struct hashTableInsertion** inputs, cilk void(*parallel_function)(hashTable*,int,void*), int start, int end);
cilk void parallel_for2(hashTable* current_table, void** temp, cilk void(*parallel_function)(hashTable*,void**,int), int start, int end);
cilk void copy(hashTable* current_table, void** temp, int i);



/*-----------------------------------Create/Initialize Things---------------------------------------*/
//Creates a hash table of input size.
hashTable* hashTable_create(int size){
    hashTable* result = malloc(sizeof(hashTable));		//Allocate hashtable space
    Cilk_lock_init(result->lock);
    result->size=size;
    result->slots=calloc(size,sizeof(void*));			//Allocate containter space
    result->load=0;
    return result;
}

//Creates an insertion operation struct.
struct hashTableInsertion* hashTable_createInsertion(int key, void* data){
    struct hashTableInsertion* result = malloc(sizeof(struct hashTableInsertion));
    result->key=key;
    result->item=data;
    return result;
};

//Creates a table item, that is, a linked list item, with key and data.
hashTableItem* hashTable_createItem(int key, void* data){
    hashTableItem* result = malloc(sizeof(hashTableItem));
    result->key=key;
    result->data=data;
    result->prev=NULL;
    result->next=NULL;
    return result;
}


/*--------------------------------------Insert----------------------------------------------*/
//Insert a key-data pair into the input table.
cilk void hashTable_insert(hashTable* table, int key, void* data) {
    int slot = hashTable_hash(table->size, key);
    hashTableItem* ptr;
    hashTableItem* dataItem = hashTable_createItem(key,data);
    Cilk_lock(table->lock);
    if (table->slots[slot]==NULL){ //No list
        table->slots[slot]=dataItem;
    }
    else {
        ptr = table->slots[slot]; //Start at the head of the list.
        while(ptr->next!=NULL) {
            ptr=ptr->next;
        }
        ptr->next=dataItem;
        ptr->next->prev=ptr;
    }
    table->load++;
    Cilk_unlock(table->lock);
}

cilk void hashTable_batchInsert(hashTable* table, void* insertions, void* results, int input_size){
    //Insertions will always be a int key followed by a void*
	struct hashTableInsertion** inputs = (struct hashTableInsertion**)insertions;
    int i;
	
	if(input_size+table->load > table->size)	//If current_array needs more space
	{
		//spawn resize(table, 2*(table->load+input_size));
		//sync;
	}

    //Parallel operation must be done.
	/* for (i=0;i<size;i++) {
		hashTable_insert(table,inputs[i]->key,inputs[i]->item); //Probably need to handle collisions cleverly.
	}*/
	spawn parallel_for1(table, inputs, hashTable_insert, 0, input_size);
	sync;
}


/*--------------------------------Other--------------------------------------------*/
//Hash the input key based on size. 
int hashTable_hash(int size, int key) {
    //Use a simple multiplicative hash for now
    double k = (double) key;
    double magic_number = (sqrt(5)-1)/2;
    int spot;
	
    spot = floor(size *(ab(k*magic_number - floor(k*magic_number))));	//Hash function
	
    return spot;
}

//Prints out the hash table given the print function.
void hashTable_print(hashTable* table, int (*printfunct)(void*)){
    int i;
	
    for (i=0;i<table->size;i++){
        if (table->slots[i]==NULL){
            printfunct(NULL);
        }
        else { 
            printfunct(table->slots[i]);
        }
    }
	printf("Load: %d\t Size: %d\n", table->load, table->size);
}

cilk void resize(hashTable* current_table, int new_size)		//Sets the size of current_array to new_size
{
	//int i;
	void** temp;
	
	if(current_table->size > new_size)
	{
		printf("Error: Sizing Problem");
		return;
	}
	
	current_table->size = new_size;
	temp = malloc(current_table->size * sizeof(void*));		//Reserve a new chunk of memory
	
	/*for(i=0; i<current_array->used; ++i){		//PARALLEL FOR
		temp[i] = current_array->array[i];
	}*/
	spawn parallel_for2(current_table, temp, copy, 0, current_table->load);		//Copy to new array in parallel
	sync;
	
	free(current_table->slots);
	current_table->slots = temp;
}


/*-------------------------Parallel Functions--------------------------------------*/
//A standard parallel_for loop
cilk void parallel_for1(hashTable* current_table, struct hashTableInsertion** inputs, cilk void(*parallel_function)(hashTable*,int,void*), int start, int end)
{
	int middle = start+(end-start)/2;
	if (end-start<=PARALLEL_CUTOFF) {
		for (start; start < end; ++start) {
            spawn parallel_function(current_table, inputs[start]->key, inputs[start]->item);
		}
    }
	else
	{		
		spawn parallel_for1(current_table, inputs, parallel_function, start, middle); 		//start -> middle-1
		spawn parallel_for1(current_table, inputs, parallel_function, middle+1, end); 		//middle+1 -> end-1
		spawn parallel_function(current_table, inputs[middle]->key, inputs[middle]->item);	//middle
	}
}

cilk void parallel_for2(hashTable* current_table, void** temp, cilk void(*parallel_function)(hashTable*,void**,int), int start, int end)
{
	int middle = start+(end-start)/2;
	if (end-start<=PARALLEL_CUTOFF) {
		for (start; start < end; ++start) {
            spawn parallel_function(current_table, temp, start);
		}
    }
	else
	{		
		spawn parallel_for2(current_table, temp, parallel_function, start, middle); 	//start -> middle-1
		spawn parallel_for2(current_table, temp, parallel_function, middle+1, end); 	//middle+1 -> end-1
		spawn parallel_function(current_table, temp, middle);						//middle
	}
}

cilk void copy(hashTable* current_table, void** temp, int i)
{
	temp[i] = current_table->slots[i];
}