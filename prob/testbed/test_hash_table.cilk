#include "hash_table_chaining2.cilk"

#define TEST_SIZE 500

static int count;

int printints(void* input){
    hashTableItem* ptr;
    if (input==NULL) {
        printf("{nil}");
    }
    else {
        ptr=input;
        printf("{");
        do {
            printf("[%d -> %d]",ptr->key,*(int*)(ptr->data));
            ptr=ptr->next;
            count++;
        }
        while (ptr!=NULL);
        printf("}");
    }
}

cilk int main() {
    hashTable* table1 = hashTable_create(15);
    hashTableItem* item;
    int i;
    int array[TEST_SIZE];
    hashTableItem* items[200];
    struct hashTableInsertion* test[TEST_SIZE];
	
    count=0;
    for (i=0;i<TEST_SIZE;i++){
        array[i] = rand()%100;
    }
    for (i=0;i<TEST_SIZE;i++){
        test[i] = hashTable_createInsertion(i,&array[i]);
    }
    
    spawn hashTable_batchInsert(table1,test,NULL,TEST_SIZE/2);
	sync;
    spawn hashTable_batchInsert(table1,&test[TEST_SIZE/2-1],NULL,TEST_SIZE/2);
	sync;
	
    hashTable_print(table1,printints);
    printf("\ncount: %d\n",count);
    
    printf("search for stuff:\n");
    for (i=0;i<200;i++){
        items[i] = spawn hashTable_search(table1,i);
    }
    sync;
    printf("remove stuff:\n");
    spawn hashTable_batchRemove(table1,items,NULL,200);
	sync;
    count=0;
    hashTable_print(table1,printints);
    printf("\ncount: %d\n",count);
}