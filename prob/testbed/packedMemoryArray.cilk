#include <stdio.h>
#include <stdlib.h>
#include <cilk-lib.cilkh>
#include <math.h>


#define TOTAL_MAX_LOAD 0.5
#define SEG_MAX_LOAD 1.0
/*! \brief Simple array item.
*/
typedef struct p_Item{
    int label;
    void* item;
    struct p_Item* in;
} pItem;

/*! \brief Struct for the packed-memory Array (called pArray now)
*/
typedef struct {
    /*! The actual array of items*/
    pItem** array;
    /*! A secondary array of sizes, there are n/log(n) ints in this array*/
    int* topArray;
    /*! Size of the pItem Array. Always a power of 2.*/
    int maxSize;
    /*! Total load factor*/
    int load;
    /*! Size of the int array*/
    int topSize;
    /*! The length of each segment that an int corresponds to, this is ~log(n)*/
    int length;
} pArray;


/*Constructors*/
pArray* pArray_create(int maxSize);
pItem* pItem_create(void* item);

/*Functions*/
void pArray_print(pArray* ds);
void pArray_destroy(pArray* victim); //Destructor
pItem* pArray_order(pItem* x, pItem* y); 
void pArray_insert(pArray* ds, pItem* x, pItem* y);
void pArray_double(pArray* ds);

/*Private Functions*/
void redistributeLabel(pArray* ds, int index,pItem* newItem);
void insertAndShove(pArray* ds, int index, pItem* newItem);
void fillSpace(pArray* ds, int start, int index, pItem* newItem, int segments);
void determineSegments(pArray* ds, int index, int* startResult, int* segments);
int countLoad(pArray* ds, int start, int end);
float loadCoefficient(float tMax, float segMax, int lvl, int hMax);

/*! \brief Creates a pArray with initial size.
    Returns a pointer to the new pArray.
    \param maxSize the initial size
*/
pArray* pArray_create(int maxSize){
    pArray* result = malloc(sizeof(pArray));
    int realSize=pow(2,ceil((log(maxSize)/log(2))));
    result->array = calloc(realSize,sizeof(pItem*)); 
    result->length = (int)log(realSize);
    result->topSize=realSize/result->length;
    result->topArray=calloc(result->topSize,sizeof(int));
    result->maxSize=realSize;
    result->load=0;
    //printf("top: %d, %d\n",result->length,result->topSize);
    return result;
}

/*! \brief Creates a pItem
*/
pItem* pItem_create(void* item){
    pItem* result = malloc(sizeof(pItem));
    result->item=item;
    result->in=NULL;
    return result;
}

/*! \brief Destructor for the pArray.
*/
void pArray_destroy(pArray* victim){
    int i;
    if (victim==NULL){
        return;
    }
    else {
        for(i=0;i<victim->maxSize;i++){
            if (victim->array[i]!=NULL){
                free(victim->array[i]);
            }
        }
        free(victim->array);
        free(victim->topArray);
        free(victim);
    }
}

/*! \brief O(1) time Order operation by comparing labels.
*/
pItem* pArray_order(pItem* x, pItem* y){
    if (x==NULL || y ==NULL){
        printf("one item is null\n");
        return NULL;
    }
    else {
        if (x->label > y->label){
            return y;
        }
        else if (x->label < y->label){
            return x;
        }
        else {
            if (x==y){
                //KL: They are the same item, so arbitrarily return one?
                return x;
            }
            else {
                printf("equal error!\n");
                return NULL;
            }
        }
    }
}

/*! \brief Insert operation, not yet O(1) amortized time
*/
void pArray_seqInsert(pArray* ds, pItem* x, pItem* y){
    int apres;
    ds->load++;
    
    
    //Need to figure out how to rebalance things properly.
    if (x==NULL){
        apres=1;
    } else {
        apres=x->label+1;
    }
    
    if (ds->array[apres]!=NULL){
        //KL: Need to shove things around in a non-trivial manner. 
        redistributeLabel(ds,apres,y);
        //printf("%d occupied\n",apres);
    }
    else {
        y->label=apres;
        ds->array[apres]=y;
        (ds->topArray[apres/ds->length])++;
    }
}

/*! \brief Delete operation just removes item from array.
*/
void pArray_delete(pArray* ds, pItem* x){
    if (x==NULL){
        return;
    }
    if (ds->array[x->label]==NULL){
        return;
    }
    else {
        ds->array[x->label]=NULL;
    }
}

/*! \brief A batch version of the insert.
*/
void pArray_batchInsert(pArray* ds, void* opRec, int size, void* results){

}

void fillSpace(pArray* ds, int start, int index, pItem* newItem, int segments) {
    int toFill;
    int next;
    int topStart = (start/ds->length);
    int spacing;
    int totalLoad=0;
    int* topArray = ds->topArray;
    pItem* temp;
    for (next=topStart; next < topStart+segments; next++){
        totalLoad+=topArray[next];
        topArray[next]=0; //Reset the load amounts, will re-populate later.
    }
    totalLoad++;//There is a newItem to add!
    
    //This flushes all the items to the left.
    toFill = start;
    for (next=start; next < start+(ds->length)*segments;next++){
        if (ds->array[next]!=NULL){
            temp=ds->array[next];
            ds->array[next]=NULL;
            ds->array[toFill]=temp;
            toFill++;
            //Insert the new item.
            if (next==index){
                //KL: Need to shove things to insert the new item.
                insertAndShove(ds,toFill,newItem);
                toFill++;
                if (next<toFill){
                    next=toFill-1;
                }
            }
        }
    }
    //Now must redistrubte along the segment. Segment has size ds->length
    spacing = (segments*ds->length)/totalLoad;
    for (toFill=(totalLoad)-1;toFill>=0;toFill--){
        temp=ds->array[start+toFill];
        //KL: This should not happen unless the above shove to left didn't work pour some reason.
        if (temp==NULL){
            printf("NULL TEMP\n");
            pArray_print(ds);
        }
        ds->array[start+toFill]=NULL;
        ds->array[toFill*spacing+start]=temp;
        ds->array[toFill*spacing+start]->label = toFill*spacing+start;
        (topArray[(toFill*spacing+start)/ds->length])++;
    }
}

/*! \brief Redistributes labels in array
    
    Note that the values of the topArray - the number of elements in each sublist, is only valid when the array is not overloaded.
    After overload, the values of the topArray no longer mean anything.
*/
void redistributeLabel(pArray* ds, int index, pItem* newItem) {
    int segments=1;
    int start,next;
    int totalSize;
    //int d=0;
    //(ds->topArray[index/ds->length])++;
    totalSize=0;
    //If the load is too high for the segment, need to do more work.
    //KL: Here, use the new re-balance function.
    determineSegments(ds, index, &start, &segments);
    if (start<0){
       //printf("array is too small to hold any more elements!"); 
       //This happens if too many elemets are inserted into the array, must then resize!
       pArray_double(ds);
       //Double the array size, then relabel everything.
       //start=0;
       //segments=ds->topSize;
       redistributeLabel(ds,index,newItem);
       return;
       //d=1;
       //return;
    }
    //printf("start,seg: %d,%d\n",start,segments);
    fillSpace(ds, start, index, newItem, segments);
    //if (d==1){
     //  pArray_print(ds);
    //}
}

/*! \brief Finds the appropriate low-density region to relabel.

    This implementation uses an implicit tree on top of the array.
*/
void determineSegments(pArray* ds, int index, int* start, int* segments)
{
    int totalLoad=0;
    int treeLevel=0;
    int length=ds->length;
    int curLength=length;
    int maxHeight = log(ds->topSize)/log(2);
    int indexSeg=index/ds->length;
    int node;
    while(treeLevel<=maxHeight){
        //base case. I.e. for 1 segment
        if (treeLevel==0){
            totalLoad=ds->topArray[indexSeg];
            if (totalLoad+1<ds->length*SEG_MAX_LOAD){
                *segments=1;
                *start=indexSeg*ds->length;
                return;
            }
        }   
        else {
            curLength=2*length;
            node=index/curLength;
            //If true, the previous calc. was the left subTree.
            if (node==2*(index/length)){
                totalLoad+=countLoad(ds,node+length,node+curLength);
            }
            else {
                totalLoad+=countLoad(ds,node,node+length);
            }
            if (totalLoad+1<curLength*loadCoefficient(TOTAL_MAX_LOAD,SEG_MAX_LOAD,treeLevel,maxHeight)){
                *segments=curLength/ds->length;
                *start=node*curLength;
                return;
            }
            else {
                //printf("load %d length %d\n",totalLoad,curLength);
                //printf("node %d idea %d\n",node,2*(index/length));
                //printf("l %d cl %d\n",length,curLength);
                length*=2;
            }
        }
        treeLevel++;
    }
    //If nothing is returned at the end of this loop, it means array is too small.
    printf("expired height, must double the array!\n");
    *start = -1;
}

/*! \brief Calculates the correct load coefficient for the current level in the implicit tree
*/
float loadCoefficient(float tMax, float segMax, int lvl, int hMax){
    float result;
    float level=(float)lvl;
    float height = (float)hMax;
    result = tMax + (segMax-tMax)*(height-level)/(height);
    //printf("coef %f\n",result);
    return result;
}

/*! \brief Counts the load from start to end, exclusive at end but inclusive at start.
*/
int countLoad(pArray* ds,int start,int end){
    int count=0;
    int i;
    start/=ds->length;
    end=(end-1)/ds->length;
    /*Needs a less-than-or-equal because the start,end bounds are inclusive! 
    I.e. suppose the start and end are both within one ds->length.
    In such a case, the count should be 1, not zero!*/
    for (i=start;i<=end;i++){ 
        count+=ds->topArray[i];
    }
    return count;
}
/*! \brief Array insert function - put in element, shove everything along to the right.
*/
void insertAndShove(pArray* ds, int index, pItem* newItem){
    int i = index;
    pItem* temp, *temp2;
    temp=ds->array[i];
    ds->array[i]=NULL;
    i++;
    while (temp!=NULL){
        temp2=temp;
        temp=ds->array[i];
        ds->array[i]=temp2;
        i++;
    }
    ds->array[index]=newItem;
}

/*! \brief Prints the Array
*/
void pArray_print(pArray* ds){
    int i;
    int count=0;
    for (i=0;i<ds->maxSize;i++){
        if (ds->array[i]!=NULL){
            printf("[%d:%c]\n",i,*(char*)(ds->array[i]->item));
            //printf("[%d:%p]\n",i,ds->array[i]);
            count++;
        }
    }
    for (i=0;i<ds->topSize;i++){
        printf("[%d]\n",ds->topArray[i]);
    }
    printf("Total: %d/%d\n",count,ds->maxSize);
}

/*! \brief Doubles the array (call when too small!)
*/
void pArray_double(pArray* ds){
    //KL: Seems to trigger all sorts of bugs 7/10/2013
    int i;
    //printf("before double size: %d,%d\n",ds->maxSize,ds->length);
   // pArray_print(ds);
    ds->maxSize*=2;
    ds->length=(int)log(ds->maxSize);
    ds->topSize=ds->maxSize/ds->length;
    ds->array = realloc(ds->array,ds->maxSize*sizeof(pItem*));
    ds->topArray=realloc(ds->topArray,ds->topSize*sizeof(int));
    if (ds->array==NULL || ds->topArray==NULL){
        printf("error allocating\n");
    }
    for (i=0;i<ds->topSize;i++){
        ds->topArray[i]=0;
    }
    for (i=0;i<ds->maxSize;i++){
        if(ds->array[i]!=NULL){
            (ds->topArray[i/ds->length])++;
        }
    }
    //printf("after double size: %d,%d\n",ds->maxSize,ds->length);
    //pArray_print(ds);
    //printf("--------------\n");
}