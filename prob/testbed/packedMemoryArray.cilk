#include <stdio.h>
#include <stdlib.h>
#include <cilk-lib.cilkh>
#include <math.h>

#define TOTAL_MAX_LOAD 0.5
#define SEG_MAX_LOAD 1.0
/*! \brief Simple array item.
*/
typedef struct p_Item{
    int label;
    void* item;
    struct p_Item* in;
} pItem;

/*! \brief The Indirection item
 */
typedef struct {
  int count;
  Cilk_lockvar lock;
  int start;
} topItem;

/*! \brief Struct for the packed-memory Array (called pArray now)
*/
typedef struct {
    /*! The actual array of items*/
    pItem** array;
    /*! A secondary array of sizes, there are n/log(n) ints in this array - this is the "indirection"*/
    topItem* topArray;
    /*! Size of the pItem Array. Always a power of 2.*/
    int maxSize;
    /*! Total load factor*/
    int load;
    /*! Size of the int array*/
    int topSize;
    /*! The length of each segment that an int corresponds to, this is ~log(n)*/
    int length;
  /*! A lock for the array*/
  Cilk_lockvar lock;
} pArray;

typedef struct {
  pItem* x;
  pItem* y;
} pOpRec;

/*Constructors*/
pArray* pArray_create(int maxSize);
pItem* pItem_create(void* item);

/*Functions*/
void pArray_print(pArray* ds);
void pArray_destroy(pArray* victim); //Destructor
pItem* pArray_order(pItem* x, pItem* y); 
void pArray_insert(pArray* ds, pItem* x, pItem* y);
void pArray_double(pArray* ds);
cilk void pArray_batchInsert(pArray* ds, void* opRec, int size, void* results);

/*Private Functions*/
void redistributeLabel(pArray* ds, int index,pItem* newItem);
void insertAndShove(pArray* ds, int index, pItem* newItem);
void fillSpace(pArray* ds, int start, int index, pItem* newItem, int segments);
void determineSegments(pArray* ds, int index, int* startResult, int* segments);
int countLoad(pArray* ds, int start, int end);
float loadCoefficient(float tMax, float segMax, int lvl, int hMax);
void fillMuchSpace(pArray* ds, pItem** temp, int startSeg, int segments);
cilk void insertItem(pArray* ds, pItem** input, int index);
int countAllLoad(pArray* ds, int start, int end);
void processItem(pArray* ds, pItem** input, int round, int index, int* notDone);
cilk void parallelProcessItem(pArray* ds, pItem** input, int round, int* notDone, int start, int end);

/*! \brief Creates a pArray with initial size.
    Returns a pointer to the new pArray.
    \param maxSize the initial size
*/
pArray* pArray_create(int maxSize){
    pArray* result = malloc(sizeof(pArray));
    int realSize=pow(2,ceil((log(maxSize)/log(2))));
    result->array = calloc(realSize,sizeof(pItem*)); 
    result->length = (int)log(realSize);
    result->topSize=realSize/result->length;
    result->topArray=calloc(result->topSize,sizeof(topItem));
    result->maxSize=realSize;
    result->load=0;
    Cilk_lock_init(result->lock);
    //KL: Could be parallel, but shouldn't matter much.
    for (realSize=0;realSize<result->topSize;realSize++){
      Cilk_lock_init(result->topArray[realSize].lock);
      result->topArray[realSize].start=realSize*result->length;
    }
    //printf("top: %d, %d\n",result->length,result->topSize);
    return result;
}

/*! \brief Creates a pItem
*/
pItem* pItem_create(void* item){
    pItem* result = malloc(sizeof(pItem));
    result->item=item;
    result->in=NULL;
    return result;
}

/*! \brief Destructor for the pArray.
*/
void pArray_destroy(pArray* victim){
    int i;
    if (victim==NULL){
        return;
    }
    else {
        for(i=0;i<victim->maxSize;i++){
            if (victim->array[i]!=NULL){
                free(victim->array[i]);
            }
        }
        free(victim->array);
        free(victim->topArray);
        free(victim);
    }
}

/*! \brief O(1) time Order operation by comparing labels.
*/
pItem* pArray_order(pItem* x, pItem* y){
    if (x==NULL || y ==NULL){
        printf("one item is null\n");
        return NULL;
    }
    else {
        if (x->label > y->label){
            return y;
        }
        else if (x->label < y->label){
            return x;
        }
        else {
            if (x==y){
                //KL: They are the same item, so arbitrarily return one?
                return x;
            }
            else {
                printf("equal error!\n");
                return NULL;
            }
        }
    }
}

/*! \brief Insert operation, O(log^2 n) amortized time, I think.
*/
void pArray_seqInsert(pArray* ds, pItem* x, pItem* y){
    int apres;
    Cilk_lock(ds->lock);
    //printf("inserting %p\n",y);
    ds->load++;
    
    
    //Need to figure out how to rebalance things properly.
    if (x==NULL){
        apres=1;
    } else {
        apres=x->label+1;
    }
    //printf("%d\n",apres);
    if (ds->array[apres]!=NULL){
        //KL: Need to shove things around in a non-trivial manner. 
        redistributeLabel(ds,apres,y);
        //printf("%d occupied\n",apres);
    }
    else {
        y->label=apres;
        ds->array[apres]=y;
        (ds->topArray[apres/ds->length].count)++;
    }
    Cilk_unlock(ds->lock);
}

/*! \brief Delete operation just removes item from array.

    Note that this does not free the memory of the item - since the caller of the method still has a pointer to it.
*/
void pArray_delete(pArray* ds, pItem* x){
    if (x==NULL){
        return;
    }
    if (ds->array[x->label]==NULL){
        return;
    }
    else {
        ds->array[x->label]=NULL;
	ds->topArray[x->label/ds->length].count--;
 
   }
}

/*! \brief The operation that calls batchify
 */
cilk void pArray_parInsert(pArray* ds, pItem* x, pItem* y){
  pOpRec ins;
  ins.x=x;
  ins.y=y;
  Cilk_batchify(_cilk_ws, &pArray_batchInsert, ds, &ins, sizeof(ins), NULL);
};


/*! \brief A batch version of the insert.
*/
cilk void pArray_batchInsert(pArray* ds, void* opRec, int size, void* results){
  /*!
    Note that the operation record must contain two pointers - the insert and the insert_place.
     That is why the input pointer to pItem is strange.
     Because it is inconvenient to use a 2D array, the technique of pretending a 2D array is 1D will be used.
     The insert item will be odd elements.
     The insert_place will be even elements.
  */
  pItem** input = opRec;
  //pOpRec* recs = opRec;
  pItem** temp;
  int i;
  //printf("%d\n",size);
   size*=2;
  /*for (i=0;i<size;i++){
    printf("size? %d\n",sizeof(pItem*));
    printf("item: %p,%p\n",input[i][0],input[i][1]);
    }*/
  
  if (ds->load+size/2>TOTAL_MAX_LOAD*ds->maxSize){
    pArray_double(ds);
  }
  ds->load+=size/2;
  
  //Store into temporary slot.
  for (i=0;i<size;i+=2){
    //printf("i=%d, %p\n",i,input[i]);
    input[i]->in = input[i+1];
    //KL: Hack#1 to re-use memory. Hopefully pointers have same size.
    //KL: so now, all odd items in input array are actually topItem*
    input[i+1]=(pItem*)&(ds->topArray[input[i]->label/ds->length]);
    //KL: increments the segment size, gets a lock.
    Cilk_lock(ds->topArray[input[i]->label/ds->length].lock);
    ds->topArray[input[i]->label/ds->length].count++;
    Cilk_unlock(ds->topArray[input[i]->label/ds->length].lock);
  }
  
  //Inserts items.
  //pArray_print(ds);
  //  printf("insert\n");
  spawn insertItem(ds,input,size);
  sync; 
 /*
  for (i=0;i<size;i+=2){
    printf("%d,%d\n",segments[i],segments[i+1]);
    }*/

  //  temp=calloc(ds->maxSize,sizeof(pItem*));
  //fillMuchSpace(ds, temp,0,ds->topSize);
  //Need to find which segments to do work on.
  Cilk_terminate_batch(_cilk_ws);
}

/*! \brief Insert method for batch. Uses locks cleverly.

 */
cilk void insertItem(pArray* ds, pItem** input, int size) {
  int round=0;
  int maxRounds=log(ds->topSize)/log(2);
  int length=ds->length;
  int i;
  int notDone=1;

  //printf("size %d\n",size);
  while (round<=maxRounds && notDone){
    //par_for
    notDone=0;
    spawn parallelProcessItem(ds, input, round, &notDone, 0, size);
    /*for (i=0;i<size;i+=2){
      processItem(ds, input, round,  i, &notDone);
    }*/
    sync;
    //printf("round %d end\n",round);
    round++;
  }
  if (notDone){
    printf("fail\n");
  } 
  else {
    //printf("done wtih stuff after %d rounds\n",round-1);
  }
}

void processItem(pArray* ds, pItem** input, int round, int index, int* notDone) {
  int length = pow(2,round);
  int count=0;
  int i;
  topItem* seg;
  int topIndex;
  pItem** temp;

  //Nothing to be done.
  if (input[index+1]==NULL){
    // printf("nothing to do in round %d for item %d\n",round,index);
    return;
  }
  
  seg = (topItem*)input[index+1];//KL: see Hack#1 above.
  topIndex = (*seg).start/ds->length;
  //  printf("doing round %d for item %d. top Index %d. topItem %p. \n",round,index, topIndex,seg);
//  printf("topIndex %d length %d, %p\n",topIndex,length,seg);
  //Lock the relevant part of the segment.
  i = (*seg).count;
  Cilk_lock((*seg).lock);
  if (i!=ds->topArray[topIndex].count){
    //printf("don't work\n");
    return;
  }
  for (i=topIndex;i<topIndex+length;i++){
    count+=ds->topArray[i].count;
  }
  if (count<length*ds->length*loadCoefficient(TOTAL_MAX_LOAD,SEG_MAX_LOAD,round, log(ds->topSize)/log(2))){
    temp = calloc(length*ds->length,sizeof(pItem*));
    //  printf("fill %d to %d\n", topIndex, topIndex+length);
    fillMuchSpace(ds,temp,topIndex,length);
    free(temp);
    input[index+1]=NULL;
  } else {
    //  printf("count %d, length %d\n",count,length);
    topIndex=topIndex/(2*length);
    topIndex*=(2*length);
    //KL: see Hack#1
    input[index+1]=(pItem*)&ds->topArray[topIndex];
    *notDone=1; //here is a concurrent write, but all are writing the same thing.
  }
  //Unlock
  Cilk_unlock((*seg).lock);
}


/*! \brief A method to populate a region of the array and evenly space them out.
  
   The newItem is the item to insert, the index is the index at which the item should be inserted.

 */
void fillSpace(pArray* ds, int start, int index, pItem* newItem, int segments) {
    int toFill;
    int next;
    int topStart = (start/ds->length);
    int spacing;
    int totalLoad=0;
    topItem* topArray = ds->topArray;
    pItem* temp;
    for (next=topStart; next < topStart+segments; next++){
        totalLoad+=ds->topArray[next].count;
        ds->topArray[next].count=0; //Reset the load amounts, will re-populate later.
    }
    totalLoad++; //There is a newItem to add!
    
    //This flushes all the items to the left to make sure the redistribution will work.
    toFill = start;
    for (next=start; next < start+(ds->length)*segments;next++){
        if (ds->array[next]!=NULL){
            temp=ds->array[next];
            ds->array[next]=NULL;
            ds->array[toFill]=temp;
            toFill++;
            //Insert the new item.
            if (next==index){
                //KL: Need to shove things to insert the new item.
                insertAndShove(ds,toFill,newItem);
                toFill++;
                if (next<toFill){
                    next=toFill-1;
                }
            }
        }
    }
    //Now must redistrubte along the segment. Segment has size ds->length
    spacing = (segments*ds->length)/totalLoad;
    for (toFill=(totalLoad)-1;toFill>=0;toFill--){
        temp=ds->array[start+toFill];
        //KL: This should not happen unless the above shove to left didn't work pour some reason.
        if (temp==NULL){
            printf("NULL TEMP\n");
            pArray_print(ds);
        }
        ds->array[start+toFill]=NULL;
        ds->array[toFill*spacing+start]=temp;
        ds->array[toFill*spacing+start]->label = toFill*spacing+start;
        (topArray[(toFill*spacing+start)/ds->length].count)++;
    }
}

/*! \brief A fillSpace method that works in batch.
  
    Note that the temp array passed in must be big enough (of size totalLoad at least)
    Suggest allocating an array of (batch_size + current_load) just in case.
*/
void fillMuchSpace(pArray* ds,  pItem** temp, int startSeg, int segments) {
  int spacing;
  int totalLoad=0;
  int next;
  int count=0;
  int startInd = startSeg*ds->length;
  int place;

  //Similar construct as in the sequential version.
  for (next=startSeg;next<startSeg+segments;next++){
    totalLoad+=ds->topArray[next].count;
    ds->topArray[next].count=0;
  }

  /*
    Let X be segments*ds->length.
    Do not do any shoving in the parallel case, since there is a temp. array of space.
    Trade-off here is that size X  portion of the array will always be copied twice.
    This is good when many batch items exist, but less so when there is few items.
    The sequential method (see the seqinsert) will only traverse the X length portion once.
       On the sceond pass it only goes through O(totalLoad) array indices.
    Luckily, it is only a constant factor worse at most.
  */  
  spacing = (segments*ds->length)/totalLoad;
  for (next=startInd;next<startInd + segments*ds->length;next++){
    if (ds->array[next]!=NULL){
      temp[count]=ds->array[next];
      count++;
      if (ds->array[next]->in!=NULL){
	temp[count]=ds->array[next]->in;
	ds->array[next]->in=NULL;
	count++;
      }
      ds->array[next]=NULL;
    }  
  }
  //Copies the items back into the array. Now with correct spacing.
  for (next=0;next<count;next++){
    place=startInd+spacing*next;
    ds->array[place]=temp[next];
    ds->array[place]->label=place;
    ds->topArray[place/ds->length].count++;
  }
}


/*! \brief Redistributes labels in array
 
    Changes the values of topArray too.
 */
void redistributeLabel(pArray* ds, int index, pItem* newItem) {
    int segments=1;
    int start,next;
    int totalSize;
    //int d=0;
    //(ds->topArray[index/ds->length])++;
    totalSize=0;
    //If the load is too high for the segment, need to do more work.
    //KL: Here, use the new re-balance function.
    determineSegments(ds, index, &start, &segments);
    if (start<0){
       //printf("array is too small to hold any more elements!"); 
       //This happens if too many elemets are inserted into the array, must then resize!
       pArray_double(ds);
       //Double the array size, then relabel everything.
       //start=0;
       //segments=ds->topSize;
       //printf("double\n");
       redistributeLabel(ds,index,newItem);
       return;
       //d=1;
       //return;
    }
    //printf("start,seg: %d,%d\n",start,segments);
    fillSpace(ds, start, index, newItem, segments);
    //if (d==1){
     //  pArray_print(ds);
    //}
}

/*! \brief Finds the appropriate low-density region to relabel.

    This implementation uses an implicit tree on top of the array.
*/
void determineSegments(pArray* ds, int index, int* start, int* segments)
{
    int totalLoad=0;
    int treeLevel=0;
    int length=ds->length;
    int curLength=length;
    int maxHeight = log(ds->topSize)/log(2);
    int indexSeg=index/ds->length;
    int node;
    while(treeLevel<=maxHeight){
        //base case. I.e. for 1 segment
        if (treeLevel==0){
            totalLoad=ds->topArray[indexSeg].count;
            if (totalLoad+1<ds->length*SEG_MAX_LOAD){
                *segments=1;
                *start=indexSeg*ds->length;
                return;
            }
        }   
        else {
            curLength=2*length;
            node=index/curLength;
            //If true, the previous calc. was the left subTree.
            if (node==2*(index/length)){
                totalLoad+=countLoad(ds,node+length,node+curLength);
            }
            else {
                totalLoad+=countLoad(ds,node,node+length);
            }
            if (totalLoad+1<curLength*loadCoefficient(TOTAL_MAX_LOAD,SEG_MAX_LOAD,treeLevel,maxHeight)){
                *segments=curLength/ds->length;
                *start=node*curLength;
                return;
            }
            else {
                //printf("load %d length %d\n",totalLoad,curLength);
                //printf("node %d idea %d\n",node,2*(index/length));
                //printf("l %d cl %d\n",length,curLength);
                length*=2;
            }
        }
        treeLevel++;
    }
    //If nothing is returned at the end of this loop, it means array is too small.
    printf("expired height, must double the array!\n");
    *start = -1;
}

/*! \brief Calculates the correct load coefficient for the current level in the implicit tree
*/
float loadCoefficient(float tMax, float segMax, int lvl, int hMax){
    float result;
    float level=(float)lvl;
    float height = (float)hMax;
    result = tMax + (segMax-tMax)*(height-level)/(height);
    //printf("coef %f\n",result);
    return result;
}

/*! \brief Count that also counts temp items.
 */
int countAllLoad(pArray* ds, int start, int end){
  int count=0;
  int i;
  for (i=start;i<end;i++){
    if (ds->array[i]!=NULL){
      count++;
      if(ds->array[i]->in!=NULL){
	count++;
      }
    }
  }
  return count;
}
/*! \brief Counts the load from start to end, exclusive at end but inclusive at start.
*/
int countLoad(pArray* ds,int start,int end){
    int count=0;
    int i;
    start/=ds->length;
    end=(end-1)/ds->length;
    /*Needs a less-than-or-equal because the start,end bounds are inclusive! 
    I.e. suppose the start and end are both within one ds->length.
    In such a case, the count should be 1, not zero!*/
    for (i=start;i<=end;i++){ 
        count+=ds->topArray[i].count;
    }
    return count;
}
/*! \brief Array insert function - put in element, shove everything along to the right.
*/
void insertAndShove(pArray* ds, int index, pItem* newItem){
    int i = index;
    pItem* temp, *temp2;
    temp=ds->array[i];
    ds->array[i]=NULL;
    i++;
    while (temp!=NULL){
        temp2=temp;
        temp=ds->array[i];
        ds->array[i]=temp2;
        i++;
    }
    ds->array[index]=newItem;
}

/*! \brief Prints the Array
*/
void pArray_print(pArray* ds){
    int i;
    int count=0;
    for (i=0;i<ds->maxSize;i++){
        if (ds->array[i]!=NULL){
            printf("[%d:%p]\n",i,ds->array[i]->item);
            count++;
        }
    }
    for (i=0;i<ds->topSize;i++){
        printf("[%d]\n",ds->topArray[i].count);
    }
    printf("Total: %d/%d\n",count,ds->maxSize);
    printf("Top size: %d\n",ds->topSize);
}

/*! \brief Doubles the array (call when too small!)
*/
void pArray_double(pArray* ds){
    int i;
    ds->maxSize*=2;
    ds->length=(int)log(ds->maxSize);
    ds->topSize=ds->maxSize/ds->length;
    ds->array = realloc(ds->array,ds->maxSize*sizeof(pItem*));
    ds->topArray=realloc(ds->topArray,ds->topSize*sizeof(topItem));
    if (ds->array==NULL || ds->topArray==NULL){
        printf("error allocating\n");
    }
    for (i=0;i<ds->topSize;i++){
        ds->topArray[i].count=0;
	ds->topArray[i].start=i*ds->length;
	Cilk_lock_init(ds->topArray[i].lock);
    }
    for (i=0;i<ds->maxSize;i++){
        if(ds->array[i]!=NULL){
            (ds->topArray[i/ds->length].count)++;
        }
    }
}

cilk void parallelProcessItem(pArray* ds, pItem** input, int round, int* notDone, int start, int end){
  int i;
  if (end-start<2){
    for (i=start; i <end; i++){
      if (i%2==0){
	processItem(ds, input, round, i, notDone);
      }
    }
  } else {
    i = start + (end-start)/2;
    spawn parallelProcessItem(ds,input,round,notDone,start,i);
    spawn parallelProcessItem(ds,input,round,notDone,i,end);
    sync;
  }
}
