#include <stdio.h>
#include <stdlib.h>
#include <cilk-lib.cilkh>
#include <math.h>


#define LOAD_COEFFICIENT 2
/*! \brief Simple array item.
*/
typedef struct {
    int label;
    void* item;
} pItem;

/*! \brief Struct for the packed-memory Array (called pArray now)
*/
typedef struct {
    /*! The actual array of items*/
    pItem** array;
    /*! A secondary array of sizes, there are n/log(n) ints in this array*/
    int* topArray;
    /*! Size of the pItem Array*/
    int maxSize;
    /*! Total load factor*/
    int load;
    /*! Size of the int array*/
    int topSize;
    /*! The length of each segment that an int corresponds to, this is ~log(n)*/
    int length;
} pArray;


/*Constructors*/
pArray* pArray_create(int maxSize);
pItem* pItem_create(void* item);

/*Functions*/
void pArray_print(pArray* ds);
void pArray_destroy(pArray* victim); //Destructor
pItem* pArray_order(pItem* x, pItem* y); 
void pArray_insert(pArray* ds, pItem* x, pItem* y);

/*Private Functions*/
void redistributeLabel(pArray* ds, int index,pItem* newItem);
void insertAndShove(pArray* ds, int index, pItem* newItem);
void fillSpace(pArray* ds, int index, pItem* newItem, int segments);

/*! \brief Creates a pArray with initial size.
    Returns a pointer to the new pArray.
    \param maxSize the initial size
*/
pArray* pArray_create(int maxSize){
    pArray* result = malloc(sizeof(pArray));
    result->array = calloc(maxSize,sizeof(pItem*)); 
    result->length = (int)log(maxSize);
    result->topSize=maxSize/result->length;
    result->topArray=calloc(result->topSize,sizeof(int));
    result->maxSize=maxSize;
    result->load=0;
    //printf("top: %d, %d\n",result->length,result->topSize);
    return result;
}

/*! \brief Creates a pItem
*/
pItem* pItem_create(void* item){
    pItem* result = malloc(sizeof(pItem));
    result->item=item;
    return result;
}

/*! \brief Destructor for the pArray.
*/
void pArray_destroy(pArray* victim){
    int i;
    if (victim==NULL){
        return;
    }
    else {
        for(i=0;i<victim->maxSize;i++){
            if (victim->array[i]!=NULL){
                free(victim->array[i]);
            }
        }
        free(victim->array);
        free(victim->topArray);
        free(victim);
    }
}

/*! \brief O(1) time Order operation by comparing labels.
*/
pItem* pArray_order(pItem* x, pItem* y){
    if (x==NULL || y ==NULL){
        printf("one item is null\n");
        return NULL;
    }
    else {
        if (x->label > y->label){
            return y;
        }
        else if (x->label < y->label){
            return x;
        }
        else {
            printf("equal error!\n");
            return NULL;
        }
    }
}

/*! \brief Insert operation, not yet O(1) amortized time
*/
void pArray_insert(pArray* ds, pItem* x, pItem* y){
    int apres;
    if (ds->load*LOAD_COEFFICIENT>ds->maxSize){
        printf("The array is too small to handle more inputs efficiently!\n");
    }
    else {
        ds->load++;
    }
    
    
    //Need to figure out how to rebalance things properly.
    if (x==NULL){
        apres=1;
    } else {
        apres=x->label+1;
    }
    if (ds->array[apres]!=NULL){
        //KL: Need to shove things around in a non-trivial manner. 
        redistributeLabel(ds,apres,y);
        //printf("%d occupied\n",apres);
    }
    else {
        y->label=apres;
        ds->array[apres]=y;
        (ds->topArray[apres/ds->length])++;
    }
}

void fillSpace(pArray* ds, int index, pItem* newItem, int segments) {
    int toFill;
    int next;
    int topStart = (index/ds->length);
    int start;
    int spacing;
    int totalLoad=0;
    int* topArray = ds->topArray;
    pItem* temp;
    start = topStart * ds->length;
    for (next=topStart; next < topStart+segments; next++){
        totalLoad+=topArray[next];
        topArray[next]=0; //Reset the load amounts, will re-populate later.
    }
    
    //This flushes all the items to the left.
    toFill = start;
    for (next=start; next < start+(ds->length)*segments;next++){
        if (ds->array[next]!=NULL){
            temp=ds->array[next];
            ds->array[next]=NULL;
            ds->array[toFill]=temp;
            toFill++;
            //Insert the new item.
            if (next==index){
                //KL: Need to shove things to insert the new item.
                insertAndShove(ds,toFill,newItem);
                toFill++;
                if (next<toFill){
                    next=toFill-1;
                }
            }
        }
    }
    //Now must redistrubte along the segment. Segment has size ds->length
    spacing = (segments*ds->length)/totalLoad;
    for (toFill=(totalLoad)-1;toFill>=0;toFill--){
        temp=ds->array[start+toFill];
        //KL: This should not happen unless the above shove to left didn't work pour some reason.
        if (temp==NULL){
            printf("NULL TEMP\n");
        }
        ds->array[start+toFill]=NULL;
        ds->array[toFill*spacing+start]=temp;
        ds->array[toFill*spacing+start]->label = toFill*spacing+start;
        (topArray[(toFill*spacing+start)/ds->length])++;
    }
}

/*! \brief Redistributes labels in array
    
    Note that the values of the topArray - the number of elements in each sublist, is only valid when the array is not overloaded.
    After overload, the values of the topArray no longer mean anything.
*/
void redistributeLabel(pArray* ds, int index, pItem* newItem) {
    int segments=1;
    int start,next;
    int totalSize;
    (ds->topArray[index/ds->length])++;
    totalSize=0;
    //If the load is too high for the segment, need to do more work.
    //KL: Here, use the new re-balance function.
    start = index/ds->length;
    for (next=start;next<ds->topSize;next++){
        totalSize+=ds->topArray[next];
        if (totalSize*LOAD_COEFFICIENT<=ds->length*segments){
            break;
        }
        else {
            segments++;
        }
    }
    if (next>=ds->topSize){
        printf("Overloaded\n");
        insertAndShove(ds,index,newItem);
        return;
    }
    else {
        //printf("segs %d\n",segments);
        fillSpace(ds, index, newItem, segments);
    }
}

/*! \brief Array insert function - put in element, shove everything along to the right.
*/
void insertAndShove(pArray* ds, int index, pItem* newItem){
    int i = index;
    pItem* temp, *temp2;
    temp=ds->array[i];
    ds->array[i]=NULL;
    i++;
    while (temp!=NULL){
        temp2=temp;
        temp=ds->array[i];
        ds->array[i]=temp2;
        i++;
    }
    ds->array[index]=newItem;
}

/*! \brief Prints the Array
*/
void pArray_print(pArray* ds){
    int i;
    int count=0;
    for (i=0;i<ds->maxSize;i++){
        if (ds->array[i]!=NULL){
            printf("[%d:%c]\n",i,*(char*)(ds->array[i]->item));
            count++;
        }
    }
    /*for (i=0;i<ds->topSize;i++){
        printf("[%d]\n",ds->topArray[i]);
    }*/
    printf("Total Items: %d\n",count);
}