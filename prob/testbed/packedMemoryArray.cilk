#include <stdio.h>
#include <stdlib.h>
#include <cilk-lib.cilkh>
#include <math.h>


#define TOTAL_MAX_LOAD 0.5
#define SEG_MAX_LOAD 1.0
/*! \brief Simple array item.
*/
typedef struct p_Item{
    int label;
    void* item;
    struct p_Item* in;
} pItem;


/*! \brief Struct for the packed-memory Array (called pArray now)
*/
typedef struct {
    /*! The actual array of items*/
    pItem** array;
    /*! A secondary array of sizes, there are n/log(n) ints in this array - this is the "indirection"*/
    int* topArray;
    /*! Size of the pItem Array. Always a power of 2.*/
    int maxSize;
    /*! Total load factor*/
    int load;
    /*! Size of the int array*/
    int topSize;
    /*! The length of each segment that an int corresponds to, this is ~log(n)*/
    int length;
} pArray;


/*Constructors*/
pArray* pArray_create(int maxSize);
pItem* pItem_create(void* item);

/*Functions*/
void pArray_print(pArray* ds);
void pArray_destroy(pArray* victim); //Destructor
pItem* pArray_order(pItem* x, pItem* y); 
void pArray_insert(pArray* ds, pItem* x, pItem* y);
void pArray_double(pArray* ds);

/*Private Functions*/
void redistributeLabel(pArray* ds, int index,pItem* newItem);
void insertAndShove(pArray* ds, int index, pItem* newItem);
void fillSpace(pArray* ds, int start, int index, pItem* newItem, int segments);
void determineSegments(pArray* ds, int index, int* startResult, int* segments);
int countLoad(pArray* ds, int start, int end);
float loadCoefficient(float tMax, float segMax, int lvl, int hMax);
void fillMuchSpace(pArray* ds, pItem** temp, int startSeg, int segments);


/*! \brief Creates a pArray with initial size.
    Returns a pointer to the new pArray.
    \param maxSize the initial size
*/
pArray* pArray_create(int maxSize){
    pArray* result = malloc(sizeof(pArray));
    int realSize=pow(2,ceil((log(maxSize)/log(2))));
    result->array = calloc(realSize,sizeof(pItem*)); 
    result->length = (int)log(realSize);
    result->topSize=realSize/result->length;
    result->topArray=calloc(result->topSize,sizeof(int));
    result->maxSize=realSize;
    result->load=0;
    //printf("top: %d, %d\n",result->length,result->topSize);
    return result;
}

/*! \brief Creates a pItem
*/
pItem* pItem_create(void* item){
    pItem* result = malloc(sizeof(pItem));
    result->item=item;
    result->in=NULL;
    return result;
}

/*! \brief Destructor for the pArray.
*/
void pArray_destroy(pArray* victim){
    int i;
    if (victim==NULL){
        return;
    }
    else {
        for(i=0;i<victim->maxSize;i++){
            if (victim->array[i]!=NULL){
                free(victim->array[i]);
            }
        }
        free(victim->array);
        free(victim->topArray);
        free(victim);
    }
}

/*! \brief O(1) time Order operation by comparing labels.
*/
pItem* pArray_order(pItem* x, pItem* y){
    if (x==NULL || y ==NULL){
        printf("one item is null\n");
        return NULL;
    }
    else {
        if (x->label > y->label){
            return y;
        }
        else if (x->label < y->label){
            return x;
        }
        else {
            if (x==y){
                //KL: They are the same item, so arbitrarily return one?
                return x;
            }
            else {
                printf("equal error!\n");
                return NULL;
            }
        }
    }
}

/*! \brief Insert operation, O(log^2 n) amortized time, I think.
*/
void pArray_seqInsert(pArray* ds, pItem* x, pItem* y){
    int apres;
    ds->load++;
    
    
    //Need to figure out how to rebalance things properly.
    if (x==NULL){
        apres=1;
    } else {
        apres=x->label+1;
    }
    
    if (ds->array[apres]!=NULL){
        //KL: Need to shove things around in a non-trivial manner. 
        redistributeLabel(ds,apres,y);
        //printf("%d occupied\n",apres);
    }
    else {
        y->label=apres;
        ds->array[apres]=y;
        (ds->topArray[apres/ds->length])++;
    }
}

/*! \brief Delete operation just removes item from array.
*/
void pArray_delete(pArray* ds, pItem* x){
    if (x==NULL){
        return;
    }
    if (ds->array[x->label]==NULL){
        return;
    }
    else {
        ds->array[x->label]=NULL;
    }
}

/*! \brief A batch version of the insert.
*/
void pArray_batchInsert(pArray* ds, void* opRec, int size, void* results){
  /*!
    Note that the operation record must contain two pointers - the insert and the insert_place.
     That is why the input is a triple pointer to pItem. 
     The insert item will be input[x][1].
     The insert_place will be input[x][0]
  */
  pItem*** input = opRec;
  int i;
  for (i=0;i<size;i++){
    //input[i][0]->in = input[i][1];
    //Temporarily just call sequential insert.
    pArray_seqInsert(ds,input[i][0],input[i][1]);
  }
  
}

/*! \brief A method to populate a region of the array and evenly space them out.
  
   The newItem is the item to insert, the index is the index at which the item should be inserted.

 */
void fillSpace(pArray* ds, int start, int index, pItem* newItem, int segments) {
    int toFill;
    int next;
    int topStart = (start/ds->length);
    int spacing;
    int totalLoad=0;
    int* topArray = ds->topArray;
    pItem* temp;
    for (next=topStart; next < topStart+segments; next++){
        totalLoad+=topArray[next];
        topArray[next]=0; //Reset the load amounts, will re-populate later.
    }
    totalLoad++;//There is a newItem to add!
    
    //This flushes all the items to the left to make sure the redistribution will work.
    toFill = start;
    for (next=start; next < start+(ds->length)*segments;next++){
        if (ds->array[next]!=NULL){
            temp=ds->array[next];
            ds->array[next]=NULL;
            ds->array[toFill]=temp;
            toFill++;
            //Insert the new item.
            if (next==index){
                //KL: Need to shove things to insert the new item.
                insertAndShove(ds,toFill,newItem);
                toFill++;
                if (next<toFill){
                    next=toFill-1;
                }
            }
        }
    }
    //Now must redistrubte along the segment. Segment has size ds->length
    spacing = (segments*ds->length)/totalLoad;
    for (toFill=(totalLoad)-1;toFill>=0;toFill--){
        temp=ds->array[start+toFill];
        //KL: This should not happen unless the above shove to left didn't work pour some reason.
        if (temp==NULL){
            printf("NULL TEMP\n");
            pArray_print(ds);
        }
        ds->array[start+toFill]=NULL;
        ds->array[toFill*spacing+start]=temp;
        ds->array[toFill*spacing+start]->label = toFill*spacing+start;
        (topArray[(toFill*spacing+start)/ds->length])++;
    }
}

/*! \brief A fillSpace method that works in batch.
  
    Note that the temp array passed in must be big enough (of size totalLoad at least)
    Suggest allocating an array of (batch_size + current_load) just in case.
*/
void fillMuchSpace(pArray* ds,  pItem** temp, int startSeg, int segments) {
  int spacing;
  int totalLoad=0;
  int next;
  int count=0;
  int startInd = startSeg*ds->length;

  //Similar construct as in the sequential version.
  for (next=startSeg;next<startSeg+segments;next++){
    totalLoad+=ds->topArray[next];
    ds->topArray[next]=0;
  }

  /*
    Let X be segments*ds->length.
    Do not do any shoving in the parallel case, since there is a temp. array of space.
    Trade-off here is that size X  portion of the array will always be copied twice.
    This is good when many batch items exist, but less so when there is few items.
    The sequential method (see the seqinsert) will only traverse the X length portion once.
       On the sceond pass it only goes through O(totalLoad) array indices.
    Luckily, it is only a constant factor worse at most.
  */  
  spacing = (segments*ds->length)/totalLoad;
  for (next=startInd;next<startInd + segments*ds->length;next++){
    if (ds->array[next]!=NULL){
      temp[count]=ds->array[next];
      count++;
      if (ds->array[next]->in!=NULL){
	temp[count]=ds->array[next]->in;
	ds->array[next]->in=NULL;
	count++;
      }
    }  
  }
  //Copies the items back into the array. Now with correct spacing.
  for (next=0;next<count;next++){
    ds->array[startInd+spacing*next]=temp[next];
  }
}


/*! \brief Redistributes labels in array
    
    Note that the values of the topArray - the number of elements in each sublist, is only valid when the array is not overloaded.
    After overload, the values of the topArray no longer mean anything.
*/
void redistributeLabel(pArray* ds, int index, pItem* newItem) {
    int segments=1;
    int start,next;
    int totalSize;
    //int d=0;
    //(ds->topArray[index/ds->length])++;
    totalSize=0;
    //If the load is too high for the segment, need to do more work.
    //KL: Here, use the new re-balance function.
    determineSegments(ds, index, &start, &segments);
    if (start<0){
       //printf("array is too small to hold any more elements!"); 
       //This happens if too many elemets are inserted into the array, must then resize!
       pArray_double(ds);
       //Double the array size, then relabel everything.
       //start=0;
       //segments=ds->topSize;
       redistributeLabel(ds,index,newItem);
       return;
       //d=1;
       //return;
    }
    //printf("start,seg: %d,%d\n",start,segments);
    fillSpace(ds, start, index, newItem, segments);
    //if (d==1){
     //  pArray_print(ds);
    //}
}

/*! \brief Finds the appropriate low-density region to relabel.

    This implementation uses an implicit tree on top of the array.
*/
void determineSegments(pArray* ds, int index, int* start, int* segments)
{
    int totalLoad=0;
    int treeLevel=0;
    int length=ds->length;
    int curLength=length;
    int maxHeight = log(ds->topSize)/log(2);
    int indexSeg=index/ds->length;
    int node;
    while(treeLevel<=maxHeight){
        //base case. I.e. for 1 segment
        if (treeLevel==0){
            totalLoad=ds->topArray[indexSeg];
            if (totalLoad+1<ds->length*SEG_MAX_LOAD){
                *segments=1;
                *start=indexSeg*ds->length;
                return;
            }
        }   
        else {
            curLength=2*length;
            node=index/curLength;
            //If true, the previous calc. was the left subTree.
            if (node==2*(index/length)){
                totalLoad+=countLoad(ds,node+length,node+curLength);
            }
            else {
                totalLoad+=countLoad(ds,node,node+length);
            }
            if (totalLoad+1<curLength*loadCoefficient(TOTAL_MAX_LOAD,SEG_MAX_LOAD,treeLevel,maxHeight)){
                *segments=curLength/ds->length;
                *start=node*curLength;
                return;
            }
            else {
                //printf("load %d length %d\n",totalLoad,curLength);
                //printf("node %d idea %d\n",node,2*(index/length));
                //printf("l %d cl %d\n",length,curLength);
                length*=2;
            }
        }
        treeLevel++;
    }
    //If nothing is returned at the end of this loop, it means array is too small.
    printf("expired height, must double the array!\n");
    *start = -1;
}

/*! \brief Calculates the correct load coefficient for the current level in the implicit tree
*/
float loadCoefficient(float tMax, float segMax, int lvl, int hMax){
    float result;
    float level=(float)lvl;
    float height = (float)hMax;
    result = tMax + (segMax-tMax)*(height-level)/(height);
    //printf("coef %f\n",result);
    return result;
}

/*! \brief Counts the load from start to end, exclusive at end but inclusive at start.
*/
int countLoad(pArray* ds,int start,int end){
    int count=0;
    int i;
    start/=ds->length;
    end=(end-1)/ds->length;
    /*Needs a less-than-or-equal because the start,end bounds are inclusive! 
    I.e. suppose the start and end are both within one ds->length.
    In such a case, the count should be 1, not zero!*/
    for (i=start;i<=end;i++){ 
        count+=ds->topArray[i];
    }
    return count;
}
/*! \brief Array insert function - put in element, shove everything along to the right.
*/
void insertAndShove(pArray* ds, int index, pItem* newItem){
    int i = index;
    pItem* temp, *temp2;
    temp=ds->array[i];
    ds->array[i]=NULL;
    i++;
    while (temp!=NULL){
        temp2=temp;
        temp=ds->array[i];
        ds->array[i]=temp2;
        i++;
    }
    ds->array[index]=newItem;
}

/*! \brief Prints the Array
*/
void pArray_print(pArray* ds){
    int i;
    int count=0;
    for (i=0;i<ds->maxSize;i++){
        if (ds->array[i]!=NULL){
            printf("[%d:%c]\n",i,*(char*)(ds->array[i]->item));
            //printf("[%d:%p]\n",i,ds->array[i]);
            count++;
        }
    }
    for (i=0;i<ds->topSize;i++){
        printf("[%d]\n",ds->topArray[i]);
    }
    printf("Total: %d/%d\n",count,ds->maxSize);
}

/*! \brief Doubles the array (call when too small!)
*/
void pArray_double(pArray* ds){
    //KL: Seems to trigger all sorts of bugs 7/10/2013
    int i;
    //printf("before double size: %d,%d\n",ds->maxSize,ds->length);
   // pArray_print(ds);
    ds->maxSize*=2;
    ds->length=(int)log(ds->maxSize);
    ds->topSize=ds->maxSize/ds->length;
    ds->array = realloc(ds->array,ds->maxSize*sizeof(pItem*));
    ds->topArray=realloc(ds->topArray,ds->topSize*sizeof(int));
    if (ds->array==NULL || ds->topArray==NULL){
        printf("error allocating\n");
    }
    for (i=0;i<ds->topSize;i++){
        ds->topArray[i]=0;
    }
    for (i=0;i<ds->maxSize;i++){
        if(ds->array[i]!=NULL){
            (ds->topArray[i/ds->length])++;
        }
    }
    //printf("after double size: %d,%d\n",ds->maxSize,ds->length);
    //pArray_print(ds);
    //printf("--------------\n");
}
