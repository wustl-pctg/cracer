#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>


//#include <ds_api.h>

cilk void ds_main(void* hack) {

    int i=0, j=0; 
    int nprocs = ds_work_array.nprocs;
    int batch_size=0;
    void **batch_data = malloc(nprocs * sizeof(void*));
    void (*operation)(void*, size_t);
   
    fprintf(stderr, "Entering DS main, nprocs=%d\n", nprocs);

    //NOTE: no termination condition
    for (i=0; 1; i=(i+1)%nprocs){
        if ( ds_work_array.array[i].status == DS_WAITING ) {
            operation = ds_work_array.array[i].operation;
            batch_data[0]=ds_work_array.array[i].args;
            batch_size=1;
            for (j=(i+1)%nprocs; j!=i; j=(j+1)%nprocs) {
                if (ds_work_array.array[j].status == DS_WAITING
                  && ds_work_array.array[j].operation == operation) {
                    batch_data[batch_size]=ds_work_array.array[j].args;
                    ++batch_size;
                }
            }
            operation (batch_data, batch_size);
            
            ds_work_array.array[i].status = DS_DONE;
        }
    }            
}


cilk int main(int argc, char *argv[])
{
    int i, dummy_counter=0;

    for (i=0; i < 1000000000; ++i)
        ++dummy_counter;

    printf("hello, %d\n", dummy_counter);

    //TODO: figure out if exit here kills cilk threads
    exit(EXIT_SUCCESS);

    return 0;
}
