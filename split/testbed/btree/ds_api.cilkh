#ifndef _DS_API_H
#define _DS_API_H

#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <unistd.h>
#include <sys/time.h>

//current tracks total ops performed, would be nice to get per proc
//however, other DS threads currently aren't actually doing work
int* op_counts;
double group_time=0, execute_time=0, cleanup_time=0;
struct timeval inner_begin, inner_end;
                
//struct _cilk_ds_main_frame{CilkStackFrame header;struct{void*hack;}scope0;struct{int i;int j;int nprocs;int batch_size;void**batch_data;int*batch_indexes;void(*operation)(CilkWorkerState*const ,void**,size_t);}scope1;};

//main thread for primary DS worker to busy loop on ds_work_array
//INPUT: void* hack - unused (makes function def match expected in runtime) 
cilk void ds_main(void* hack) {
    int i=0, j=0; 
    int nprocs = ds_work_array.nprocs;
    int batch_size=0;
    void **batch_data = malloc(nprocs * sizeof(void*)); //args for every job
    int *batch_indexes = malloc(nprocs * sizeof(int)); //reverse proc ptrs
    void (*operation)(CilkWorkerState* const, void**, size_t); //operation(args, batch_size)
    printf ("nprocs = %d\n", nprocs);
    op_counts = malloc(nprocs * sizeof(int));
    op_counts[0]=0;
   
    //NOTE: no termination condition
    for (i=0; 1; i=(i+1)%nprocs){
        //for (j=0; j < nprocs*sizeof(BatchOp); j+=64) {
        //    __builtin_prefetch(((char*)ds_work_array.array),0,1); 
        //}
        if ( ds_work_array.array[i].status == DS_WAITING ) { //start new batch
            gettimeofday(&inner_begin, NULL);
            operation = ds_work_array.array[i].operation; 
            batch_data[0]=ds_work_array.array[i].args; 
            batch_size=1; 
            batch_indexes[0]=i;
            //loop through work array again to fill batch
            for (j=(i+1)%nprocs; j!=i; j=(j+1)%nprocs) {
                if (ds_work_array.array[j].status == DS_WAITING
                  && ds_work_array.array[j].operation == operation) {
                    batch_data[batch_size]=ds_work_array.array[j].args;
                    batch_indexes[batch_size]=j;
                    ++batch_size;
                }
            }
            printf("Starting batch size: %d\n", batch_size);
            //for (j=0; j < batch_size; ++j) {
            //    __builtin_prefetch(&ds_work_array.array[batch_indexes[j]].status,1,3); 
            //}
            gettimeofday(&inner_end, NULL);
            group_time += inner_end.tv_sec*1000000 +inner_end.tv_usec -
                (inner_begin.tv_sec*1000000 + inner_begin.tv_usec);
            //call the actual operation on batch data
            gettimeofday(&inner_begin, NULL);
            printf("calling operation\n");
            ds_main_status = DS_WAITING;

            {
                extern struct _cilk_ds_main_frame*_cilk_frame;
                //_cilk_frame->header.entry=1;
                //_cilk_frame->scope0.batch_data=batch_data;
                //_cilk_frame->scope0.batch_size=batch_size;
                CILK2C_BEFORE_SPAWN_FAST();
                CILK2C_PUSH_FRAME(_cilk_frame);
                operation (_cilk_ws, batch_data, batch_size);
                CILK2C_XPOP_FRAME_NORESULT(_cilk_frame,0);
                CILK2C_AFTER_SPAWN_FAST();
            }

            ds_main_status = DS_DONE;
            printf("finished operation\n");
            gettimeofday(&inner_end, NULL);
            execute_time += inner_end.tv_sec*1000000 +inner_end.tv_usec -
                (inner_begin.tv_sec*1000000 + inner_begin.tv_usec);
            //use reverse proc ptrs to clean up wait flags
            gettimeofday(&inner_begin, NULL);
            for (j=0; j < batch_size; ++j) {
                ds_work_array.array[batch_indexes[j]].status = DS_DONE;
            }
            gettimeofday(&inner_end, NULL);
            cleanup_time += inner_end.tv_sec*1000000 +inner_end.tv_usec -
                (inner_begin.tv_sec*1000000 + inner_begin.tv_usec);

        }
    }            

    return;
}
#endif
