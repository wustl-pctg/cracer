#ifndef _DS_API_H
#define _DS_API_H

#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <unistd.h>
#include <sys/time.h>

//generalized macro to put operation and arguments into work_array then wait
#define BATCH(f,a) ds_work_array.array[_cilk_ws->self].operation=(f); \
    ds_work_array.array[_cilk_ws->self].args=(a); \
    ds_work_array.array[_cilk_ws->self].status=DS_WAITING; \
    while(ds_work_array.array[_cilk_ws->self].status==DS_WAITING) {;}

//current tracks total ops performed, would be nice to get per proc
//however, other DS threads currently aren't actually doing work
int* op_counts;
double group_time=0, execute_time=0, cleanup_time=0;
struct timeval inner_begin, inner_end;

//main thread for primary DS worker to busy loop on ds_work_array
//INPUT: void* hack - unused (makes function def match expected in runtime) 
cilk void ds_main(void* hack) {
    int i=0, j=0; 
    int nprocs = ds_work_array.nprocs;
    int batch_size=0;
    void **batch_data = malloc(nprocs * sizeof(void*)); //args for every job
    int *batch_indexes = malloc(nprocs * sizeof(int)); //reverse proc ptrs
    void (*operation)(void**, size_t); //operation(args, batch_size)
    printf ("nprocs = %d\n", nprocs);
    op_counts = malloc(nprocs * sizeof(int));
    op_counts[0]=0;
   
    //NOTE: no termination condition
    for (i=0; 1; i=(i+1)%nprocs){
        //for (j=0; j < nprocs*sizeof(BatchOp); j+=64) {
        //    __builtin_prefetch(((char*)ds_work_array.array),0,1); 
        //}
        if ( ds_work_array.array[i].status == DS_WAITING ) { //start new batch
            gettimeofday(&inner_begin, NULL);
            operation = ds_work_array.array[i].operation; 
            batch_data[0]=ds_work_array.array[i].args; 
            batch_size=1; 
            batch_indexes[0]=i;
            //loop through work array again to fill batch
            for (j=(i+1)%nprocs; j!=i; j=(j+1)%nprocs) {
                if (ds_work_array.array[j].status == DS_WAITING
                  && ds_work_array.array[j].operation == operation) {
                    batch_data[batch_size]=ds_work_array.array[j].args;
                    batch_indexes[batch_size]=j;
                    ++batch_size;
                }
            }
            //for (j=0; j < batch_size; ++j) {
            //    __builtin_prefetch(&ds_work_array.array[batch_indexes[j]].status,1,3); 
            //}
            gettimeofday(&inner_end, NULL);
            group_time += inner_end.tv_sec*1000000 +inner_end.tv_usec -
                (inner_begin.tv_sec*1000000 + inner_begin.tv_usec);
            //call the actual operation on batch data
            gettimeofday(&inner_begin, NULL);
            operation (batch_data, batch_size);
            gettimeofday(&inner_end, NULL);
            execute_time += inner_end.tv_sec*1000000 +inner_end.tv_usec -
                (inner_begin.tv_sec*1000000 + inner_begin.tv_usec);
            //use reverse proc ptrs to clean up wait flags
            gettimeofday(&inner_begin, NULL);
            for (j=0; j < batch_size; ++j) {
                ds_work_array.array[batch_indexes[j]].status = DS_DONE;
            }
            gettimeofday(&inner_end, NULL);
            cleanup_time += inner_end.tv_sec*1000000 +inner_end.tv_usec -
                (inner_begin.tv_sec*1000000 + inner_begin.tv_usec);

        }
    }            
}
#endif
