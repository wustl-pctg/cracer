#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <unistd.h>

#include <ds_api.cilkh> //generalized DS utils + counter defaults

Cilk_lockvar incr_mutex;
int dummy_counter = 0;

//batch function for dummy DS op
//INPUT: batch_data - list of argument lists for individual calls
//       size - size of batch_data
void BatchIncr(void **batch_data, size_t size) {
    int i;
    //cast then dereference first argument (others assumed to be the same)
    int dummy_wait = **((int**)batch_data); 
    //lock to mirror incr version, no actual relevent concurrency
    Cilk_lock(incr_mutex);
    //busy loop to simulate op
    for (i=0; i < dummy_wait; ++i) {
        ++i;
        ++dummy_counter; //moved portion of global inside loop in attempt
        //to address optimization related bug - didn't work   
    }
    dummy_counter+=(size-1)*dummy_wait; //fix dummy_counter for size of batch
    op_counts[0]++; //TODO: want to loop at operations per DS worker here
    Cilk_unlock(incr_mutex);
}

//Concurrent function to add work to ds_work_array global via BATCH macro
//INPUT: dummy_wait - number of increments in busy loop op simulation
cilk void ds_incr(int dummy_wait) {
    BATCH(BatchIncr, (void*)(&dummy_wait));
}


//USAGE: ds_incr [-nproc <total procs>] [-dsratio <ds:total>] [op_iters] [iters]
cilk int main(int argc, char *argv[])
{
    int i, dummy_iters, dummy_wait;

    //grab some command line parameter adjustments if available
    if (argc > 1)
        dummy_wait = atoi(argv[1]);
    else
        dummy_wait = DUMMY_WAIT;
    if (argc > 2)
        dummy_iters = atoi(argv[2]);
    else
        dummy_iters = DUMMY_ITERS;
        

    Cilk_lock_init(incr_mutex);//init lock used to mirror incr

    //spawn all the operations
    for (i=0; i < dummy_iters; ++i) {
        spawn ds_incr(dummy_wait);
    }

    sync;
    
    printf("dummy_counter:%d\n", dummy_counter);
    for (i=0; i < ds_work_array.nprocs; ++i)
        printf("op_counts[%d]:%d\n", i, op_counts[i]);

    exit(EXIT_SUCCESS);

    return 0;
}
