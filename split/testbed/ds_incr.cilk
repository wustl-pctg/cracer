#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>


//#include <ds_api.h>
//#define BATCH(f,a) ds_work_array.array[_cilk_ws->self].operation=(f); \
    printf("%d inserting in work array\n", _cilk_ws->self); \
    ds_work_array.array[_cilk_ws->self].args=(a); \
    ds_work_array.array[_cilk_ws->self].status=DS_WAITING; \
    while(ds_work_array.array[_cilk_ws->self].status==DS_WAITING) { \
        printf("ds_work_array[%d].status = %d\n", _cilk_ws->self, \
            ds_work_array.array[_cilk_ws->self].status);}

#define BATCH(f,a) ds_work_array.array[_cilk_ws->self].operation=(f); \
    ds_work_array.array[_cilk_ws->self].args=(a); \
    ds_work_array.array[_cilk_ws->self].status=DS_WAITING; \
    while(1) { \
        Cilk_lock(status_mutex); \
        if (ds_work_array.array[_cilk_ws->self].status!=DS_WAITING) { \
            Cilk_unlock(status_mutex); \
            break; \
        } \
        Cilk_unlock(status_mutex); \
    } \
 
Cilk_lockvar incr_mutex;
Cilk_lockvar status_mutex;
int dummy_counter = 0;

void BatchIncr(void **batch_data, size_t size) {
    Cilk_lock(incr_mutex);
    dummy_counter+=size;
    Cilk_unlock(incr_mutex);
}

cilk void ds_incr() {
    BATCH(BatchIncr, NULL);
}

cilk void ds_main(void* hack) {

    int i=0, j=0; 
    int nprocs = ds_work_array.nprocs;
    int batch_size=0;
    void **batch_data = malloc(nprocs * sizeof(void*));
    int *batch_indexes = malloc(nprocs * sizeof(int));
    void (*operation)(void*, size_t);
   
    //NOTE: no termination condition
    for (i=0; 1; i=(i+1)%nprocs){
        if ( ds_work_array.array[i].status == DS_WAITING ) {
            //printf("collecting batch\n");
            operation = ds_work_array.array[i].operation;
            batch_data[0]=ds_work_array.array[i].args;
            batch_size=1;
            batch_indexes[0]=i;
            for (j=(i+1)%nprocs; j!=i; j=(j+1)%nprocs) {
                if (ds_work_array.array[j].status == DS_WAITING
                  && ds_work_array.array[j].operation == operation) {
                    batch_data[batch_size]=ds_work_array.array[j].args;
                    batch_indexes[batch_size]=j;
                    ++batch_size;
                }
                //printf("batch_size=%d\n", batch_size);
            }
            //printf("performing batch op\n");
            operation (batch_data, batch_size);
            Cilk_lock(status_mutex);
            for (j=0; j < batch_size; ++j) {
                ds_work_array.array[batch_indexes[j]].status = DS_DONE;
                //printf("set ds_work_array[%d].status = %d\n", batch_indexes[j], DS_DONE); 
            }
            Cilk_unlock(status_mutex);
        }
    }            
}


cilk int main(int argc, char *argv[])
{
    int i;

    Cilk_lock_init(incr_mutex);
    Cilk_lock_init(status_mutex);

    for (i=0; i < 10000000; ++i) {
        spawn ds_incr();
    }

    sync;
    
    exit(EXIT_SUCCESS);

    return 0;
}
