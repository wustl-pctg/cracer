#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <assert.h>
#include <limits.h>

#define MEMCMP_SAME	0
#define READ_ARG 	0
#define WRITE_ARG 	1
#define PARALLEL	10
#define SEQUENTIAL	11
#define RD_INIT_SIZE_1(mem) RD_INIT(mem ,  1)


/**\struct General struct to test
 */
typedef struct test_struct_gen_s {

	void * j;

	int  i;

	double d;

	float f;

	size_t size;
} test_struct_gen;

/**\fn Check_test_struct_equal
 * \brief Checks if all of the variables in the rd_ds-> and the test_struct_gen are the same
 */
inline void  Check_test_struct_equal(void *rd_ds, test_struct_gen * s){
/*
	test_struct_gen tmp;
//	printf("***ignore any race conditions on this line*****( doing memory checks: ");
	/// Note: we may or may not get a race condition here, but were are just checking memory (after sync's anyways)
	READ(rd_ds, tmp);

	/// Check if the content of rd_ds->data match s (passed in param)
	assert(memcmp((void *)&tmp, (void *)s, sizeof(test_struct_gen)) == MEMCMP_SAME);
*/
}


/**\fn Assign_struct_random_vars
 * \brief Assign random variables and allocate variables for members of struct
 */
inline void Assign_struct_random_vars(test_struct_gen * s){

	/// Assign i
	s->i = rand() %100 +1;
	/// Assign d
	s->d = (double)rand()/1000.0;
	/// Assign f
	s->f = (float) rand()/1000.0;
	/// Assign size
	//s->size = sizeof(*s);

}

/// A spawned write helper function
cilk void cilk_write_func(void *rd_ds, test_struct_gen * s, int * result){
	/// Write to rd_ds
	WRITE_b(rd_ds, s, result);

	/// Check test struct equal to passed in race detect data structure
	Check_test_struct_equal(rd_ds, s);
}

/// A spawned read helper function
cilk void cilk_read_func(void *rd_ds, test_struct_gen * s, int * result){
	/// Read from rd_ds and store in tmp rd_ds
	READ_b(rd_ds, s, result);

	/// Compare to test_Struct passed in
	Check_test_struct_equal(rd_ds, s);
}

/// Functions used by rd_parent_child_test
cilk void parent_child_spawned(void * rd_ds, const int op1, const int op2, const int par_flag ){
	/// Create var to store race detection result
	int race_detect_result1 = -1, race_detect_result2 = -1;

	/// Create tmp variables to assign to ds
	test_struct_gen tmp_s;

	/// Give struct random variables and allocate memory to members
	Assign_struct_random_vars(&tmp_s);

	/// Execute first operation
	/// Races possible
	if (op1 == READ_ARG){

		/// Spawn a function that calls read
		spawn cilk_read_func(rd_ds, &tmp_s, &race_detect_result1);

		///Sync if sequential
		if (par_flag == SEQUENTIAL)
		    sync;
	}
	else	{
		/// Spawn a function that calls write
		spawn cilk_write_func(rd_ds, &tmp_s, &race_detect_result1);

		/// Sync if sequential
		if (par_flag == SEQUENTIAL)
		    sync;
	}

	/// Execute second operation
	/// Races possible
	if (op2 == READ_ARG){

		/// Read into tmp structure
		READ_b(rd_ds, &tmp_s, &race_detect_result2);
	}
	else	{
		/// Write into tmp structure
		WRITE_b(rd_ds, &tmp_s, &race_detect_result2);
	}

	//Sync to end parallel threads
	if (par_flag == PARALLEL)
		sync;
	;//printf("RD1: %i, RD2: %i, (RD1 ^ RD2): %i\n", race_detect_result1, race_detect_result2, (race_detect_result1 ^ race_detect_result2));

	/// Check if our race conditions were as expected
	/// Note: This is overly specific, but it will catch errors in the
	/// 	  test itself if the op1/op2 are passed incorrectly
	if ((op1 == READ_ARG && op2 == READ_ARG) || par_flag == SEQUENTIAL )
		assert((race_detect_result1 | race_detect_result2) == 0); ///< No races
	else if (((op1 == READ_ARG  && op2 == WRITE_ARG)
			  || (op1 == WRITE_ARG && op2 == READ_ARG)
			  || (op1 == WRITE_ARG  && op2 == WRITE_ARG) )
			 &&  par_flag == PARALLEL)
		assert((race_detect_result1 ^ race_detect_result2) == 1); ///< Only one had a race

	else
		assert(0); /// Only done if incorrectly passed op1/op2 into function
}
/// End functions used by rd_parent_child_test

/**\fn rd_parent_child_test
 *\brief Tests the operations op1 in the parent and op2 in the child function. First runs sequentially then in parallel.
 *\param op1 either 0 to do a read first or 1 to do a write in the parent
 *\param op2 either 0 to do a read second or 1 to do a write in the child
 */
cilk void rd_parent_child_test(void ** parseqArr){
	/// Run sequentially read/read
	spawn parent_child_spawned(parseqArr[0], READ_ARG, READ_ARG, SEQUENTIAL);sync;

	/// Run sequentially read/write
	spawn parent_child_spawned(parseqArr[1], READ_ARG, WRITE_ARG, SEQUENTIAL);sync;

	/// Run sequentially write/read
	spawn parent_child_spawned(parseqArr[2], WRITE_ARG, READ_ARG, SEQUENTIAL);sync;

	/// Run sequentially write/write
	spawn parent_child_spawned(parseqArr[3], WRITE_ARG, WRITE_ARG, SEQUENTIAL);sync;

	/// Run parallel read/read
	spawn parent_child_spawned(parseqArr[4], READ_ARG, READ_ARG, PARALLEL);sync;

	/// Run parallel read/write
	spawn parent_child_spawned(parseqArr[5], READ_ARG, WRITE_ARG, PARALLEL);sync;

	/// Run parallel write/read
	spawn parent_child_spawned(parseqArr[6], WRITE_ARG, READ_ARG, PARALLEL);sync;

	/// Run parallel write/write
	spawn parent_child_spawned(parseqArr[7], WRITE_ARG, WRITE_ARG, PARALLEL);sync;

} /// End rd_parent_child_test

/// Functions used by rd_same_function_test

cilk void seq_same_func_spawned(void * rd_ds, const int op1, const int op2 ){
	/// Create var to store race detection result
	int race_detect_result = -1;

	/// Create tmp variables to assign to ds
	test_struct_gen tmp_s;

	/// Give struct and union random variables and allocate memory to members
	Assign_struct_random_vars(&tmp_s);
	;//printf("tmp_s: %p with i: %i and size: \n", &tmp_s, tmp_s.i);

	/// Execute first operation
	/// No races expected

	if (op1 == READ_ARG){

		/// Read from tmp structure
		READ_b(rd_ds, &tmp_s, &race_detect_result);
		;//printf("tmp_s: %p with i: %i and size: \n", &tmp_s, tmp_s.i);

		/// Check test struct equal to passed in race detect data structure
		Check_test_struct_equal(rd_ds, &tmp_s);

		/// Assert that no race happened
		assert(race_detect_result == 0);
	}
	else	{
		WRITE_b(rd_ds, &tmp_s, &race_detect_result);

		/// Check test struct equal to passed in race detect data structure
		Check_test_struct_equal(rd_ds, &tmp_s);
		
		/// Assert that no race happened
		assert(race_detect_result == 0);
	}

	/// Reset race detect results
	race_detect_result = -1;

	/// Execute second operation
	/// No races expected
	if (op2 == READ_ARG){

		/// Read from tmp structure
		READ_b(rd_ds, &tmp_s, &race_detect_result);
		;//printf("tmp_s: %p with i: %i and size: \n", &tmp_s, tmp_s.i );

		/// Check test struct equal to passed in race detect data structure
		Check_test_struct_equal(rd_ds, &tmp_s);
		
		/// Assert that no race happened
		assert(race_detect_result == 0);
	}
	else	{

		WRITE_b(rd_ds, &tmp_s, &race_detect_result);
		/// Check test struct equal to passed in race detect data structure
		Check_test_struct_equal(rd_ds, &tmp_s);

		/// Assert that no race happened
		assert(race_detect_result == 0);
	}
}

/// End functions used by rd_same_function_test


/**\fn rd_same_function_test
 *\brief Tests the operations op1 and op2 in that order in the same cilk function. This should be a serial operation -- no races are expected.
 *\param op1 either 0 to do a read first or 1 to do a write first
 *\param op2 either 0 to do a read second or 1 to do a write second
 */
cilk void rd_same_function_test(void ** seqArr){

	/// Run sequentially read/read
	spawn seq_same_func_spawned(seqArr[0], READ_ARG, READ_ARG);sync;

	/// Run sequentially read/write
	spawn seq_same_func_spawned(seqArr[1], READ_ARG, WRITE_ARG);sync;

	/// Run sequentially write/read
	spawn seq_same_func_spawned(seqArr[2], WRITE_ARG, READ_ARG);sync;

	/// Run sequentially write/write
	spawn seq_same_func_spawned(seqArr[3], WRITE_ARG, WRITE_ARG);sync;
}
/// End rd_same_function_test

/// Start rd_cousin_test helper functions

/// A spawned write helper function
cilk void spawn_rd_cousin_write(void *rd_ds, test_struct_gen * s, int * result){
	/// Write to rd_ds
	WRITE_b(rd_ds, s, result);

	/// Check test struct equal to passed in race detect data structure
	Check_test_struct_equal(rd_ds, s);
}

/// A spawned read helper function
cilk void spawn_rd_cousin_read(void *rd_ds, test_struct_gen * s, int * result){
    /// Read from rd_ds and store in tmp rd_ds
    READ_b(rd_ds, s, result);

	/// Compare to test_Struct passed in
	Check_test_struct_equal(rd_ds, s);
}

/// Spawned test function
cilk void cousin_sequential(const int op1, const int op2, void * mem_ptr,
							test_struct_gen * s, test_struct_gen * t) {

	/// Booleans to use to check if races are detected
	int race_detected1 = -1, race_detected2 = -1;

	/// Spawn op1, then sync
	if(op1 == WRITE_ARG) {
		spawn spawn_rd_cousin_write(mem_ptr, s, &race_detected1);
	} else {
		spawn spawn_rd_cousin_read(mem_ptr, s, &race_detected1);
	} sync;

	/// Spawn op2, then sync
	if(op2 == WRITE_ARG) {
		spawn spawn_rd_cousin_write(mem_ptr, t, &race_detected2);
	} else {
		spawn spawn_rd_cousin_read(mem_ptr, t, &race_detected2);
	} sync;

	/// Confirm no race was found
	;//printf("race_detected1: %i ************************************\n", race_detected1);
	assert(race_detected1 == 0);
	assert(race_detected2 == 0);
}

cilk void cousin_parallel(const int op1, const int op2, void * mem_ptr,
						  test_struct_gen * s, test_struct_gen * t) {

	/// Booleans to use to check if races are detected
	int race_detected1 = -1, race_detected2 = -1;

	/// Spawn op1 *DON'T SYNC*
	if(op1 == WRITE_ARG) {
		spawn spawn_rd_cousin_write(mem_ptr, s, &race_detected1);
	} else {
		spawn spawn_rd_cousin_read(mem_ptr, s, &race_detected1);
	}

	/// Spawn op2
	if(op2 == WRITE_ARG) {
		spawn spawn_rd_cousin_write(mem_ptr, t, &race_detected2);
	} else {
		spawn spawn_rd_cousin_read(mem_ptr, t, &race_detected2);
	}

	/// Now Sync
	sync;

	/// If both are reads, it shouldn't be a race condition
	if( op1 == READ_ARG && op2 == READ_ARG ) {
		assert(race_detected1 == 0);
		assert(race_detected2 == 0);
		return;

	} else

		/// A race should be found, however, we have no way of
		/// knowing which (if at all) will detect the race
		assert( (race_detected1 ^ race_detected2) == 1); ///< Exactly one should be true

}

/// End helper functions for rd_cousin_test
/// Start rd_cousin_test

cilk void rd_cousin_test(void ** parseqArr) {

	/// Declare various empty structs for passing into the functions
	test_struct_gen a,b,c,d;
	test_struct_gen e,f,g,h;

	/// Instantiate all of the dummy structs for passing
	Assign_struct_random_vars(&a);
	Assign_struct_random_vars(&b);
	Assign_struct_random_vars(&c);
	Assign_struct_random_vars(&d);
	Assign_struct_random_vars(&e);
	Assign_struct_random_vars(&f);
	Assign_struct_random_vars(&g);
	Assign_struct_random_vars(&h);

	/// Four sets of sequential cousin tests
	spawn cousin_sequential(READ_ARG, READ_ARG, parseqArr[0] , &a, &b); sync;

	spawn cousin_sequential(READ_ARG, WRITE_ARG, parseqArr[1] , &c, &d); sync;

	spawn cousin_sequential(WRITE_ARG, READ_ARG,  parseqArr[2], &e, &f); sync;

	spawn cousin_sequential(WRITE_ARG, WRITE_ARG,  parseqArr[3], &g, &h); sync;

	/// Redefine all the dummy structs
	Assign_struct_random_vars(&a);
	Assign_struct_random_vars(&b);
	Assign_struct_random_vars(&c);
	Assign_struct_random_vars(&d);
	Assign_struct_random_vars(&e);
	Assign_struct_random_vars(&f);
	Assign_struct_random_vars(&g);
	Assign_struct_random_vars(&h);

	/// Four sets of parallel cousin tests - All races but first
	spawn cousin_parallel(READ_ARG, READ_ARG,   parseqArr[4], &a, &b); sync;

	spawn cousin_parallel(READ_ARG, WRITE_ARG,   parseqArr[5], &c, &d); sync;

	spawn cousin_parallel(WRITE_ARG, READ_ARG,   parseqArr[6], &e, &f); sync;

	spawn cousin_parallel(WRITE_ARG, WRITE_ARG,   parseqArr[7], &g, &h); sync;

}
/// End rd_cousin_test


/// Functions used by rd_gparent_gchild_test
cilk void cilk_write_func_nest(void *rd_ds, test_struct_gen *s, int * result){
	spawn cilk_write_func(rd_ds, s, result);
	//sync;
}

cilk void cilk_read_func_nest(void *rd_ds, test_struct_gen *s, int * result){
	spawn cilk_read_func(rd_ds, s, result);
	//sync;
}

cilk void gparent_gchild_spawned(void * rd_ds, const int op1, const int op2){
	/// Create var to store race detection result
	int race_detect_result1 = -1, race_detect_result2 = -1;

	/// Create tmp variables to assign to ds
	test_struct_gen tmp_s;

	/// Give struct and union random variables and allocate memory to members
	Assign_struct_random_vars(&tmp_s);

	/// Execute first operation
	/// Races possible
	if (op1 == READ_ARG){

		/// Spawn a function that calls read
		spawn cilk_read_func_nest(rd_ds, &tmp_s, &race_detect_result1);

	}
	else	{
		/// Spawn a function that calls write
		spawn cilk_write_func_nest(rd_ds, &tmp_s, &race_detect_result1);

	}

	/// Execute second operation
	/// Races possible
	if (op2 == READ_ARG){
		/// Read into tmp structure
		READ_b(rd_ds, &tmp_s, &race_detect_result2);
	}
	else	{
		/// Write into tmp structure
		WRITE_b(rd_ds, &tmp_s, &race_detect_result2);
	}

	//Sync to end parallel threads
	sync;

	;//printf("RD1: %i, RD2: %i, \n", race_detect_result1, race_detect_result2);

	/// Check if our race conditions were as expected
	/// Note: This is overly specific, but it will catch errors in the
	/// 	  test itself if the op1/op2 are passed incorrectly
	if (op1 == READ_ARG && op2 == READ_ARG)
		assert((race_detect_result1 | race_detect_result2) == 0); /// No races
	else if (  (op1 == READ_ARG  && op2 == WRITE_ARG)
			   || (op1 == WRITE_ARG && op2 == READ_ARG)
			   || (op1 == WRITE_ARG  && op2 == WRITE_ARG))
		assert((race_detect_result1 ^ race_detect_result2) == 1); /// Only one had a race
	else
		assert(0); /// Only done if incorrectly passed op1/op2 into function

}
/// End functions used by rd_parent_child_test


cilk void rd_gparent_gchild_test(void ** parseqArr){

	/// Run sequentially read/read
	spawn gparent_gchild_spawned(parseqArr[0], READ_ARG, READ_ARG);sync;

	/// Run sequentially read/write
	spawn gparent_gchild_spawned(parseqArr[1], READ_ARG, WRITE_ARG);sync;

	/// Run sequentially write/read
	spawn gparent_gchild_spawned(parseqArr[2], WRITE_ARG, READ_ARG);sync;

	/// Run sequentially write/write
	spawn gparent_gchild_spawned(parseqArr[3], WRITE_ARG, WRITE_ARG);sync;

	/// Run parallel read/read
	spawn gparent_gchild_spawned(parseqArr[4], READ_ARG, READ_ARG);sync;

	/// Run parallel read/write
	spawn gparent_gchild_spawned(parseqArr[5], READ_ARG, WRITE_ARG);sync;

	/// Run parallel write/read
	spawn gparent_gchild_spawned(parseqArr[6], WRITE_ARG, READ_ARG);sync;

	/// Run parallel write/write
	spawn gparent_gchild_spawned(parseqArr[7], WRITE_ARG, WRITE_ARG);sync;

}


///  Start functions for rd_huge_test

cilk void recursive_call_sequential(void * mem_ptr, int decrement_counter, const int op1, const int op2, test_struct_gen * s, test_struct_gen * t) {
	int race_detected1 = -1, race_detected2 = -1;
	
	// printf("Seq: counter is %i\n", decrement_counter);
	if(decrement_counter <= 1)
	{
		if(op1 == WRITE_ARG) {
			spawn spawn_rd_cousin_write(mem_ptr, s, &race_detected1);
		} else {
			spawn spawn_rd_cousin_read(mem_ptr, s, &race_detected1);
		} sync; //!< Synced here

		/// Now spawn again
		if(op2 == WRITE_ARG) {
			spawn spawn_rd_cousin_write(mem_ptr, t, &race_detected2);
		} else {
			spawn spawn_rd_cousin_read(mem_ptr, t, &race_detected2);

		} sync;

		// DOESN"T WORK assert(!race_detected1 && !race_detected2);
		return;
	}
	else {
		--(decrement_counter);
		spawn recursive_call_sequential(mem_ptr, decrement_counter, op1, op2, s, t);
		spawn recursive_call_sequential(mem_ptr, decrement_counter, op1, op2, s, t);
		return;
	}
	
}

cilk void recursive_call_parallel(void * mem_ptr, int decrement_counter, const int op1, const int op2, test_struct_gen * s, test_struct_gen * t) {

	int race_detected1 = -1, race_detected2 = -1;
	if(decrement_counter <= 1)
	{
		if(op1 == WRITE_ARG) {
			spawn spawn_rd_cousin_write(mem_ptr, s, &race_detected1);
		} else {
			spawn spawn_rd_cousin_read(mem_ptr, s, &race_detected1);
		}

		/// Spawn op2, then sync
		if(op2 == WRITE_ARG) {
			spawn spawn_rd_cousin_write(mem_ptr, t, &race_detected2);
		} else {
			spawn spawn_rd_cousin_read(mem_ptr, t, &race_detected2);
		} sync;

		// DOESN"T WORKassert( (op1 == READ_ARG && op2 == READ_ARG) || ((race_detected1 ^ race_detected2) == 1));
		
		return;
	}
	else {
		--(decrement_counter);
		spawn recursive_call_parallel(mem_ptr, decrement_counter, op1, op2, s, t);
		spawn recursive_call_parallel(mem_ptr, decrement_counter, op1, op2, s, t);
		return;
	}
	
}


/* So Alex, I'm not sure if I did this correctly at all... The biggest problem
is I don't know "the solution" to what races we'd expect.  So at this point, there are no asserts
for this test.

I also did some testing without this function.  Everything will work (LL and bender) sequentially but
with bender, in parallel, there was a weird error in the write/read case of rd_gparent... test.
Bascially, both RD1 and RD2 were 1, so they somehow both detected races.. I tried to debug but made
no progress as to how that could be possible. However, I did fix a few bugs I came across in sched
and it seems our splitting changes are working as expected (i.e. infrequent and faster).
*/
cilk void rd_huge_test(void ** parseqArr) {
	
	/// Declare test_struct_gen variable(s)
	test_struct_gen a, b, c, d;
	test_struct_gen e, f, g, h;
	
	/// Counters
	int counter1 = 14, counter2 = 14, counter3 = 14,
		counter4 = 14, counter5 = 14, counter6 = 14,
		counter7 = 14, counter8 = 14;

	/// instantiate test_struct_gen variables(s)
	Assign_struct_random_vars(&a);
	Assign_struct_random_vars(&b);
	Assign_struct_random_vars(&c);
	Assign_struct_random_vars(&d);
	Assign_struct_random_vars(&e);
	Assign_struct_random_vars(&f);
	Assign_struct_random_vars(&g);
	Assign_struct_random_vars(&h);

	/// Sequential tests
	// printf("*********Entering first recursive_call_sequential\n");
	spawn recursive_call_sequential(parseqArr[0], counter1, READ_ARG, READ_ARG, &a, &b); sync;
	
	spawn recursive_call_sequential(parseqArr[1], counter2, READ_ARG, WRITE_ARG, &c, &d); sync;
	
	spawn recursive_call_sequential(parseqArr[2], counter3, WRITE_ARG, READ_ARG, &e, &f); sync;
	
	spawn recursive_call_sequential(parseqArr[3], counter4, WRITE_ARG, WRITE_ARG, &g, &h); sync;

	/// Redefine all the dummy structs
	Assign_struct_random_vars(&a);
	Assign_struct_random_vars(&b);
	Assign_struct_random_vars(&c);
	Assign_struct_random_vars(&d);
	Assign_struct_random_vars(&e);
	Assign_struct_random_vars(&f);
	Assign_struct_random_vars(&g);
	Assign_struct_random_vars(&h);

	/// Parallel tests
	spawn recursive_call_parallel(parseqArr[4], counter5, READ_ARG, READ_ARG, &a, &b); sync;
	
	spawn recursive_call_parallel(parseqArr[5], counter6, READ_ARG, WRITE_ARG, &c, &d); sync;
	
	spawn recursive_call_parallel(parseqArr[6], counter7, WRITE_ARG, READ_ARG, &e, &f); sync;
	
	spawn recursive_call_parallel(parseqArr[7], counter8, WRITE_ARG, WRITE_ARG, &g, &h); sync;
	
}


cilk int main(int argv, char* argc){

	/// Declare the four types of sequential race detect variables
	void * seq_r_r, * seq_r_w, *seq_w_r, *seq_w_w;

	/// Declare the four types of parallel race detect variables
	void * par_r_r, * par_r_w, *par_w_r, *par_w_w;

	/// Arrays to be passed into functions
	void **seqArr = malloc(4*sizeof(void*)), **parseqArr = malloc(8 * sizeof(void *));

	/// Instantiate all of the race detect structures
	seq_r_r = RD_INIT_SIZE_1(test_struct_gen);
	seq_r_w = RD_INIT_SIZE_1(test_struct_gen);
	seq_w_r = RD_INIT_SIZE_1(test_struct_gen);
	seq_w_w = RD_INIT_SIZE_1(test_struct_gen);
	par_r_r = RD_INIT_SIZE_1(test_struct_gen);
	par_r_w = RD_INIT_SIZE_1(test_struct_gen);
	par_w_r = RD_INIT_SIZE_1(test_struct_gen);
	par_w_w = RD_INIT_SIZE_1(test_struct_gen);

	/// Sequential array
	seqArr[0] = seq_r_r;
	seqArr[1] = seq_r_w;
	seqArr[2] = seq_w_r;
	seqArr[3] = seq_w_w;

	/// Array for all of them
	parseqArr[0] = seq_r_r;
	parseqArr[1] = seq_r_w;
	parseqArr[2] = seq_w_r;
	parseqArr[3] = seq_w_w;
	parseqArr[4] = par_r_r;
	parseqArr[5] = par_r_w;
	parseqArr[6] = par_w_r;
	parseqArr[7] = par_w_w;

	srand(time(NULL));

	/// Case 1:
	/// This function tests each combination of read/write
	/// within the same spawned function. None of these should
	/// have any races within them, as they are all executed serially.
	spawn rd_same_function_test(seqArr);
	sync;

	/// Case 2:
	/// These functions tests each combination of read/write
	/// within a parent function and its child, in both the serial and
	/// parallel case.
	spawn rd_parent_child_test(parseqArr);
	sync;

	/// Case 3:
	/// These functions test each combination of read/write
	/// within a parent function and its grandchildren and great grandchildren
	/// in both the serial and parallel case.
	spawn rd_gparent_gchild_test(parseqArr);
	sync;

	/// Case 4:
	/// These functions test each combination of read/write
	/// within cousin nodes and sibling nodes
	/// in both the serial and parallel case.
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	spawn rd_same_function_test(seqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_parent_child_test(parseqArr);
	sync;
	spawn rd_cousin_test(parseqArr);
	sync;

	/// Case 5;
	/// These functions each contain read/write
	/// after a web of ~50,000 spawns to check
	/// if ordering maintains in crazy conditionds
	spawn rd_huge_test(parseqArr);
	sync;

	;//printf("Test completed fully as expected. No errors [before the frees...]\n");

	/// Free all race detect data structures
	RD_free(_cilk_ws, seq_r_r);
	RD_free(_cilk_ws, seq_r_w);
	RD_free(_cilk_ws, seq_w_r);
	RD_free(_cilk_ws, seq_w_w);
	RD_free(_cilk_ws, par_r_r);
	RD_free(_cilk_ws, par_r_w);
	RD_free(_cilk_ws, par_w_r);
	RD_free(_cilk_ws, par_w_w);
	
	free(seqArr);
	free(parseqArr);

	printf("Test completed fully as expected. No errors.\n");

	return 0;
}
