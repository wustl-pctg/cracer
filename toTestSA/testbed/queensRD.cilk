/*!Queens adapted to detect races
 *
 * Adaptations by Shane Deiley
 */

#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>

/*
 * <a> contains array of <n> queen positions.  Returns 1
 * if none of the queens conflict, and returns 0 otherwise.
 */
int ok(int n, char *a)
{
	int i, j;
	char p, q;

	for (i = 0; i < n; i++) {
		p = a[i];

		for (j = i + 1; j < n; j++) {
			q = a[j];
			if (q == p || q == p - (j - i) || q == p + (j - i))
				return 0;
		}
	}
	return 1;
}

/*
 * <a> is an array of <j> numbers.  The entries of <a> contain
 * queen positions already set.  If there is any extension of <a>
 * to a complete <n> queen setting, returns one of these queen
 * settings (allocated from the heap).  Otherwise, returns NULL.
 * Does not side-effect <a>.
 */

cilk char *nqueens(int n, int j, char *a)
{
	char *b;
	char *done = NULL;
	int i;

	inlet void catch(char *res) {
		if (res != NULL) {
			if (done == NULL)
				done = res;
			abort;
		}
	} if (n == j) {
		/* put good solution in heap, return pointer to it. */
		b = malloc(n * sizeof(char));

		return b;
	}

	/* try each possible position for queen <j> */
	for (i = 0; i < n; i++) {
		/* allocate a temporary array and copy <a> into it */
		b = Cilk_alloca((j + 1) * sizeof(char));
		memcpy(b, a, j * sizeof(char));
		b[j] = i;
		if (ok(j + 1, b))
			catch(spawn nqueens(n, j + 1, b));

		if (done != NULL)
			break;
	}
	sync;

	return done;
}

cilk int cilk_main(int argc, char *argv[])
{
	int n, i;
	char * charptr_a, a;


	if (argc < 2) {
		printf("%s: number of queens required\n", argv[0]);
		return 1;
	}
	if (argc > 2)
		printf("%s: extra arguments being ignored\n", argv[0]);

	n = atoi(argv[1]);

	//!First change, a is RD_Memory_struct holder
	charptr_a = RD_INIT(char,n);
	// a = Cilk_alloca(n * sizeof(char));

	printf("running queens %d\n", n);

	a = spawn nqueens(n, 0, (char*)Race_detect_read(_cilk_ws, charptr_a, __FUNCTION__, __LINE__) );
	WRITE(charptr_a,a); //!<Write a's holding value to chaptr;
	sync;

	//!Since we want to check a ptr, READ macro is a bit different
	if ( (char*)Race_detect_read(_cilk_ws, charptr_a, __FUNCTION__, __LINE__) != NULL) {

		//!Instead pass struct ptr
		if (!ok(n, (char*)Race_detect_read(_cilk_ws, charptr_a, __FUNCTION__, __LINE__) )
			printf("RESULT IS BAD!!!\n");

		printf("result: ");

		for (i = 0; i < n; i++) {
			a = (char*)Race_detect_read(_cilk_ws, charptr_a, __FUNCTION__, __LINE__);
			printf("%2d ", a[i]);
		}
		
		printf("\n");
	} else
		printf("no possible result!\n");
	return 0;
}
