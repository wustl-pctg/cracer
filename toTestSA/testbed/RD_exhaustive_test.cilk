#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <assert.h>
#include <limits.h>

#define MEMCMP_SAME	0
#define READ_ARG 	0
#define WRITE_ARG 	1
#define PARALLEL	10
#define SEQUENTIAL	11
#define RD_INIT_SIZE_1(mem) RD_INIT(mem ,  1)


/**\struct General struct to test
 */
typedef struct test_struct_gen_s {

	int  i;

	double d;

	float f;

	size_t size;
} test_struct_gen;

/**\fn Check_test_struct_equal
 * \brief Checks if all of the variables in the rd_ds-> and the test_struct_gen are the same
 */
cilk void  Check_test_struct_equal(void *rd_ds, test_struct_gen * s){

	test_struct_gen tmp;
//	printf("***ignore any race conditions on this line*****( doing memory checks: ");
	/// Note: we may or may not get a race condition here, but were are just checking memory (after sync's anyways)
	tmp = READ(rd_ds, test_struct_gen);	

	/// Check if the content of rd_ds->data match s (passed in param) 
	assert(memcmp((void *)&tmp, (void *)s, sizeof(test_struct_gen)) == MEMCMP_SAME);
}


/**\fn Assign_struct_random_vars
 * \brief Assign random variables and allocate variables for members of struct
 */
inline void Assign_struct_random_vars(test_struct_gen * s){

	/// Assign i
	s->i = rand() %100 +1;
	/// Assign d
	s->d = (double)rand()/1000.0;
	/// Assign f
	s->f = (float) rand()/1000.0;
	/// Assign size
	s->size = sizeof(*s);
	
}

/// A spawned write helper function
cilk void cilk_write_func(void *rd_ds, test_struct_gen * s, int * result){
	/// Write to rd_ds
	WRITE_b(rd_ds, s, result);
	
	/// Check test struct equal to passed in race detect data structure
	spawn Check_test_struct_equal(rd_ds, s);
	sync;
}

/// A spawned read helper function
cilk void cilk_read_func(void *rd_ds, test_struct_gen * s, int * result){
	/// Read from rd_ds and store in tmp rd_ds
	*s = READ_b(rd_ds, test_struct_gen, result);

	/// Compare to test_Struct passed in
	spawn Check_test_struct_equal(rd_ds, s);
	sync;
}

/// Functions used by rd_parent_child_test
cilk void parent_child_spawned(void * rd_ds, const int op1, const int op2, const int par_flag ){
	/// Create var to store race detection result
	int race_detect_result1 = -1, race_detect_result2 = -1;

	/// Create tmp variables to assign to ds
	test_struct_gen tmp_s;
	
	/// Give struct random variables and allocate memory to members
	Assign_struct_random_vars(&tmp_s);

	/// Execute first operation	
	/// Races possible
	if (op1 == READ_ARG){
		
		/// Spawn a function that calls read
		spawn cilk_read_func(rd_ds, &tmp_s, &race_detect_result1);
		
		///Sync if sequential
		if (par_flag == SEQUENTIAL)
		    sync;
	}
	else	{
		/// Spawn a function that calls write
		spawn cilk_write_func(rd_ds, &tmp_s, &race_detect_result1);
		
		/// Sync if sequential
		if (par_flag == SEQUENTIAL)
		    sync;
	}

	/// Execute second operation
	/// Races possible
	if (op2 == READ_ARG){

		/// Read into tmp structure
		tmp_s = READ_b(rd_ds,test_struct_gen, &race_detect_result2);
	}
	else	{
		/// Write into tmp structure
		WRITE_b(rd_ds, &tmp_s, &race_detect_result2); 
	}

	//Sync to end parallel threads
	if (par_flag == PARALLEL)
		sync;
	printf("RD1: %i, RD2: %i, (RD1 ^ RD2): %i\n",
		   race_detect_result1, race_detect_result2,
		   (race_detect_result1 ^ race_detect_result2));
	/// Check if our race conditions were as expected
	/// Note: This is overly specific, but it will catch errors in the
	/// 	  test itself if the op1/op2 are passed incorrectly
	if ((op1 == READ_ARG && op2 == READ_ARG) || par_flag == SEQUENTIAL )
		assert((race_detect_result1 | race_detect_result2) == 0); ///< No races
	else if (((op1 == READ_ARG  && op2 == WRITE_ARG) 
			  || (op1 == WRITE_ARG && op2 == READ_ARG)  
			  || (op1 == WRITE_ARG  && op2 == WRITE_ARG) ) 
			 &&  par_flag == PARALLEL)
		assert((race_detect_result1 ^ race_detect_result2) == 1); ///< Only one had a race
	
	else 
		assert(0); /// Only done if incorrectly passed op1/op2 into function
}
/// End functions used by rd_parent_child_test
	
/**\fn rd_parent_child_test
 *\brief Tests the operations op1 in the parent and op2 in the child function. First runs sequentially then in parallel.
 *\param op1 either 0 to do a read first or 1 to do a write in the parent
 *\param op2 either 0 to do a read second or 1 to do a write in the child
 */
cilk void rd_parent_child_test(){
	/// Declare the four types of sequential race detect variables
	void * seq_r_r, * seq_r_w, *seq_w_r, *seq_w_w;
	
	/// Declare the four types of parallel race detect variables
	void * par_r_r, * par_r_w, *par_w_r, *par_w_w;
	
	/// Instantiate all of the race detect structures 
	seq_r_r = RD_INIT_SIZE_1(test_struct_gen);
	seq_r_w = RD_INIT_SIZE_1(test_struct_gen);
	seq_w_r = RD_INIT_SIZE_1(test_struct_gen);
	seq_w_w = RD_INIT_SIZE_1(test_struct_gen);
	par_r_r = RD_INIT_SIZE_1(test_struct_gen);
	par_r_w = RD_INIT_SIZE_1(test_struct_gen);
	par_w_r = RD_INIT_SIZE_1(test_struct_gen);
	par_w_w = RD_INIT_SIZE_1(test_struct_gen);

	/// Run sequentially read/read
	spawn parent_child_spawned(seq_r_r, READ_ARG, READ_ARG, SEQUENTIAL);sync;

	/// Run sequentially read/write
	spawn parent_child_spawned(seq_r_w, READ_ARG, WRITE_ARG, SEQUENTIAL);sync;

	/// Run sequentially write/read
	spawn parent_child_spawned(seq_w_r, WRITE_ARG, READ_ARG, SEQUENTIAL);sync;

	/// Run sequentially write/write
	spawn parent_child_spawned(seq_w_w, WRITE_ARG, WRITE_ARG, SEQUENTIAL);sync;

	/// Run parallel read/read
	spawn parent_child_spawned(par_r_r, READ_ARG, READ_ARG, PARALLEL);sync;

	/// Run parallel read/write
	spawn parent_child_spawned(par_r_w, READ_ARG, WRITE_ARG, PARALLEL);sync;

	/// Run parallel write/read
	spawn parent_child_spawned(par_w_r, WRITE_ARG, READ_ARG, PARALLEL);sync;

	/// Run parallel write/write
	spawn parent_child_spawned(par_w_w, WRITE_ARG, WRITE_ARG, PARALLEL);sync;


	/// Free all race detect data structures
	RD_free(_cilk_ws, seq_r_r);
	RD_free(_cilk_ws, seq_r_w);
	RD_free(_cilk_ws, seq_w_r);
	RD_free(_cilk_ws, seq_w_w);
	RD_free(_cilk_ws, par_r_r);
	RD_free(_cilk_ws, par_r_w);
	RD_free(_cilk_ws, par_w_r);
	RD_free(_cilk_ws, par_w_w);
	
} /// End rd_parent_child_test

/// Functions used by rd_same_function_test

cilk void seq_same_func_spawned(void * rd_ds, const int op1, const int op2 ){
	/// Create var to store race detection result
	int race_detect_result = -1;

	/// Create tmp variables to assign to ds
	test_struct_gen tmp_s;

	/// Give struct and union random variables and allocate memory to members
	Assign_struct_random_vars(&tmp_s);
	printf("tmp_s: %p with i: %i and size: %lu\n", &tmp_s, tmp_s.i, tmp_s.size);

	/// Execute first operation	
	/// No races expected

	if (op1 == READ_ARG){

		/// Read from tmp structure
		tmp_s = READ_b(rd_ds,test_struct_gen, &race_detect_result);
		printf("tmp_s: %p with i: %i and size: %lu\n", &tmp_s, tmp_s.i, tmp_s.size);

		/// Check test struct equal to passed in race detect data structure
		spawn Check_test_struct_equal(rd_ds, &tmp_s);
		sync;

		/// Assert that no race happened
		assert(race_detect_result == 0);
	}
	else	{
		WRITE_b(rd_ds, &tmp_s, &race_detect_result); 

		/// Check test struct equal to passed in race detect data structure
		spawn Check_test_struct_equal(rd_ds, &tmp_s);
		sync; 

		/// Assert that no race happened
		assert(race_detect_result == 0);
	}

	/// Reset race detect results
	race_detect_result = -1;

	/// Execute second operation
	/// No races expected
	if (op2 == READ_ARG){

		/// Read from tmp structure
		tmp_s = READ_b(rd_ds,test_struct_gen, &race_detect_result);
		printf("tmp_s: %p with i: %i and size: %lu\n", &tmp_s, tmp_s.i, tmp_s.size);

		/// Check test struct equal to passed in race detect data structure
		spawn Check_test_struct_equal(rd_ds, &tmp_s);
		sync;

		/// Assert that no race happened
		assert(race_detect_result == 0);
	}
	else	{

		WRITE_b(rd_ds, &tmp_s, &race_detect_result); 
		/// Check test struct equal to passed in race detect data structure
		spawn Check_test_struct_equal(rd_ds, &tmp_s);
		sync;

		/// Assert that no race happened
		assert(race_detect_result == 0);
	}
}

/// End functions used by rd_same_function_test


/**\fn rd_same_function_test
 *\brief Tests the operations op1 and op2 in that order in the same cilk function. This should be a serial operation -- no races are expected.
 *\param op1 either 0 to do a read first or 1 to do a write first
 *\param op2 either 0 to do a read second or 1 to do a write second
 */
cilk void rd_same_function_test(){

	/// Declare the four types of sequential race detect variables
	void * seq_r_r, * seq_r_w, *seq_w_r, *seq_w_w;
	
	
	/// Instantiate all of the race detect structures 
	seq_r_r = RD_INIT_SIZE_1(test_struct_gen);
	seq_r_w = RD_INIT_SIZE_1(test_struct_gen);
	seq_w_r = RD_INIT_SIZE_1(test_struct_gen);
	seq_w_w = RD_INIT_SIZE_1(test_struct_gen);

	/// Run sequentially read/read
	spawn seq_same_func_spawned(seq_r_r, READ_ARG, READ_ARG);sync;

	/// Run sequentially read/write
	spawn seq_same_func_spawned(seq_r_w, READ_ARG, WRITE_ARG);sync;

	/// Run sequentially write/read
	spawn seq_same_func_spawned(seq_w_r, WRITE_ARG, READ_ARG);sync;

	/// Run sequentially write/write
	spawn seq_same_func_spawned(seq_w_w, WRITE_ARG, WRITE_ARG);sync;

	/// Free all race detect data structures
	RD_free(_cilk_ws, seq_r_r);
	RD_free(_cilk_ws, seq_r_w);
	RD_free(_cilk_ws, seq_w_r);
	RD_free(_cilk_ws, seq_w_w);
}
/// End rd_same_function_test

/// Start rd_cousin_test helper functions

/// A spawned write helper function
cilk void spawn_rd_cousin_write(void *rd_ds, test_struct_gen * s, int * result){
	/// Write to rd_ds
	WRITE_b(rd_ds, s, result);
	
	/// Check test struct equal to passed in race detect data structure
	spawn Check_test_struct_equal(rd_ds, s);
	sync;
}

/// A spawned read helper function
cilk void spawn_rd_cousin_read(void *rd_ds, test_struct_gen * s, int * result){
    /// Read from rd_ds and store in tmp rd_ds
	*s = READ_b(rd_ds, test_struct_gen, result);

	/// Compare to test_Struct passed in
	spawn Check_test_struct_equal(rd_ds, s);
	sync;
}

/// Spawned test function
cilk void cousin_sequential(const int op1, const int op2, void * mem_ptr,
							test_struct_gen * s, test_struct_gen * t) {

	/// Booleans to use to check if races are detected
	int race_detected1 = -1, race_detected2 = -1;

	/// Spawn op1, then sync
	if(op1 == WRITE_ARG) {
		spawn spawn_rd_cousin_write(mem_ptr, s, &race_detected1);
	} else {
		spawn spawn_rd_cousin_read(mem_ptr, s, &race_detected1);
	} sync;
	
	/// Spawn op2, then sync
	if(op2 == WRITE_ARG) {
		spawn spawn_rd_cousin_write(mem_ptr, t, &race_detected2);
	} else {
		spawn spawn_rd_cousin_read(mem_ptr, t, &race_detected2);
	} sync;

	/// Confirm no race was found
	printf("race_detected1: %i ************************************\n", race_detected1);
	assert(race_detected1 == 0);
	assert(race_detected2 == 0);
}

cilk void cousin_parallel(const int op1, const int op2, void * mem_ptr,
						  test_struct_gen * s, test_struct_gen * t) {

	/// Booleans to use to check if races are detected
	int race_detected1 = -1, race_detected2 = -1;

	/// Spawn op1 *DON'T SYNC*
	if(op1 == WRITE_ARG) {
		spawn spawn_rd_cousin_write(mem_ptr, s, &race_detected1);
	} else {
		spawn spawn_rd_cousin_read(mem_ptr, s, &race_detected1);
	}
	
	/// Spawn op2
	if(op2 == WRITE_ARG) {
		spawn spawn_rd_cousin_write(mem_ptr, t, &race_detected2);
	} else {
		spawn spawn_rd_cousin_read(mem_ptr, t, &race_detected2);
	}

	/// Now Sync
	sync;

	/// If both are reads, it shouldn't be a race condition
	if( op1 == READ_ARG && op2 == READ_ARG ) {
		assert(race_detected1 == 0);
		assert(race_detected2 == 0);
		return;

	} else

		/// A race should be found, however, we have no way of
		/// knowing which (if at all) will detect the race
		assert( (race_detected1 ^ race_detected2) == 1); ///< Exactly one should be true

}

/// End helper functions for rd_cousin_test
/// Start rd_cousin_test

cilk void rd_cousin_test() {

	/// Declare the four types of race detect variables
	/// These will be used in cousins that are sequential
	void * seq_r_r, * seq_r_w, *seq_w_r, *seq_w_w;
	
	/// Declare the four types of parallel race detect variables
	/// These will be used in cousins that are parallel
	void * par_r_r, * par_r_w, *par_w_r, *par_w_w;

	/// Declare various empty structs for passing into the functions
	test_struct_gen a,b,c,d;
	test_struct_gen e,f,g,h;
	
	/// Instantiate all of the race detect structures 
	seq_r_r = RD_INIT_SIZE_1(test_struct_gen);
	seq_r_w = RD_INIT_SIZE_1(test_struct_gen);
	seq_w_r = RD_INIT_SIZE_1(test_struct_gen);
	seq_w_w = RD_INIT_SIZE_1(test_struct_gen);
	par_r_r = RD_INIT_SIZE_1(test_struct_gen);
	par_r_w = RD_INIT_SIZE_1(test_struct_gen);
	par_w_r = RD_INIT_SIZE_1(test_struct_gen);
	par_w_w = RD_INIT_SIZE_1(test_struct_gen);

	/// Instantiate all of the dummy structs for passing 
	Assign_struct_random_vars(&a);	
	Assign_struct_random_vars(&b);	
	Assign_struct_random_vars(&c);	
	Assign_struct_random_vars(&d);	
	Assign_struct_random_vars(&e);	
	Assign_struct_random_vars(&f);	
	Assign_struct_random_vars(&g);	
	Assign_struct_random_vars(&h);	
	
	/// Four sets of sequential cousin tests
	spawn cousin_sequential(READ_ARG, READ_ARG, seq_r_r, &a, &b); sync;

	spawn cousin_sequential(READ_ARG, WRITE_ARG, seq_r_w, &c, &d); sync;

	spawn cousin_sequential(WRITE_ARG, READ_ARG, seq_w_r, &e, &f); sync;
	
	spawn cousin_sequential(WRITE_ARG, WRITE_ARG, seq_w_w, &g, &h); sync;

	/// Redefine all the dummy structs
	Assign_struct_random_vars(&a);	
	Assign_struct_random_vars(&b);	
	Assign_struct_random_vars(&c);	
	Assign_struct_random_vars(&d);	
	Assign_struct_random_vars(&e);	
	Assign_struct_random_vars(&f);	
	Assign_struct_random_vars(&g);	
	Assign_struct_random_vars(&h);	
 
	/// Four sets of parallel cousin tests - All races but first
	spawn cousin_parallel(READ_ARG, READ_ARG, par_r_r, &a, &b); sync;

	spawn cousin_parallel(READ_ARG, WRITE_ARG, par_r_w, &c, &d); sync;

	spawn cousin_parallel(WRITE_ARG, READ_ARG, par_w_r, &e, &f); sync;
	
	spawn cousin_parallel(WRITE_ARG, WRITE_ARG, par_w_w, &g, &h); sync;

	/// Free all race detect data structures
	RD_free(_cilk_ws, seq_r_r);
	RD_free(_cilk_ws, seq_r_w);
	RD_free(_cilk_ws, seq_w_r);
	RD_free(_cilk_ws, seq_w_w);
	RD_free(_cilk_ws, par_r_r);
	RD_free(_cilk_ws, par_r_w);
	RD_free(_cilk_ws, par_w_r);
	RD_free(_cilk_ws, par_w_w);
}
/// End rd_cousin_test


/// Functions used by rd_gparent_gchild_test
cilk void cilk_write_func_nest(void *rd_ds, test_struct_gen *s, int * result){
	spawn cilk_write_func(rd_ds, s, result);
	sync;
}

cilk void cilk_read_func_nest(void *rd_ds, test_struct_gen *s, int * result){
	spawn cilk_read_func(rd_ds, s, result);
	sync;
}

cilk void gparent_gchild_spawned(void * rd_ds, const int op1, const int op2){
	/// Create var to store race detection result
	int race_detect_result1 = -1, race_detect_result2 = -1;

	/// Create tmp variables to assign to ds
	test_struct_gen tmp_s;
	
	/// Give struct and union random variables and allocate memory to members
	Assign_struct_random_vars(&tmp_s);

	/// Execute first operation	
	/// Races possible
	if (op1 == READ_ARG){
		
		/// Spawn a function that calls read
		spawn cilk_read_func_nest(rd_ds, &tmp_s, &race_detect_result1);
		
	}
	else	{
		/// Spawn a function that calls write
		spawn cilk_write_func_nest(rd_ds, &tmp_s, &race_detect_result1);
		
	}

	/// Execute second operation
	/// Races possible
	if (op2 == READ_ARG){
		/// Read into tmp structure
		tmp_s = READ_b(rd_ds,test_struct_gen, &race_detect_result2);
	}
	else	{
		/// Write into tmp structure
		WRITE_b(rd_ds, &tmp_s, &race_detect_result2); 
	}

	//Sync to end parallel threads
	sync;

	/// Check if our race conditions were as expected
	/// Note: This is overly specific, but it will catch errors in the
	/// 	  test itself if the op1/op2 are passed incorrectly
	if (op1 == READ_ARG && op2 == READ_ARG)
		assert((race_detect_result1 | race_detect_result2) == 0); /// No races
	else if (  (op1 == READ_ARG  && op2 == WRITE_ARG) 
			   || (op1 == WRITE_ARG && op2 == READ_ARG)  
			   || (op1 == WRITE_ARG  && op2 == WRITE_ARG))
		assert((race_detect_result1 ^ race_detect_result2) == 1); /// Only one had a race
	else 
		assert(0); /// Only done if incorrectly passed op1/op2 into function

}
/// End functions used by rd_parent_child_test
	

cilk void rd_gparent_gchild_test(){
	/// Declare the four types of sequential race detect variables
	void * seq_r_r, * seq_r_w, *seq_w_r, *seq_w_w;
	
	/// Declare the four types of parallel race detect variables
	void * par_r_r, * par_r_w, *par_w_r, *par_w_w;
	
	/// Instantiate all of the race detect structures 
	seq_r_r = RD_INIT_SIZE_1(test_struct_gen);
	seq_r_w = RD_INIT_SIZE_1(test_struct_gen);
	seq_w_r = RD_INIT_SIZE_1(test_struct_gen);
	seq_w_w = RD_INIT_SIZE_1(test_struct_gen);
	par_r_r = RD_INIT_SIZE_1(test_struct_gen);
	par_r_w = RD_INIT_SIZE_1(test_struct_gen);
	par_w_r = RD_INIT_SIZE_1(test_struct_gen);
	par_w_w = RD_INIT_SIZE_1(test_struct_gen);

	/// Run sequentially read/read
	spawn gparent_gchild_spawned(seq_r_r, READ_ARG, READ_ARG);sync;

	/// Run sequentially read/write
	spawn gparent_gchild_spawned(seq_r_w, READ_ARG, WRITE_ARG);sync;

	/// Run sequentially write/read
	spawn gparent_gchild_spawned(seq_w_r, WRITE_ARG, READ_ARG);sync;

	/// Run sequentially write/write
	spawn gparent_gchild_spawned(seq_w_w, WRITE_ARG, WRITE_ARG);sync;

	/// Run parallel read/read
	spawn gparent_gchild_spawned(par_r_r, READ_ARG, READ_ARG);sync;

	/// Run parallel read/write
	spawn gparent_gchild_spawned(par_r_w, READ_ARG, WRITE_ARG);sync;

	/// Run parallel write/read
	spawn gparent_gchild_spawned(par_w_r, WRITE_ARG, READ_ARG);sync;

	/// Run parallel write/write
	spawn gparent_gchild_spawned(par_w_w, WRITE_ARG, WRITE_ARG);sync;


	/// Free all race detect data structures
	RD_free(_cilk_ws, seq_r_r);
	RD_free(_cilk_ws, seq_r_w);
	RD_free(_cilk_ws, seq_w_r);
	RD_free(_cilk_ws, seq_w_w);
	RD_free(_cilk_ws, par_r_r);
	RD_free(_cilk_ws, par_r_w);
	RD_free(_cilk_ws, par_w_r);
	RD_free(_cilk_ws, par_w_w);
	
}

cilk int main(int argv, char* argc){
	srand(time(NULL));
	/// Case 1:	
	/// This function tests each combination of read/write
	/// within the same spawned function. None of these should
	/// have any races within them, as they are all executed serially.
//	spawn rd_same_function_test();
//	sync;

	/// Case 2:
	/// These functions tests each combination of read/write
	/// within a parent function and its child, in both the serial and
	/// parallel case.	
//	spawn rd_parent_child_test();
//	sync;						

	/// Case 3:
	/// These functions test each combination of read/write
	/// within a parent function and its grandchildren and great grandchildren
	/// in both the serial and parallel case.
//	spawn rd_gparent_gchild_test();
//	sync;

	/// Case 4:
	/// These functions test each combination of read/write
	/// within cousin nodes and sibling nodes
	/// in both the serial and parallel case.
	spawn rd_cousin_test();
	sync;					
	
	
	printf("Test completed fully as expected. No errors.\n");
	return 0;
}
