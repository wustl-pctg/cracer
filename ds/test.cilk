#include <stdio.h>
#include <stdlib.h>
#ifdef CILK
#include <cilk-lib.cilkh>
#endif

#include "common.h"
#include "benchopt.h"
#include "timer.h"
#include "dynarray.cilkh"

#define INIT_SIZE 20000

BenchOptions g_options;
int* g_vals;
int g_num_spots;
DynamicArray g_array;

cilk void set_up(size_t initial_size, size_t num_ops)
{
  int i;
  g_array = da_create();

  for (i = 0; i < initial_size; ++i) {
    spawn da_push_back(g_array, rand());
    sync;
  }

  g_vals = malloc(sizeof(int) * num_ops * g_num_spots);
  if (!g_vals) fprintf(stderr, "insufficient memory (vals)\n");

  for (i = 0; i < num_ops * g_num_spots; ++i) {
    g_vals[i] = rand();
  }

  return;
}

cilk void run_test(size_t num_ops)
{
  int i;
  for (i = 0; i < num_ops; ++i) {
    spawn da_batch_insert(g_array, g_vals + (i * g_num_spots),
                             g_num_spots, NULL);
    sync;
  }
}

cilk int main(int argc, char* argv[])
{
  size_t num_ops;
  size_t initial_size;

  get_options(argc, argv, &g_options);
  num_ops = g_options.operations;
  initial_size = g_options.initial_size > 0 ?
    g_options.initial_size : INIT_SIZE;

#ifdef CILK
  g_num_spots = _cilk_ws->context->Cilk_RO_params->batchvals;
#else
  g_num_spots = 1;
#endif

  spawn set_up(initial_size, num_ops);
  sync;

  timer_start();
  spawn run_test(num_ops);
  sync;
  timer_stop();

  printf("%lf\n", timer_get_wall_time());

  return 0;
}
