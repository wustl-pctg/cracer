#include <stdio.h>
#include <stdlib.h>

#ifdef CILK
#include <cilk-lib.cilkh>
#endif

#include "common.h"
#include "benchopt.h"
#include "timer.h"
#include "counter.cilkh"

int g_parfor_threshold = 32;
Counter g_counter;
counter_t* g_vals;
int g_num_spots;
BenchOptions g_options;

void set_up(counter_t init, size_t num_ops)
{
  int i;
  g_counter = ct_create_init(init);

  g_vals = malloc(sizeof(counter_t) * num_ops * g_num_spots);
  if (!g_vals) fprintf(stderr, "insufficient memory (vals)\n");

  for (i = 0; i < num_ops * g_num_spots; ++i) {
    g_vals[i] = 1;//rand();
  }

}

cilk void parfor_ct(const int begin, const int end)
{
  int i;

  if (end - begin <= g_parfor_threshold) {

    for (i = begin; i < end; ++i) {

#ifdef CILK
      ct_par_incr_val(_cilk_ws, g_counter, g_vals[i]);
#else
      ct_incr_val(g_counter, g_vals[i]);
#endif
      
    }

  } else {
    i = begin + (end - begin) / 2;
    spawn parfor_ct(begin, i);
    spawn parfor_ct(i, end);
  }
}


cilk int main(int argc, char* argv[])
{
  size_t num_ops;
  counter_t initial_value;

  get_options(argc, argv, &g_options);
  num_ops = g_options.operations;
  initial_value = (counter_t)g_options.initial_size;

#ifdef CILK
  g_num_spots = _cilk_ws->context->Cilk_RO_params->batchvals;
#else
  g_num_spots = 1;
#endif

  set_up(initial_value, num_ops);

  timer_start();
  spawn parfor_ct(0, num_ops);
  sync;
  timer_stop();

  printf("%lf\n", timer_get_wall_time());

  // @todo *if* verbose set:
  ct_print(g_counter);

  return 0;
}
