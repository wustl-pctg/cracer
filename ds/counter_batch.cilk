void ct_par_incr_val(CilkWorkerState* const ws, Counter this, counter_t val)
{
  Cilk_batchify(ws, ct_batch_incr, this, &val, sizeof(counter_t*), NULL);
}

#define left(i,d) i
#define right(i,d) i + d < num_vals ? i + d : num_vals - 1

cilk void sweep_up(counter_t* vals, size_t num_vals, int d,
                   const int begin, const int end)
{
  int i;

  if (end - begin <= PARFOR_THRESHOLD) {
    for (i = begin; i < end; ++i) {
      // Actual up-sweep.
      if (i != num_vals) vals[right(i,d)] += vals[left(i,d)];
    }
  } else {
    i = begin + (end - begin) / 2;
    spawn sweep_up(vals, num_vals, d, begin, i);
    spawn sweep_up(vals, num_vals, d, i, end);
  }
}

cilk void sweep_down(counter_t* vals, size_t num_vals, int d,
                     const int begin, const int end)
{
  int i;

  if (end - begin <= PARFOR_THRESHOLD) {
    for (i = begin; i < end; ++i) {
      // Actual down-sweep.
      int r,l,temp;
      r = right(i,d);
      l = left(i,d);
      temp = vals[r];
      vals[r] += vals[l];
      vals[l] = temp;
    }
  } else {
    i = begin + (end - begin) / 2;
    spawn sweep_down(vals, num_vals, d, begin, i);
    spawn sweep_down(vals, num_vals, d, i, end);
  }
}


cilk void ct_batch_incr(void* ds, void* data, size_t num_vals, void* res)
{
  int i;
  // int d;
  counter_t* vals = (counter_t*) data;
  Counter c = (Counter) ds;
  //  counter_t last = vals[num_vals - 1];
  counter_t temp = 0;

  for (i = 0; i < num_vals; ++i) {
    temp += vals[i];
  }
  *c += temp;

  /* for (d = 1; d <= num_vals; d <<= 1) { */
  /*   spawn sweep_up(vals, num_vals, d << 1, 0, num_vals); */
  /*   sync; */
  /* } */

  /* vals[num_vals - 1] = 0; */

  /* for (d >>= 1; d > 0; d >>= 1) { */
  /*   spawn sweep_down(vals, num_vals, d << 1, 0, num_vals); */
  /*   sync; */
  /* } */

  /* *c += last + vals[num_vals - 1]; */


  return;
}
